<!DOCTYPE html><head><meta charset="UTF-8"><title>RankOneDivergence | Eel</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Eel</a><a href="https://github.com/hugary1995/eel" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="../../eel.html">Documentation</a></li></ul><a href="#" class="sidenav-trigger" data-target="0e6ec9d8-f5b5-4d25-8261-5ff83f0f6f48"><i class="material-icons">menu</i></a><ul class="sidenav" id="0e6ec9d8-f5b5-4d25-8261-5ff83f0f6f48"><li><a href="../../eel.html">Documentation</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">kernels</span><a href="#" class="breadcrumb">RankOneDivergence</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="bd1fa146-6d2c-42c1-ba6f-ad672cb9a45a" data-section-level="1" data-section-text="RankOneDivergence"><h1 id="rankonedivergence">RankOneDivergence</h1><p>This class implements the weak form for the divergence of a vector.</p><section class="scrollspy" id="c0e59d33-4525-4fcd-98ab-baba331b6b2c" data-section-level="2" data-section-text="Overview"><h2 id="overview">Overview</h2><p>Given a strong form <span class="moose-katex-inline-equation" id="moose-equation-5bcdbb67-c5a4-434a-8f07-1c0968adc2b8"><script>var element = document.getElementById("moose-equation-5bcdbb67-c5a4-434a-8f07-1c0968adc2b8");katex.render("-\\divergence \\bfv", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, the corresponding weak form is</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-f4b5eba7-7e76-4331-84d1-a65ee207273b"></span><script>var element = document.getElementById("moose-equation-f4b5eba7-7e76-4331-84d1-a65ee207273b");katex.render("  \\left( \\grad \\psi, \\bfv \\right)_\\Omega", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span></p><p>where <span class="moose-katex-inline-equation" id="moose-equation-57a71002-bdec-4b70-ac8d-c501cc3c99dd"><script>var element = document.getElementById("moose-equation-57a71002-bdec-4b70-ac8d-c501cc3c99dd");katex.render("\\psi", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is the test function, and <span class="moose-katex-inline-equation" id="moose-equation-2c849372-0372-4c7c-984f-dab817f67584"><script>var element = document.getElementById("moose-equation-2c849372-0372-4c7c-984f-dab817f67584");katex.render("\\bfv", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is a material property of type <code>RealVectorValue</code>.</p></section><section class="scrollspy" id="a2c4d853-c596-4340-b0dd-f4f3001839d3" data-section-level="2" data-section-text="Example Input File Syntax"><h2 id="example-input-file-syntax">Example Input File Syntax</h2><pre class="moose-pre" style="max-height:350px;"><code class="language-text">[charge_balance]
  type = RankOneDivergence
  variable = Phi
  vector = i
[]
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#b1e043c6-9546-4f58-9704-ecc34d39a7ee">(test/tests/electrical/bv.i)</a></section><section class="scrollspy" id="72695fcd-b115-48f6-89c8-4dff03bf9fee" data-section-level="2" data-section-text="Input Parameters"><h2 id="input-parameters">Input Parameters</h2><section id="e1bef5c8-f3f2-418a-a106-be7a219c1a07" data-section-level="3" data-section-text="Required Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">variable</span><span class="moose-parameter-header-description">The name of the variable that this residual object operates on</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>NonlinearVariableName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The name of the variable that this residual object operates on</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">vector</span><span class="moose-parameter-header-description">The vector</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MaterialPropertyName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The vector</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Required Parameters</h3></summary></details></section><section id="583b9521-30da-4768-b988-f45f1dda13af" data-section-level="3" data-section-text="Optional Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">block</span><span class="moose-parameter-header-description">The list of blocks (ids or names) that this object will be applied</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;SubdomainName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The list of blocks (ids or names) that this object will be applied</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">displacements</span><span class="moose-parameter-header-description">The displacements</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;VariableName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The displacements</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">factor</span><span class="moose-parameter-header-default">1</span><span class="moose-parameter-header-description">The multiplication factor</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The multiplication factor</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">prop_getter_suffix</span><span class="moose-parameter-header-description">An optional suffix parameter that can be appended to any attempt to retrieve/get material properties. The suffix will be prepended with a '_' character.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MaterialPropertyName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>An optional suffix parameter that can be appended to any attempt to retrieve/get material properties. The suffix will be prepended with a '_' character.</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section id="d5e2a028-4641-4603-a519-1947832411bb" data-section-level="3" data-section-text="Tagging Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">absolute_value_vector_tags</span><span class="moose-parameter-header-description">The tags for the vectors this residual object should fill with the absolute value of the residual contribution</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;TagName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The tags for the vectors this residual object should fill with the absolute value of the residual contribution</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">extra_matrix_tags</span><span class="moose-parameter-header-description">The extra tags for the matrices this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;TagName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The extra tags for the matrices this Kernel should fill</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">extra_vector_tags</span><span class="moose-parameter-header-description">The extra tags for the vectors this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;TagName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The extra tags for the vectors this Kernel should fill</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">matrix_tags</span><span class="moose-parameter-header-default">system</span><span class="moose-parameter-header-description">The tag for the matrices this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>system</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MultiMooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>nontime, system</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The tag for the matrices this Kernel should fill</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">vector_tags</span><span class="moose-parameter-header-default">nontime</span><span class="moose-parameter-header-description">The tag for the vectors this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>nontime</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MultiMooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>nontime, time</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The tag for the vectors this Kernel should fill</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Tagging Parameters</h3></summary></details></section><section id="f3a8c899-0ad3-448a-84c2-8df124227bfe" data-section-level="3" data-section-text="Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">control_tags</span><span class="moose-parameter-header-description">Adds user-defined labels for accessing object parameters via control logic.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Adds user-defined labels for accessing object parameters via control logic.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">diag_save_in</span><span class="moose-parameter-header-description">The name of auxiliary variables to save this Kernel's diagonal Jacobian contributions to. Everything about that variable must match everything about this variable (the type, what blocks it's on, etc.)</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;AuxVariableName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The name of auxiliary variables to save this Kernel's diagonal Jacobian contributions to. Everything about that variable must match everything about this variable (the type, what blocks it's on, etc.)</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Set the enabled status of the MooseObject.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>Yes</p><p class="moose-parameter-description"><span>Description:</span>Set the enabled status of the MooseObject.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">implicit</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Determines whether this object is calculated using an implicit or explicit form</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Determines whether this object is calculated using an implicit or explicit form</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">save_in</span><span class="moose-parameter-header-description">The name of auxiliary variables to save this Kernel's residual contributions to.  Everything about that variable must match everything about this variable (the type, what blocks it's on, etc.)</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;AuxVariableName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The name of auxiliary variables to save this Kernel's residual contributions to.  Everything about that variable must match everything about this variable (the type, what blocks it's on, etc.)</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">seed</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">The seed for the master random number generator</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The seed for the master random number generator</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">use_displaced_mesh</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not this object should use the displaced mesh for computation. Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether or not this object should use the displaced mesh for computation. Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section></section><section class="scrollspy" id="2b0603d0-871e-435c-81ac-7a3c246bf7ee" data-section-level="2" data-section-text="Input Files"><h2 id="input-files">Input Files</h2><ul class="moose-list-inputs browser-default"><li><a class="moose-source-filename tooltipped modal-trigger" href="#a67c99c7-73ae-40c7-87c6-3a1125c50ea4">(test/tests/chemical-mechanical/stress_assisted_diffusion.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#ff8640c0-45cd-4d64-a9b4-7178211d13ab">(examples/SSB_3D/CC_discharging.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#08fbf40b-64e8-46b4-b63d-7b7505ba9ef9">(examples/degradation/base.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#586eb4cf-f059-4894-933a-85fc7e41b9be">(test/tests/chemical/split_condensed.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#0c383fdf-8f2f-4f4d-8f8e-d727fa959372">(examples/PCM-GF/discharging.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#6008c9f6-6cb1-454d-b653-4c373eea6fbb">(test/tests/chemical-electrical-thermal-mechanical/pressure.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#6ec41d61-87de-4b1e-a737-212a4bea90b6">(examples/SSB/CC_charging.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#e7e85e78-c6f2-45b7-a7f3-6d1223078ece">(examples/LiB/CC_discharging.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#2c36e20f-33b6-42d4-84a5-0e3e0d82ede2">(examples/SSB_3D/CV_charging.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#e2f639eb-9db4-406e-aabf-fa1b304d0dd3">(examples/PCM-GF/charging_idling.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#6c7e4690-8876-4fef-80ac-1d76866f038a">(examples/SSB/CC_discharging.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#02e91eaa-e6e5-4cf3-8bc4-fc1a48d7947b">(test/tests/chemical-electrical-thermal/thermal_effects.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#b810a154-b760-4fb5-b9fb-60a6e0ed98ef">(test/tests/electrical-thermal/jh.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#4c6516b0-8945-44d8-aeae-619f2545d28f">(examples/SSB/charging.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#f293dc76-a556-4723-8380-c3b56c35ed4e">(examples/creep-diffusion/bulk/creep-diffusion.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#e4e048e0-dcd1-41fd-a4a5-527f01dac5b1">(examples/SSB_3D/charging.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#7113a2a0-e468-4807-8357-47635a87f651">(test/tests/electrical/bv.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#09dd01fb-52ea-4f44-866c-86526e443e39">(examples/SSB/CV_charging.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#27a6e54d-c8bb-4296-932e-c46299dfc74f">(examples/LiB/CV_charging.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#621bfab7-aec2-40d0-8801-54529bfe3f88">(examples/LiB/CC_charging.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#f68d3b18-65dd-4b7d-86af-2b1304c8e51b">(examples/PCM-GF/equilibriate.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#bed5fba5-ac13-46cc-a11b-f55f1d27e768">(test/tests/chemical-electrical/diffusion_vs_migration.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#42a05f3e-3cf9-429d-93d7-2643568b6fae">(examples/cable/cable.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#edb5267d-6dc5-4cdf-9a83-8523da75fede">(test/tests/electrical/mms.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#26626e2c-fa58-49bd-ba59-98d6eff8a222">(examples/SSB_3D/CC_charging.i)</a></li></ul></section></section><div class="moose-modal modal" id="b1e043c6-9546-4f58-9704-ecc34d39a7ee"><div class="modal-content"><h4>(test/tests/electrical/bv.i)</h4><pre class="moose-pre"><code class="language-text">n = 100
sigma = 10
alpha = 0.5
i0 = 1
F = 96485
R = 8.3145
T = 300
U = 0.1

[Mesh]
  [left]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = 0
    xmax = 1
    ymin = 0
    ymax = 1
    nx = ${n}
    ny = 1
    boundary_name_prefix = anode
  []
  [right]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = 1
    xmax = 2
    ymin = 0
    ymax = 1
    nx = ${n}
    ny = 1
    boundary_name_prefix = elyte
    boundary_id_offset = 100
  []
  [stitch]
    type = StitchedMeshGenerator
    inputs = &#x27;left right&#x27;
    stitch_boundaries_pairs = &#x27;anode_right elyte_left&#x27;
  []
  [rename]
    type = RenameBoundaryGenerator
    input = stitch
    old_boundary = &#x27;anode_left elyte_right&#x27;
    new_boundary = &#x27;left right&#x27;
  []
  [anode]
    type = SubdomainBoundingBoxGenerator
    input = rename
    bottom_left = &#x27;0 0 0&#x27;
    top_right = &#x27;1 1 0&#x27;
    block_id = 0
    block_name = anode
  []
  [elyte]
    type = SubdomainBoundingBoxGenerator
    input = anode
    bottom_left = &#x27;1 0 0&#x27;
    top_right = &#x27;2 1 0&#x27;
    block_id = 1
    block_name = elyte
  []
  [break]
    type = BreakMeshByBlockGenerator
    input = elyte
    split_interface = true
    add_interface_on_two_sides = true
  []
[]

[Variables]
  [Phi]
  []
[]

[AuxVariables]
  [T]
    initial_condition = ${T}
  []
[]

[Kernels]
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
[]

[InterfaceKernels]
  [current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ibv
    boundary = &#x27;anode_elyte&#x27;
  []
[]

[Functions]
  [in]
    type = ParsedFunction
    expression = &#x27;-t&#x27;
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = Phi
    boundary = left
    value = 0
  []
  [right]
    type = FunctionNeumannBC
    variable = Phi
    boundary = right
    function = in
  []
[]

[Materials]
  [electric_constants]
    type = ADGenericConstantMaterial
    prop_names = &#x27;sigma&#x27;
    prop_values = &#x27;${sigma}&#x27;
  []
  [charge_trasport]
    type = BulkChargeTransport
    electrical_energy_density = E
    electric_potential = Phi
    electric_conductivity = sigma
  []
  [current]
    type = CurrentDensity
    current_density = i
    energy_densities = &#x27;E&#x27;
    electric_potential = Phi
  []
  [OCP_anode]
    type = ADParsedMaterial
    property_name = U
    expression = &#x27;${U}&#x27;
    boundary = &#x27;anode_elyte&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    charge_transfer_current_density = ibv
    charge_transfer_mass_flux = jbv
    charge_transfer_heat_flux = hbv
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = ${alpha}
    exchange_current_density = ${i0}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;anode_elyte&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true

  dt = 1e-3
  end_time = 1

  timestep_tolerance = 1e-10
[]

[Postprocessors]
  [Phi_r]
    type = PointValue
    variable = Phi
    point = &#x27;2 0 0&#x27;
    outputs = none
  []
  [delta_Phi]
    type = ParsedPostprocessor
    function = &#x27;-Phi_r&#x27;
    pp_names = &#x27;Phi_r&#x27;
  []
  [in]
    type = FunctionValuePostprocessor
    function = in
  []
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="a67c99c7-73ae-40c7-87c6-3a1125c50ea4"><div class="modal-content"><h4>(test/tests/chemical-mechanical/stress_assisted_diffusion.i)</h4><pre class="moose-pre"><code class="language-text"># Pumping a species from +z to -z via stress assisted diffusion

E = 100
nu = 0.3
lambda = &#x27;${fparse E*nu/(1+nu)/(1-2*nu)}&#x27;
mu = &#x27;${fparse E/2/(1+nu)}&#x27;

D = 100
Omega = 300
c0 = 1e-3

R = 8.3145
T = 300

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) zeta&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
[]

[Mesh]
  [pipe]
    type = GeneratedMeshGenerator
    dim = 3
    nx = 6
    ny = 6
    nz = 60
    zmax = 10
  []
  [right]
    type = SideSetsFromBoundingBoxGenerator
    input = pipe
    bottom_left = &#x27;0 0 5&#x27;
    top_right = &#x27;1 1 10&#x27;
    boundaries_old = &#x27;right&#x27;
    boundary_new = 11
    block_id = 0
  []
  [top]
    type = SideSetsFromBoundingBoxGenerator
    input = right
    bottom_left = &#x27;0 0 5&#x27;
    top_right = &#x27;1 1 10&#x27;
    boundaries_old = &#x27;top&#x27;
    boundary_new = 12
    block_id = 0
  []
[]

[Variables]
  [c]
    initial_condition = ${c0}
  []
  [disp_x]
  []
  [disp_y]
  []
  [disp_z]
  []
[]

[AuxVariables]
  [c0]
    initial_condition = ${c0}
  []
  [T]
    initial_condition = ${T}
  []
[]

[Kernels]
  ### Chemical
  [mass_balance_time]
    type = TimeDerivative
    variable = c
  []
  [mass_balance]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  ### Mechanical
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    tensor = P
    component = 0
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    tensor = P
    component = 1
    factor = -1
  []
  [momentum_balance_z]
    type = RankTwoDivergence
    variable = disp_z
    tensor = P
    component = 2
    factor = -1
  []
[]

[BCs]
  [x_fix]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  []
  [y_fix]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  []
  [z_fix]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  []
  [push_x]
    type = FunctionNeumannBC
    variable = disp_x
    boundary = 11
    function = ramp_x
  []
  [push_y]
    type = FunctionNeumannBC
    variable = disp_y
    boundary = 12
    function = ramp_y
  []
  [push_z]
    type = FunctionNeumannBC
    variable = disp_z
    boundary = front
    function = ramp_z
  []
[]

[Functions]
  [ramp_x]
    type = PiecewiseLinear
    x = &#x27;0 0.05&#x27;
    y = &#x27;0 ${fparse -0.1*E}&#x27;
  []
  [ramp_y]
    type = PiecewiseLinear
    x = &#x27;0 0.05&#x27;
    y = &#x27;0 ${fparse -0.1*E}&#x27;
  []
  [ramp_z]
    type = PiecewiseLinear
    x = &#x27;0 0.05&#x27;
    y = &#x27;0 ${fparse -0.1*E}&#x27;
  []
[]

[Materials]
  [mobility]
    type = ADParsedMaterial
    property_name = M
    expression = &#x27;${D}*c0/${R}/${T}&#x27;
    coupled_variables = &#x27;c0&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T
    reference_concentration = 1e-4
    reference_chemical_potential = 1e3
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu_c
    concentration = c
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu_c
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu_c
    output_properties = &#x27;j&#x27;
    outputs = &#x27;exodus&#x27;
  []
  [mechanical_parameters]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda mu beta&#x27;
    prop_values = &#x27;${lambda} ${mu} 1&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c0
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [def_grad]
    type = MechanicalDeformationGradient
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = mu
    concentration = c
  []
  [pk1_stress]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = P
    deformation_gradient_rate = dot(F)
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true

  dt = 0.001
  end_time = 0.1

  nl_rel_tol = 1e-08
  nl_abs_tol = 1e-10
[]

[Outputs]
  exodus = true
  print_linear_residuals = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="ff8640c0-45cd-4d64-a9b4-7178211d13ab"><div class="modal-content"><h4>(examples/SSB_3D/CC_discharging.i)</h4><pre class="moose-pre"><code class="language-text">I = 0.005 #mA
width = 0.05 #mm
in = &#x27;${fparse -I/width/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;

sigma_a = 0.2 #mS/mm
sigma_e = 0.1 #mS/mm
sigma_cp = 0.05 #mS/mm
sigma_ca = 0.2 #mS/mm
sigma_cm = 0.05 #mS/mm

Phi_penalty = 10

cmin_a = 1e-4 #mmol/mm^3
cmax_a = 1e-3 #mmol/mm^3
c_e = 5e-4 #mmol/mm^3
cmax_c = 1e-3 #mmol/mm^3
c_ref_entropy = 5e-5
D_cp = 5e-5 #mm^2/s
D_cm = 1e-4 #mm^2/s
D_a = 5e-4 #mm^2/s
D_e = 1e-4 #mm^2/s

c_penalty = 1

R = 8.3145 #mJ/mmol/K
T0 = 300 #K
F = 96485 #mC/mmol

i0_a = 1e-1 #mA/mm^2
i0_c = 1e-1 #mA/mm^2

E_cp = 6e4
E_cm = 5e4
E_e = 5e4
E_a = 1e5
nu_cp = 0.3
nu_cm = 0.25
nu_e = 0.25
nu_a = 0.3

u_penalty = 1e8

Omega = 140
beta = 1e-4
CTE = 1e-5

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s
htc = 9.5e-3

T_penalty = 1

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
  thermal_deformation_gradient = Ft
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Problem]
  restart_file_base = &#x27;${outname}_CV_charging_cp/LATEST&#x27;
[]

[Mesh]
  [battery]
    type = FileMeshGenerator
    file = &#x27;../coarse.e&#x27;
  []
  [scale]
    type = TransformGenerator
    input = battery
    transform = SCALE
    vector_value = &#x27;1e-3 1e-3 1e-3&#x27; #um to mm
  []
  [cathode_particle]
    type = RenameBlockGenerator
    input = scale
    old_block = &#x27;1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44&#x27;
    new_block = &#x27;cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp&#x27;
  []
  [cathode_matrix]
    type = RenameBlockGenerator
    input = cathode_particle
    old_block = &#x27;48&#x27;
    new_block = &#x27;cm&#x27;
  []
  [elyte]
    type = RenameBlockGenerator
    input = cathode_matrix
    old_block = 49
    new_block = &#x27;e&#x27;
  []
  [anode]
    type = RenameBlockGenerator
    input = elyte
    old_block = 50
    new_block = &#x27;a&#x27;
  []
  [interfaces]
    type = BreakMeshByBlockGenerator
    input = anode
    add_interface_on_two_sides = true
    split_interface = true
  []
  [sidesets]
    type = SideSetsFromNormalsGenerator
    input = interfaces
    normals = &#x27;-1 0 0 1 0 0 0 -1 0 0 1 0 0 0 -1 0 0 1&#x27;
    new_boundary = &#x27;left right bottom top back front&#x27;
  []
  use_displaced_mesh = false
[]

[Variables]
  [Phi_ca]
    block = cm
  []
  [Phi]
  []
  [c]
  []
  [disp_x]
  []
  [disp_y]
  []
  [disp_z]
  []
  [T]
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
  [stress]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = pk1
      scalar_type = Hydrostatic
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Js]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = Fs
      scalar_type = ThirdInvariant
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Jt]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = Ft
      scalar_type = ThirdInvariant
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Phi0]
  []
[]

[ICs]
  [c_ref_a]
    type = ConstantIC
    variable = c_ref
    value = ${cmin_a}
    block = &#x27;a&#x27;
  []
  [c_ref_e]
    type = ConstantIC
    variable = c_ref
    value = ${c_e}
    block = &#x27;cm e&#x27;
  []
  [c_ref_c]
    type = ConstantIC
    variable = c_ref
    value = ${cmax_c}
    block = &#x27;cp&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  [charge_balance_ca]
    type = RankOneDivergence
    variable = Phi_ca
    vector = i_ca
    block = cm
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
  [momentum_balance_z]
    type = RankTwoDivergence
    variable = disp_z
    component = 2
    tensor = pk1
    factor = -1
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [negative_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = 1
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    boundary = &#x27;a_e cm_cp e_a cp_cm&#x27;
  []
  [continuity_c]
    type = InterfaceContinuity
    variable = c
    neighbor_var = c
    penalty = ${c_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_Phi_ca]
    type = InterfaceContinuity
    variable = Phi_ca
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_cp&#x27;
  []
  [continuity_Phi]
    type = InterfaceContinuity
    variable = Phi
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_disp_x]
    type = InterfaceContinuity
    variable = disp_x
    neighbor_var = disp_x
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_disp_y]
    type = InterfaceContinuity
    variable = disp_y
    neighbor_var = disp_y
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_disp_z]
    type = InterfaceContinuity
    variable = disp_z
    neighbor_var = disp_z
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${fparse -in}&#x27;
  []
[]

[BCs]
  [current]
    type = FunctionNeumannBC
    variable = Phi
    boundary = right
    function = in
  []
  [potential]
    type = DirichletBC
    variable = Phi_ca
    boundary = left
    value = 0
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  []
  [fix_z]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back&#x27;
  []
  [hconv]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;left right&#x27;
    value = -1
    boundary_material = qconv
  []
[]

[Constraints]
  [ev_y]
    type = EqualValueBoundaryConstraint
    variable = disp_y
    penalty = ${u_penalty}
    secondary = top
  []
  [ev_z]
    type = EqualValueBoundaryConstraint
    variable = disp_z
    penalty = ${u_penalty}
    secondary = front
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;a ${sigma_a} e ${sigma_e} cm ${sigma_cm} cp ${sigma_cp}&#x27;
  []
  [conductivity_ca]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma_ca&#x27;
    subdomain_to_prop_value = &#x27;cm ${sigma_ca}&#x27;
    block = cm
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [charge_transport_ca]
    type = BulkChargeTransport
    electrical_energy_density = q_ca
    electric_potential = Phi_ca
    electric_conductivity = sigma_ca
    temperature = T
    block = cm
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
    output_properties = i
    outputs = exodus
  []
  [current_density_ca]
    type = CurrentDensity
    current_density = i_ca
    electric_potential = Phi_ca
    output_properties = i_ca
    outputs = exodus
    block = cm
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;D&#x27;
    subdomain_to_prop_value = &#x27;a ${D_a} e ${D_e} cm ${D_cm} cp ${D_cp}&#x27;
  []
  [mobility]
    type = ADParsedMaterial
    f_name = M
    args = &#x27;c_ref T_ref&#x27;
    material_property_names = &#x27;D&#x27;
    function = &#x27;D*c_ref/${R}/T_ref&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T_ref
    reference_concentration = ${c_ref_entropy}
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
    energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta m&#x27;
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
    outputs = exodus
  []

  # Redox
  [ramp]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;ramp&#x27;
    prop_values = &#x27;if(t&lt;${t0},t/${t0},1)&#x27;
  []
  [OCP_anode_graphite]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_a}; 2.77e-4*x^2-0.0069*x+0.0785&#x27;
    # function = &#x27;x:=c/${cmax_a}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;a&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_c}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;cp&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;a_e&#x27;
  []
  [charge_transfer_elyte_anode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;e_a&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cp_cm&#x27;
  []
  [charge_transfer_elyte_cathode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cm_cp&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
    output_properties = h
    outputs = exodus
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
    output_properties = r
    outputs = exodus
  []
  [conv]
    type = ADParsedMaterial
    f_name = qconv
    function = &#x27;${htc}*(T-T_ref)&#x27;
    args = &#x27;T T_ref&#x27;
    boundary = &#x27;left right&#x27;
  []

  # Mechanical
  [stiffness_cp]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cp*nu_cp/(1+nu_cp)/(1-2*nu_cp)} ${fparse E_cp/2/(1+nu_cp)}&#x27;
    block = cp
  []
  [stiffness_cm]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cm*nu_cm/(1+nu_cm)/(1-2*nu_cm)} ${fparse E_cm/2/(1+nu_cm)}&#x27;
    block = cm
  []
  [stiffness_e]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_e*nu_e/(1+nu_e)/(1-2*nu_e)} ${fparse E_e/2/(1+nu_e)}&#x27;
    block = e
  []
  [stiffness_a]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_a*nu_a/(1+nu_a)/(1-2*nu_a)} ${fparse E_a/2/(1+nu_a)}&#x27;
    block = a
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;beta&#x27;
    prop_values = &#x27;${beta}&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = T_ref
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
    non_swelling_pressure = p
    output_properties = &#x27;p&#x27;
    outputs = exodus
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi_ca
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_l - V_r&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [I]
    type = ADSideIntegralMaterialProperty
    property = i
    component = 0
    boundary = right
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;dt*I&#x27;
    pp_names = &#x27;dt I&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[UserObjects]
  [kill_V]
    type = Terminator
    expression = &#x27;V &lt;= 2.5&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options = &#x27;-ksp_converged_reason&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_interp_type -pc_hypre_boomeramg_coarsen_type -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths -pc_hypre_boomeramg_truncfactor&#x27;
  petsc_options_value = &#x27;hypre boomeramg 301 0.25 ext+i PMIS 4 2 0.4&#x27;
  automatic_scaling = true
  ignore_variables_for_autoscaling = &#x27;T&#x27;
  verbose = true
  line_search = none

  l_max_its = 300
  l_tol = 1e-6
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-9
  nl_max_its = 12

  [Predictor]
    type = SimplePredictor
    scale = 1
  []
  [TimeStepper]
    type = IterationAdaptiveDT
    dt = &#x27;${fparse t0/50}&#x27;
    optimal_iterations = 6
    iteration_window = 1
    growth_factor = 1.2
    cutback_factor = 0.2
    cutback_factor_at_failure = 0.1
    linear_iteration_ratio = 100
  []
  end_time = 10000
[]

[Outputs]
  file_base = &#x27;${outname}_CC_discharging&#x27;
  exodus = true
  csv = true
  print_linear_residuals = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="08fbf40b-64e8-46b4-b63d-7b7505ba9ef9"><div class="modal-content"><h4>(examples/degradation/base.i)</h4><pre class="moose-pre"><code class="language-text">I = 5e-4 #mA
width = 0.03 #mm
in = &#x27;${fparse -I/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;
dt = &#x27;${fparse t0/50}&#x27;

sigma_a = 1e0 #mS/mm
sigma_e = 1e-1 #mS/mm
sigma_c = 1e-2 #mS/mm

l0 = 0
l1 = 0.04
l2 = 0.07
l3 = 0.12

cmin = 1e-4 #mmol/mm^3
cmax = 1e-3 #mmol/mm^3
D_a = 1e-3 #mm^2/s
D_e = 1e-4 #mm^2/s
D_c = 5e-5 #mm^2/s
mu0 = 1e3

h0 = 1e-9
hc = 1e-3
Omega_sei = 100
A_sei = 0.8
Q_sei = 5e3
rho0_sei = 5e2

R = 8.3145 #mJ/mmol/K
T0 = 300 #K
F = 96485 #mC/mmol

i0_a = 1e-4 #mA/mm^2
i0_c = 1e-4 #mA/mm^2

E_c = 1e5
E_e = 1e4
E_a = 2e5
nu_c = 0.3
nu_e = 0.25
nu_a = 0.3

Ei = 1e7
Gi = 5e6
Acr = 1e-5
Qcr = 4e3
ncr = 5
Tn0 = 10
Gc = 2.06e-5

u_penalty = 1e8

Omega = 60
beta = 1e-3
CTE = 1e-5

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) q zeta&#x27;
  displacements = &#x27;disp_x disp_y&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
  thermal_deformation_gradient = Ft
[]

[Mesh]
  [battery]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = ${l0}
    xmax = ${l3}
    ymin = 0
    ymax = ${width}
    nx = 60
    ny = 1
  []
  [anode]
    type = SubdomainBoundingBoxGenerator
    input = battery
    block_id = 1
    block_name = anode
    bottom_left = &#x27;${l0} 0 0&#x27;
    top_right = &#x27;${l1} ${width} 0&#x27;
  []
  [elyte]
    type = SubdomainBoundingBoxGenerator
    input = anode
    block_id = 2
    block_name = elyte
    bottom_left = &#x27;${l1} 0 0&#x27;
    top_right = &#x27;${l2} ${width} 0&#x27;
  []
  [cathode]
    type = SubdomainBoundingBoxGenerator
    input = elyte
    block_id = 3
    block_name = cathode
    bottom_left = &#x27;${l2} 0 0&#x27;
    top_right = &#x27;${l3} ${width} 0&#x27;
  []
  [interfaces]
    type = BreakMeshByBlockGenerator
    input = cathode
    add_interface_on_two_sides = true
    split_interface = true
  []
  use_displaced_mesh = false
[]

[Variables]
  [Phi]
  []
  [c]
  []
  [disp_x]
  []
  [disp_y]
  []
[]

[AuxVariables]
  [c_ref]
  []
  [Phi0]
  []
  [T]
    initial_condition = ${T0}
  []
  [T_ref]
    initial_condition = ${T0}
  []
[]

[ICs]
  [c_ref_min]
    type = ConstantIC
    variable = c_ref
    value = ${cmin}
    block = &#x27;anode&#x27;
  []
  [c_ref_mid]
    type = ConstantIC
    variable = c_ref
    value = &#x27;${fparse (cmax+cmin)/2}&#x27;
    block = &#x27;elyte&#x27;
  []
  [c_ref_max]
    type = ConstantIC
    variable = c_ref
    value = ${cmax}
    block = &#x27;cathode&#x27;
  []
[]

[AuxKernels]
  [Phi0]
    type = ParsedAux
    variable = Phi0
    expression = &#x27;Phi&#x27;
    coupled_variables = &#x27;Phi&#x27;
    execute_on = &#x27;INITIAL&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
[]

[Modules]
  [TensorMechanics]
    [CohesiveZoneMaster]
      [interface]
        boundary = &#x27;anode_elyte&#x27;
        strain = SMALL
        use_automatic_differentiation = true
      []
    []
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    boundary = &#x27;cathode_elyte&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;anode_elyte&#x27;
  []
  [negative_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = -1
    boundary = &#x27;cathode_elyte&#x27;
  []
  [positive_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    boundary = &#x27;anode_elyte&#x27;
  []
  [continuity_disp_x]
    type = InterfaceContinuity
    variable = disp_x
    neighbor_var = disp_x
    penalty = ${u_penalty}
    boundary = &#x27;cathode_elyte&#x27;
  []
  [continuity_disp_y]
    type = InterfaceContinuity
    variable = disp_y
    neighbor_var = disp_y
    penalty = ${u_penalty}
    boundary = &#x27;cathode_elyte&#x27;
  []
[]

[BCs]
  [pull_x]
    type = NeumannBC
    variable = disp_x
    value = 1
    boundary = &#x27;right&#x27;
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left&#x27;
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${in}&#x27;
  []
  [in_discharging]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${fparse -in}&#x27;
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;anode ${sigma_a} elyte ${sigma_e} cathode ${sigma_c}&#x27;
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;D&#x27;
    subdomain_to_prop_value = &#x27;anode ${D_a} elyte ${D_e} cathode ${D_c}&#x27;
  []
  [mobility]
    type = ADParsedMaterial
    property_name = M
    coupled_variables = &#x27;c_ref T_ref&#x27;
    material_property_names = &#x27;D&#x27;
    expression = &#x27;D*c_ref/${R}/T_ref&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T
    reference_concentration = c_ref
    reference_chemical_potential = ${mu0}
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
  []

  # Redox
  [OCP_anode_graphite]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax}; (2.77e-4*x^2-0.0069*x+0.0785)&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    boundary = &#x27;anode_elyte&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    boundary = &#x27;cathode_elyte&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    interface_resistance = rho_sei
    degradation = g
    boundary = &#x27;anode_elyte&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cathode_elyte&#x27;
  []
  [SEI]
    type = SEIGrowth
    thickness = h_sei
    initial_thickness = ${h0}
    charge_transfer_mass_flux = je
    characteristic_thickness = ${hc}
    molar_volume = ${Omega_sei}
    correction = ${A_sei}
    activation_energy = ${Q_sei}
    ideal_gas_constant = ${R}
    temperature = T
    boundary = &#x27;anode_elyte&#x27;
  []
  [SEI_resistance]
    type = ADParsedMaterial
    property_name = rho_sei
    expression = &#x27;${rho0_sei} * h_sei&#x27;
    material_property_names = &#x27;h_sei&#x27;
    boundary = &#x27;anode_elyte&#x27;
  []

  # Mechanical
  [stiffness_c]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_c*nu_c/(1+nu_c)/(1-2*nu_c)} ${fparse E_c/2/(1+nu_c)}&#x27;
    block = cathode
  []
  [stiffness_e]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_e*nu_e/(1+nu_e)/(1-2*nu_e)} ${fparse E_e/2/(1+nu_e)}&#x27;
    block = elyte
  []
  [stiffness_a]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_a*nu_a/(1+nu_a)/(1-2*nu_a)} ${fparse E_a/2/(1+nu_a)}&#x27;
    block = anode
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;beta&#x27;
    prop_values = &#x27;${beta}&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = T_ref
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
  [traction]
    type = InterfaceTractionWithCreepDegradation
    normal_stiffness = ${Ei}
    tangential_stiffness = ${Gi}
    normal_traction = Tn
    activation_energy = ${Qcr}
    ideal_gas_constant = ${R}
    temperature = T
    damage = Di
    degradation = g
    creep_displacement_jump = juc
    fracture_driving_energy = psi_f
    energy_release_rate = ${Gc}
    reference_normal_traction = ${Tn0}
    creep_coefficient = ${Acr}
    creep_exponent = ${ncr}
    residual_stiffness = 1e-4
    boundary = &#x27;anode_elyte&#x27;
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_r - V_l&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [I]
    type = ADSideIntegralMaterialProperty
    property = i
    component = 0
    boundary = right
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;-dt*I&#x27;
    pp_names = &#x27;dt I&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_a_max]
    type = NodalExtremeValue
    variable = c
    value_type = max
    block = anode
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_c_min]
    type = NodalExtremeValue
    variable = c
    value_type = min
    block = cathode
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_a_min]
    type = NodalExtremeValue
    variable = c
    value_type = min
    block = anode
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_c_max]
    type = NodalExtremeValue
    variable = c
    value_type = max
    block = cathode
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_a]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_e]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = elyte
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_c]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [SEI_thickness]
    type = ADSideAverageMaterialProperty
    property = h_sei
    boundary = &#x27;anode_elyte&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [Di]
    type = ADSideAverageMaterialProperty
    property = Di
    boundary = &#x27;anode_elyte&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [psi_f]
    type = ADSideAverageMaterialProperty
    property = psi_f
    boundary = &#x27;anode_elyte&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dV]
    type = ChangeOverTimePostprocessor
    postprocessor = V
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [target_V_dt]
    type = ParsedPostprocessor
    function = &#x27;if(abs(dV)&gt;0.01,${dt},1e6)&#x27;
    pp_names = &#x27;dV&#x27;
    outputs = none
    execute_on = &#x27;TIMESTEP_END&#x27;
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="586eb4cf-f059-4894-933a-85fc7e41b9be"><div class="modal-content"><h4>(test/tests/chemical/split_condensed.i)</h4><pre class="moose-pre"><code class="language-text">R = 8.3145
T = 300
M = 4e-5

[GlobalParams]
  energy_densities = &#x27;dot(psi_c) zeta&#x27;
[]

[Mesh]
  [battery]
    type = GeneratedMeshGenerator
    dim = 3
    xmax = 10
    nx = 10
  []
[]

[Variables]
  [c]
    [InitialCondition]
      type = FunctionIC
      function = &#x27;-(x-5)^2/25+1&#x27;
    []
  []
[]

[AuxVariables]
  [c0]
    initial_condition = 1e-1
  []
  [T]
    initial_condition = ${T}
  []
[]

[Kernels]
  [mass_balance_time]
    type = TimeDerivative
    variable = c
  []
  [mass_balance]
    type = RankOneDivergence
    variable = c
    vector = j
  []
[]

[Materials]
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T
    reference_concentration = c0
    reference_chemical_potential = 1e3
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = ${M}
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
  []
[]

[Postprocessors]
  [total_mass]
    type = ElementIntegralVariablePostprocessor
    variable = c
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true
  ignore_variables_for_autoscaling = &#x27;c&#x27;

  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-8
  nl_max_its = 20

  dt = 1
  end_time = 10
[]

[Outputs]
  exodus = true
  print_linear_residuals = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="0c383fdf-8f2f-4f4d-8f8e-d727fa959372"><div class="modal-content"><h4>(examples/PCM-GF/discharging.i)</h4><pre class="moose-pre"><code class="language-text"># units are in meter kelvin second (m,kg,s)

end_time = 14400 # 4 hrs

dtmax = 5
dt = 1

sigma_PCM = 5 # (from Wen&#x27;s measurement of Gfoam+PCM in radial direction) (from Cfoam 70% dense foam = 28571.43) S/m (1/electrical resistivity (0.000035 ohm-m))
kappa_PCM = 10 #18.8 # (average of Kxy = 14 W/m-K, Kz = 23.6 W/mK at T=700C) #from Singh et al. Solar energy 159(2018) 270-282 (Prototype 1)
rho_PCM = 2050 # kg/m^3 #from Singh et al. Solar energy 159(2018) 270-282 (Prototype 1)
cp_PCM = 1074 # J/kg-K #from Singh et al. Solar energy 159(2018) 270-282 (Prototype 1)

sigma_pipe = 750750.75 # S/m (resistivity 1.332e-6 ohm-m at T = 700C) #Special metal data sheet
kappa_pipe = 23.9 # W/m-K (at 700C) #Special metal datasheet
rho_pipe = 8359.33 #kg/m^3
cp_pipe = 419 # J/kg-K

sigma_gas = 1e-12
kappa_gas = 0.03 #file:///C:/Users/barua/Downloads/PDS-FOAMGLAS%20ONE-US-en.pdf
rho_gas = 1.29 #file:///C:/Users/barua/Downloads/PDS-FOAMGLAS%20ONE-US-en.pdf
cp_gas = 1000 #file:///C:/Users/barua/Downloads/PDS-FOAMGLAS%20ONE-US-en.pdf

htc_gas = 0.1
T_inf_gas = 500

htc_insul = 5
T_inf_insul = 300

T_target = 800

[GlobalParams]
  energy_densities = &#x27;E H&#x27;
[]

[Mesh]
  [fmg]
    type = FileMeshGenerator
    file = &#x27;equilibriate_out.e&#x27;
    use_for_exodus_restart = true
  []
  coord_type = RZ
[]

[Variables]
  [Phi]
  []
  [T]
    initial_from_file_var = T
  []
  [v]
    family = LAGRANGE_VEC
    block = gas
  []
  [p]
    block = gas
  []
[]

[ICs]
  [vel]
    type = VectorConstantIC
    variable = v
    x_value = 1e-15
    y_value = 1e-15
    block = gas
  []
[]

[AuxVariables]
  [T_old]
    [AuxKernel]
      type = ParsedAux
      expression = &#x27;T&#x27;
      coupled_variables = &#x27;T&#x27;
      execute_on = &#x27;INITIAL TIMESTEP_BEGIN&#x27;
    []
  []
[]

[Kernels]
  [mass]
    type = INSADMass
    variable = p
    block = gas
  []
  [pspg]
    type = INSADMassPSPG
    variable = p
    block = gas
  []
  [momentum_convection]
    type = INSADMomentumAdvection
    variable = v
    block = gas
  []
  [momentum_viscous]
    type = INSADMomentumViscous
    variable = v
    block = gas
  []
  [momentum_pressure]
    type = INSADMomentumPressure
    variable = v
    pressure = p
    integrate_p_by_parts = true
    block = gas
  []
  [momentum_supg]
    type = INSADMomentumSUPG
    variable = v
    velocity = v
    block = gas
  []

  [temperature_advection]
    type = INSADEnergyAdvection
    variable = T
    block = gas
  []
  [temperature_supg]
    type = INSADEnergySUPG
    variable = T
    velocity = v
    block = gas
  []
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cp
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [energy_balance_3]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[BCs]
  [ground]
    type = DirichletBC
    variable = Phi
    boundary = &#x27;PCM_left&#x27;
    value = 0
  []
  [voltage]
    type = TargetFeedbackDirichletBC
    variable = Phi
    monitor = T_outlet
    target = ${T_target}
    window = &#x27;${fparse 0.02*T_target}&#x27;
    idle_value = 0
    maintain_value = 12
    compensate_value = 20
    boundary = &#x27;PCM_right&#x27;
  []
  [T_inlet]
    type = DirichletBC
    variable = T
    value = 300
    boundary = &#x27;inlet&#x27;
  []
  [velocity_inlet]
    type = VectorFunctionDirichletBC
    variable = v
    function_y = 0.1
    boundary = &#x27;inlet&#x27;
  []
  [wall]
    type = VectorFunctionDirichletBC
    variable = v
    boundary = &#x27;wall&#x27;
  []
  [hconv_outlet]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;outlet&#x27;
    value = -1
    boundary_material = qconv_outlet
  []
  [hconv_insul]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;insul PCM_right&#x27;
    value = -1
    boundary_material = qconv_insul
  []
[]

[Materials]
  [constant]
    type = ADGenericConstantMaterial
    prop_names = &#x27;mu&#x27;
    prop_values = &#x27;1.8e-5&#x27;
  []
  [ins]
    type = INSADStabilized3Eqn
    pressure = p
    velocity = v
    temperature = T
    k_name = kappa
    block = gas
  []
  [electrical_conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = sigma
    subdomain_to_prop_value = &#x27;PCM ${sigma_PCM} pipe ${sigma_pipe} gas ${sigma_gas}&#x27;
  []
  [charge_trasport]
    type = BulkChargeTransport
    electrical_energy_density = E
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [current]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
  []
  [thermal_conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = kappa
    subdomain_to_prop_value = &#x27;PCM ${kappa_PCM} pipe ${kappa_pipe} gas ${kappa_gas}&#x27;
  []
  [density]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = rho
    subdomain_to_prop_value = &#x27;PCM ${rho_PCM} pipe ${rho_pipe} gas ${rho_gas}&#x27;
  []
  [specific_heat]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = cp
    subdomain_to_prop_value = &#x27;PCM ${cp_PCM} pipe ${cp_pipe} gas ${cp_gas}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = H
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
  []
  [qconv_outlet]
    type = ADParsedMaterial
    property_name = qconv_outlet
    expression = &#x27;htc*(T-T_inf)&#x27;
    coupled_variables = &#x27;T&#x27;
    constant_names = &#x27;htc T_inf&#x27;
    constant_expressions = &#x27;${htc_gas} ${T_inf_gas}&#x27;
    boundary = &#x27;outlet&#x27;
  []
  [qconv_insul]
    type = ADParsedMaterial
    property_name = qconv_insul
    expression = &#x27;htc*(T-T_inf)&#x27;
    coupled_variables = &#x27;T&#x27;
    constant_names = &#x27;htc T_inf&#x27;
    constant_expressions = &#x27;${htc_insul} ${T_inf_insul}&#x27;
    boundary = &#x27;insul PCM_right&#x27;
  []
  [delta_enthalpy]
    type = ADParsedMaterial
    property_name = delta_enthalpy
    expression = &#x27;rho*cp*(T-T_old)/2&#x27;
    material_property_names = &#x27;rho cp&#x27;
    coupled_variables = &#x27;T T_old&#x27;
  []
[]

[Postprocessors]
  [T_outlet]
    type = SideAverageValue
    variable = T
    boundary = &#x27;outlet&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type&#x27;
  petsc_options_value = &#x27;lu       NONZERO&#x27;
  automatic_scaling = true

  end_time = ${end_time}
  dtmax = ${dtmax}
  dtmin = 0.01
  [TimeStepper]
    type = IterationAdaptiveDT
    dt = ${dt}
    cutback_factor = 0.2
    cutback_factor_at_failure = 0.1
    growth_factor = 1.2
    optimal_iterations = 7
    iteration_window = 2
    linear_iteration_ratio = 100000
  []
  [Predictor]
    type = SimplePredictor
    scale = 1
    skip_after_failed_timestep = true
  []

  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-6
  nl_max_its = 12
[]

[Outputs]
  file_base = &#x27;T_target_${T_target}&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="6008c9f6-6cb1-454d-b653-4c373eea6fbb"><div class="modal-content"><h4>(test/tests/chemical-electrical-thermal-mechanical/pressure.i)</h4><pre class="moose-pre"><code class="language-text">R = 8.3145 #mJ/mmol/K
F = 96485 #mC/mmol

I = 3e-3 #mA
width = 0.03 #mm
in = &#x27;${fparse -I/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;
dt = &#x27;${fparse t0/100}&#x27;
Vmax = 4.3 #V

vf_se = 0.3
vf_cp = 0.5
vf_ca = 0.2

sigma_a = 0.2 #mS/mm
sigma_se = 0.1 #mS/mm
sigma_cp = 0.05 #mS/mm
sigma_ca = 0.2 #mS/mm
sigma_e = ${sigma_se}
sigma_c = &#x27;${fparse vf_se*sigma_se + vf_cp*sigma_cp + vf_ca*sigma_ca}&#x27;

l0 = 0
l1 = 0.04
l2 = 0.07
l3 = 0.12

cmax = 1e-3 #mmol/mm^3
c0_a = 1e-4
c0_e = 5e-4
c0_c = 1e-3

M_a = 8e-11
M_se = 1e-11
M_cp = 4e-14
M_ca = 1e-13
M_e = ${M_se}
M_c = &#x27;${fparse vf_se*M_se + vf_cp*M_cp + vf_ca*M_ca}&#x27;

T0 = 300 #K

i0_a = 0.1 #mA/mm^2
i0_c = 0.1 #mA/mm^2

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s
hconv = 9.5e-3 #mJ/mm^2/K/s

T_penalty = 2e-1

E_e = 1e4
E_a = 2e5
nu_e = 0.25
nu_a = 0.3
nu_c = 0.3

d = 0
E_e_bar = &#x27;${fparse E_e/(1-nu_e*nu_e)}&#x27;
E_c_bar = &#x27;${fparse (1+d)/(1-d)*E_e_bar}&#x27;
E_c = &#x27;${fparse (1-nu_c*nu_c)*E_c_bar}&#x27;

Omega = 140
beta = 1
CTE = 1e-5

u_penalty = 1e8

P = 10
center = 0.12
spread = 0.01

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) q zeta chi m&#x27;
  displacements = &#x27;disp_x disp_y&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
  thermal_deformation_gradient = Ft
[]

[Mesh]
  [battery]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = ${l0}
    xmax = ${l3}
    ymin = 0
    ymax = ${width}
    nx = 60
    ny = 15
  []
  [anode]
    type = SubdomainBoundingBoxGenerator
    input = battery
    block_id = 1
    block_name = anode
    bottom_left = &#x27;${l0} 0 0&#x27;
    top_right = &#x27;${l1} ${width} 0&#x27;
  []
  [elyte]
    type = SubdomainBoundingBoxGenerator
    input = anode
    block_id = 2
    block_name = elyte
    bottom_left = &#x27;${l1} 0 0&#x27;
    top_right = &#x27;${l2} ${width} 0&#x27;
  []
  [cathode]
    type = SubdomainBoundingBoxGenerator
    input = elyte
    block_id = 3
    block_name = cathode
    bottom_left = &#x27;${l2} 0 0&#x27;
    top_right = &#x27;${l3} ${width} 0&#x27;
  []
  [anode_elyte]
    type = BreakMeshByBlockGenerator
    input = cathode
    block_pairs = &#x27;1 2&#x27;
    add_interface_on_two_sides = true
    split_interface = true
  []
  [cathode_elyte]
    type = BreakMeshByBlockGenerator
    input = anode_elyte
    block_pairs = &#x27;2 3&#x27;
    add_interface_on_two_sides = true
    split_interface = true
  []
[]

[Variables]
  [Phi]
  []
  [c]
  []
  [T]
    initial_condition = ${T0}
  []
  [disp_x]
  []
  [disp_y]
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
  [j]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADMaterialRealVectorValueAux
      property = j
      component = 0
    []
  []
[]

[ICs]
  [c_a]
    type = ConstantIC
    variable = c
    value = ${c0_a}
    block = &#x27;anode&#x27;
  []
  [c_e]
    type = ConstantIC
    variable = c
    value = ${c0_e}
    block = &#x27;elyte&#x27;
  []
  [c_c]
    type = ConstantIC
    variable = c
    value = ${c0_c}
    block = &#x27;cathode&#x27;
  []
  [c_ref_a]
    type = ConstantIC
    variable = c_ref
    value = ${c0_a}
    block = &#x27;anode&#x27;
  []
  [c_ref_e]
    type = ConstantIC
    variable = c_ref
    value = ${c0_e}
    block = &#x27;elyte&#x27;
  []
  [c_ref_c]
    type = ConstantIC
    variable = c_ref
    value = ${c0_c}
    block = &#x27;cathode&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
    use_displaced_mesh = true
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
    use_displaced_mesh = true
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
    use_displaced_mesh = true
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    factor_neighbor = 1
    boundary = &#x27;cathode_elyte&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;anode_elyte&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    factor_neighbor = 1
    boundary = &#x27;anode_elyte cathode_elyte&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
  [continuity_disp_x]
    type = InterfaceContinuity
    variable = disp_x
    neighbor_var = disp_x
    penalty = ${u_penalty}
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
  [continuity_disp_y]
    type = InterfaceContinuity
    variable = disp_y
    neighbor_var = disp_y
    penalty = ${u_penalty}
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${in}&#x27;
  []
[]

[BCs]
  [left]
    type = FunctionNeumannBC
    variable = Phi
    boundary = left
    function = in
  []
  [right]
    type = DirichletBC
    variable = Phi
    boundary = right
    value = 0
  []
  [open]
    type = OpenBC
    variable = c
    flux = jm
    boundary = &#x27;left right&#x27;
  []
  [hconv]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;left right&#x27;
    value = -1
    boundary_material = qconv
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  []
  [traction]
    enable = false
    type = FunctionNeumannBC
    variable = disp_y
    boundary = &#x27;top&#x27;
    function = &#x27;-if(t&lt;${t0},t/${t0}*${P},${P})/${spread}/sqrt(2*pi)*exp(-0.5*(x-${center})^2/${spread}^2)&#x27;
  []
[]

[Constraints]
  [y]
    enable = false
    type = EqualValueBoundaryConstraint
    variable = disp_y
    penalty = ${u_penalty}
    secondary = top
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;anode ${sigma_a} elyte ${sigma_e} cathode ${sigma_c}&#x27;
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
  []

  # Migration
  [migration]
    type = Migration
    electrochemical_energy_density = m
    electric_potential = Phi
    chemical_potential = mu
    electric_conductivity = sigma
    faraday_constant = ${F}
  []
  [migration_flux]
    type = MassFlux
    mass_flux = jm
    energy_densities = &#x27;m&#x27;
    chemical_potential = mu
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;M&#x27;
    subdomain_to_prop_value = &#x27;anode ${M_a} elyte ${M_e} cathode ${M_c}&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T
    reference_concentration = c_ref
    reference_chemical_potential = 1e3
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
  []

  # Redox
  [ramp]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;ramp&#x27;
    prop_values = &#x27;if(t&lt;${t0},t/${t0},1)&#x27;
  []
  [OCP_anode_graphite]
    type = ADParsedMaterial
    property_name = U
    expression = &#x27;x:=c/${cmax}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)*ramp&#x27;
    coupled_variables = c
    material_property_names = &#x27;ramp&#x27;
    boundary = &#x27;anode_elyte&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    property_name = U
    expression = &#x27;x:=c/${cmax}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)*ramp&#x27;
    coupled_variables = c
    material_property_names = &#x27;ramp&#x27;
    boundary = &#x27;cathode_elyte&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;anode_elyte&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cathode_elyte&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
  []
  [qconv]
    type = ADParsedMaterial
    property_name = qconv
    expression = &#x27;htc*(T-T_inf)&#x27;
    coupled_variables = &#x27;T&#x27;
    constant_names = &#x27;htc T_inf&#x27;
    constant_expressions = &#x27;${hconv} ${T0}&#x27;
    boundary = &#x27;left right&#x27;
  []

  # Mechanical
  [stiffness_c]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_c*nu_c/(1+nu_c)/(1-2*nu_c)} ${fparse E_c/2/(1+nu_c)}&#x27;
    block = cathode
  []
  [stiffness_e]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_e*nu_e/(1+nu_e)/(1-2*nu_e)} ${fparse E_e/2/(1+nu_e)}&#x27;
    block = elyte
  []
  [stiffness_a]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_a*nu_a/(1+nu_a)/(1-2*nu_a)} ${fparse E_a/2/(1+nu_a)}&#x27;
    block = anode
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;beta&#x27;
    prop_values = &#x27;${beta}&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = T_ref
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
    displacements = &#x27;disp_x disp_y&#x27;
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
    non_swelling_pressure = p
    output_properties = &#x27;p&#x27;
    outputs = exodus
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_r - V_l&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [in]
    type = FunctionValuePostprocessor
    function = in
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;-dt*in*${width}&#x27;
    pp_names = &#x27;dt in&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_a_max]
    type = NodalExtremeValue
    variable = c
    value_type = max
    block = anode
  []
  [c_c_min]
    type = NodalExtremeValue
    variable = c
    value_type = min
    block = cathode
  []
  [mass_a]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_e]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = elyte
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_c]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [E_c_bar]
    type = ParsedPostprocessor
    function = &#x27;${E_c_bar}&#x27;
    execute_on = INITIAL
    pp_names = &#x27;&#x27;
  []
[]

[UserObjects]
  [kill]
    type = Terminator
    expression = &#x27;V &gt;= ${Vmax}&#x27;
    message = &#x27;Voltage reached Vmax&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true
  line_search = none

  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-10
  nl_max_its = 20
  l_max_its = 150

  [Predictor]
    type = SimplePredictor
    scale = 1
    skip_after_failed_timestep = true
  []

  [TimeStepper]
    type = IterationAdaptiveDT
    dt = ${dt}
    optimal_iterations = 7
    iteration_window = 2
    growth_factor = 1.2
    cutback_factor = 0.5
    cutback_factor_at_failure = 0.2
    linear_iteration_ratio = 1000000
  []
  dtmax = 1
  end_time = 100000
[]

[Outputs]
  exodus = true
  print_linear_residuals = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="6ec41d61-87de-4b1e-a737-212a4bea90b6"><div class="modal-content"><h4>(examples/SSB/CC_charging.i)</h4><pre class="moose-pre"><code class="language-text">I = 0.005 #mA
width = 0.05 #mm
in = &#x27;${fparse -I/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;

sigma_a = 0.2 #mS/mm
sigma_e = 0.1 #mS/mm
sigma_cp = 0.05 #mS/mm
sigma_ca = 0.2 #mS/mm
sigma_cm = 0.05 #mS/mm

Phi_penalty = 10

cmin_a = 1e-4 #mmol/mm^3
cmax_a = 1e-3 #mmol/mm^3
c_e = 5e-4 #mmol/mm^3
cmax_c = 1e-3 #mmol/mm^3
c_ref_entropy = 5e-5
D_cp = 5e-5 #mm^2/s
D_cm = 1e-4 #mm^2/s
D_a = 5e-4 #mm^2/s
D_e = 1e-4 #mm^2/s

c_penalty = 1

R = 8.3145 #mJ/mmol/K
T0 = 300 #K
F = 96485 #mC/mmol

i0_a = 1e-1 #mA/mm^2
i0_c = 1e-1 #mA/mm^2

E_cp = 6e4
E_cm = 5e4
E_e = 5e4
E_a = 1e5
nu_cp = 0.3
nu_cm = 0.25
nu_e = 0.25
nu_a = 0.3

u_penalty = 1e8

Omega = 140
beta = 1e-4
CTE = 1e-5

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s
htc = 9.5e-3

T_penalty = 1

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
  thermal_deformation_gradient = Ft
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  [battery]
    type = FileMeshGenerator
    file = &#x27;gold/ssb.msh&#x27;
  []
  [interfaces]
    type = BreakMeshByBlockGenerator
    input = battery
    add_interface_on_two_sides = true
    split_interface = true
  []
  use_displaced_mesh = false
[]

[Variables]
  [Phi_ca]
    block = cm
  []
  [Phi]
  []
  [c]
  []
  [disp_x]
  []
  [disp_y]
  []
  [T]
    initial_condition = ${T0}
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
  [stress]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = pk1
      scalar_type = Hydrostatic
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Js]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = Fs
      scalar_type = ThirdInvariant
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Jt]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = Ft
      scalar_type = ThirdInvariant
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Phi0]
  []
[]

[ICs]
  [c_a]
    type = ConstantIC
    variable = c
    value = ${cmin_a}
    block = &#x27;a&#x27;
  []
  [c_e]
    type = ConstantIC
    variable = c
    value = ${c_e}
    block = &#x27;cm e&#x27;
  []
  [c_c]
    type = ConstantIC
    variable = c
    value = ${cmax_c}
    block = &#x27;cp&#x27;
  []
  [c_ref_a]
    type = ConstantIC
    variable = c_ref
    value = ${cmin_a}
    block = &#x27;a&#x27;
  []
  [c_ref_e]
    type = ConstantIC
    variable = c_ref
    value = ${c_e}
    block = &#x27;cm e&#x27;
  []
  [c_ref_c]
    type = ConstantIC
    variable = c_ref
    value = ${cmax_c}
    block = &#x27;cp&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  [charge_balance_ca]
    type = RankOneDivergence
    variable = Phi_ca
    vector = i_ca
    block = cm
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [negative_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = 1
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    boundary = &#x27;a_e cm_cp e_a cp_cm&#x27;
  []
  [continuity_c]
    type = InterfaceContinuity
    variable = c
    neighbor_var = c
    penalty = ${c_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_Phi_ca]
    type = InterfaceContinuity
    variable = Phi_ca
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_cp&#x27;
  []
  [continuity_Phi]
    type = InterfaceContinuity
    variable = Phi
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_disp_x]
    type = InterfaceContinuity
    variable = disp_x
    neighbor_var = disp_x
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_disp_y]
    type = InterfaceContinuity
    variable = disp_y
    neighbor_var = disp_y
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${in}&#x27;
  []
[]

[BCs]
  [current]
    type = FunctionNeumannBC
    variable = Phi
    boundary = right
    function = in
  []
  [potential]
    type = DirichletBC
    variable = Phi_ca
    boundary = left
    value = 0
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  []
  [hconv]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;left right&#x27;
    value = -1
    boundary_material = qconv
  []
[]

[Constraints]
  [ev_y]
    type = EqualValueBoundaryConstraint
    variable = disp_y
    penalty = ${u_penalty}
    secondary = top
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;a ${sigma_a} e ${sigma_e} cm ${sigma_cm} cp ${sigma_cp}&#x27;
  []
  [conductivity_ca]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma_ca&#x27;
    subdomain_to_prop_value = &#x27;cm ${sigma_ca}&#x27;
    block = cm
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [charge_transport_ca]
    type = BulkChargeTransport
    electrical_energy_density = q_ca
    electric_potential = Phi_ca
    electric_conductivity = sigma_ca
    temperature = T
    block = cm
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
    output_properties = i
    outputs = exodus
  []
  [current_density_ca]
    type = CurrentDensity
    current_density = i_ca
    electric_potential = Phi_ca
    output_properties = i_ca
    outputs = exodus
    block = cm
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;D&#x27;
    subdomain_to_prop_value = &#x27;a ${D_a} e ${D_e} cm ${D_cm} cp ${D_cp}&#x27;
  []
  [mobility]
    type = ADParsedMaterial
    f_name = M
    args = &#x27;c_ref T_ref&#x27;
    material_property_names = &#x27;D&#x27;
    function = &#x27;D*c_ref/${R}/T_ref&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T_ref
    reference_concentration = ${c_ref_entropy}
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
    energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta m&#x27;
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
    outputs = exodus
  []

  # Redox
  [ramp]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;ramp&#x27;
    prop_values = &#x27;if(t&lt;${t0},t/${t0},1)&#x27;
  []
  [OCP_anode_graphite]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_a}; 2.77e-4*x^2-0.0069*x+0.0785&#x27;
    # function = &#x27;x:=c/${cmax_a}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;a&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_c}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;cp&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;a_e&#x27;
  []
  [charge_transfer_elyte_anode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;e_a&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cp_cm&#x27;
  []
  [charge_transfer_elyte_cathode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cm_cp&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
    output_properties = h
    outputs = exodus
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
    output_properties = r
    outputs = exodus
  []
  [conv]
    type = ADParsedMaterial
    f_name = qconv
    function = &#x27;${htc}*(T-T_ref)&#x27;
    args = &#x27;T T_ref&#x27;
    boundary = &#x27;left right&#x27;
  []

  # Mechanical
  [stiffness_cp]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cp*nu_cp/(1+nu_cp)/(1-2*nu_cp)} ${fparse E_cp/2/(1+nu_cp)}&#x27;
    block = cp
  []
  [stiffness_cm]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cm*nu_cm/(1+nu_cm)/(1-2*nu_cm)} ${fparse E_cm/2/(1+nu_cm)}&#x27;
    block = cm
  []
  [stiffness_e]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_e*nu_e/(1+nu_e)/(1-2*nu_e)} ${fparse E_e/2/(1+nu_e)}&#x27;
    block = e
  []
  [stiffness_a]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_a*nu_a/(1+nu_a)/(1-2*nu_a)} ${fparse E_a/2/(1+nu_a)}&#x27;
    block = a
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;beta&#x27;
    prop_values = &#x27;${beta}&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = T_ref
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
    non_swelling_pressure = p
    output_properties = &#x27;p&#x27;
    outputs = exodus
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi_ca
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_l - V_r&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [I]
    type = ADSideIntegralMaterialProperty
    property = i
    component = 0
    boundary = right
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;dt*I&#x27;
    pp_names = &#x27;dt I&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[UserObjects]
  [kill_V]
    type = Terminator
    expression = &#x27;V &gt;= 4.6&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options = &#x27;-ksp_converged_reason&#x27;
  # petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_interp_type -pc_hypre_boomeramg_coarsen_type -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths -pc_hypre_boomeramg_truncfactor&#x27;
  # petsc_options_value = &#x27;hypre boomeramg 301 0.25 ext+i PMIS 4 2 0.4&#x27;
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true
  ignore_variables_for_autoscaling = &#x27;T&#x27;
  verbose = true
  line_search = none

  l_max_its = 300
  l_tol = 1e-6
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-9
  nl_max_its = 12

  [Predictor]
    type = SimplePredictor
    scale = 1
  []
  [TimeStepper]
    type = IterationAdaptiveDT
    dt = &#x27;${fparse t0/50}&#x27;
    optimal_iterations = 6
    iteration_window = 1
    growth_factor = 1.2
    cutback_factor = 0.2
    cutback_factor_at_failure = 0.1
    linear_iteration_ratio = 100
  []
  end_time = 10000
[]

[Outputs]
  exodus = true
  csv = true
  print_linear_residuals = false
  checkpoint = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="e7e85e78-c6f2-45b7-a7f3-6d1223078ece"><div class="modal-content"><h4>(examples/LiB/CC_discharging.i)</h4><pre class="moose-pre"><code class="language-text">I = 3e-3 #mA
width = 0.03 #mm
in = &#x27;${fparse I/width}&#x27;
t0 = &#x27;${fparse 1e-2/in}&#x27;
dt = &#x27;${fparse t0/100}&#x27;

sigma_a = 1e0 #mS/mm
sigma_e = 1e-1 #mS/mm
sigma_c = 1e-2 #mS/mm

l0 = 0
l1 = 0.04
l2 = 0.07
l3 = 0.12

cmin = 1e-4 #mmol/mm^3
cmax = 1e-3 #mmol/mm^3
D_a = 1e-3 #mm^2/s
D_e = 1e-4 #mm^2/s
D_c = 5e-5 #mm^2/s

R = 8.3145 #mJ/mmol/K
T0 = 300 #K
F = 96485 #mC/mmol

i0_a = 1e-1 #mA/mm^2
i0_c = 1e-1 #mA/mm^2

E_c = 1e5
E_e = 1e4
E_a = 2e5
nu_c = 0.3
nu_e = 0.25
nu_a = 0.3

u_penalty = 1e8

Omega = 60
beta = 1e-3
CTE = 1e-5

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s

T_penalty = 2e-1

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q zeta m&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
  thermal_deformation_gradient = Ft
[]

[Problem]
  restart_file_base = &#x27;CV_charging_I_${I}_cp/LATEST&#x27;
[]

[Mesh]
  [battery]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = ${l0}
    xmax = ${l3}
    ymin = 0
    ymax = ${width}
    nx = 60
    ny = 15
  []
  [anode]
    type = SubdomainBoundingBoxGenerator
    input = battery
    block_id = 1
    block_name = anode
    bottom_left = &#x27;${l0} 0 0&#x27;
    top_right = &#x27;${l1} ${width} 0&#x27;
  []
  [elyte]
    type = SubdomainBoundingBoxGenerator
    input = anode
    block_id = 2
    block_name = elyte
    bottom_left = &#x27;${l1} 0 0&#x27;
    top_right = &#x27;${l2} ${width} 0&#x27;
  []
  [cathode]
    type = SubdomainBoundingBoxGenerator
    input = elyte
    block_id = 3
    block_name = cathode
    bottom_left = &#x27;${l2} 0 0&#x27;
    top_right = &#x27;${l3} ${width} 0&#x27;
  []
  [interfaces]
    type = BreakMeshByBlockGenerator
    input = cathode
    add_interface_on_two_sides = true
    split_interface = true
  []
[]

[Variables]
  [Phi]
  []
  [c]
  []
  [disp_x]
  []
  [disp_y]
  []
  [T]
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
  [Phi0]
  []
[]

[ICs]
  [c_ref_min]
    type = ConstantIC
    variable = c_ref
    value = ${cmin}
    block = &#x27;anode&#x27;
  []
  [c_ref_mid]
    type = ConstantIC
    variable = c_ref
    value = &#x27;${fparse (cmax+cmin)/2}&#x27;
    block = &#x27;elyte&#x27;
  []
  [c_ref_max]
    type = ConstantIC
    variable = c_ref
    value = ${cmax}
    block = &#x27;cathode&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    boundary = &#x27;elyte_anode cathode_elyte&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    boundary = &#x27;anode_elyte elyte_cathode elyte_anode cathode_elyte&#x27;
  []
  [continuity_disp_x]
    type = InterfaceContinuity
    variable = disp_x
    neighbor_var = disp_x
    penalty = ${u_penalty}
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
  [continuity_disp_y]
    type = InterfaceContinuity
    variable = disp_y
    neighbor_var = disp_y
    penalty = ${u_penalty}
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${in}&#x27;
  []
[]

[BCs]
  [left]
    type = FunctionNeumannBC
    variable = Phi
    boundary = left
    function = in
  []
  [right]
    type = DirichletBC
    variable = Phi
    boundary = right
    value = 0
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  []
  [open]
    type = OpenBC
    variable = c
    flux = jm
    boundary = &#x27;left right&#x27;
  []
[]

[Constraints]
  [y]
    type = EqualValueBoundaryConstraint
    variable = disp_y
    penalty = ${u_penalty}
    secondary = top
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;anode ${sigma_a} elyte ${sigma_e} cathode ${sigma_c}&#x27;
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;D&#x27;
    subdomain_to_prop_value = &#x27;anode ${D_a} elyte ${D_e} cathode ${D_c}&#x27;
  []
  [mobility]
    type = ADParsedMaterial
    f_name = M
    args = &#x27;c_ref T_ref&#x27;
    material_property_names = &#x27;D&#x27;
    function = &#x27;D*c_ref/${R}/T_ref&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T
    reference_concentration = c_ref
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
  []

  # Migration
  [migration]
    type = Migration
    electrochemical_energy_density = m
    electric_potential = Phi
    chemical_potential = mu
    electric_conductivity = sigma
    faraday_constant = ${F}
  []
  [migration_flux]
    type = MassFlux
    mass_flux = jm
    energy_densities = &#x27;m&#x27;
    chemical_potential = mu
  []

  # Redox
  [OCP_anode_graphite]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)&#x27;
    args = c
    block = &#x27;anode&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)&#x27;
    args = c
    block = &#x27;cathode&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;anode_elyte&#x27;
  []
  [charge_transfer_elyte_anode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;elyte_anode&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cathode_elyte&#x27;
  []
  [charge_transfer_elyte_cathode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;elyte_cathode&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
  []

  # Mechanical
  [stiffness_c]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_c*nu_c/(1+nu_c)/(1-2*nu_c)} ${fparse E_c/2/(1+nu_c)}&#x27;
    block = cathode
  []
  [stiffness_e]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_e*nu_e/(1+nu_e)/(1-2*nu_e)} ${fparse E_e/2/(1+nu_e)}&#x27;
    block = elyte
  []
  [stiffness_a]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_a*nu_a/(1+nu_a)/(1-2*nu_a)} ${fparse E_a/2/(1+nu_a)}&#x27;
    block = anode
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;beta&#x27;
    prop_values = &#x27;${beta}&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = T_ref
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
    displacements = &#x27;disp_x disp_y&#x27;
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_r - V_l&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [I]
    type = ADSideIntegralMaterialProperty
    property = i
    component = 0
    boundary = right
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;-dt*I&#x27;
    pp_names = &#x27;dt I&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_a_max]
    type = NodalExtremeValue
    variable = c
    value_type = max
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_c_min]
    type = NodalExtremeValue
    variable = c
    value_type = min
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_a_min]
    type = NodalExtremeValue
    variable = c
    value_type = min
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_c_max]
    type = NodalExtremeValue
    variable = c
    value_type = max
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_a]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_e]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = elyte
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_c]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[UserObjects]
  [kill_a]
    type = Terminator
    expression = &#x27;c_a_min &lt;= ${cmin}&#x27;
    message = &#x27;Concentration in anode is below the minimum allowable value.&#x27;
  []
  [kill_c]
    type = Terminator
    expression = &#x27;c_c_max &gt;= ${cmax}&#x27;
    message = &#x27;Concentration in cathode exceeds the maximum allowable value.&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true

  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-10
  nl_max_its = 20

  [Predictor]
    type = SimplePredictor
    scale = 1
    skip_after_failed_timestep = true
  []
  [TimeStepper]
    type = IterationAdaptiveDT
    dt = ${dt}
    optimal_iterations = 7
    iteration_window = 2
    growth_factor = 1.2
    cutback_factor = 0.5
    cutback_factor_at_failure = 0.2
    linear_iteration_ratio = 1000000
  []
  start_time = 0
  end_time = 100000
[]

[Outputs]
  file_base = &#x27;CC_discharging_I_${I}&#x27;
  csv = true
  exodus = true
  print_linear_residuals = false
  checkpoint = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="2c36e20f-33b6-42d4-84a5-0e3e0d82ede2"><div class="modal-content"><h4>(examples/SSB_3D/CV_charging.i)</h4><pre class="moose-pre"><code class="language-text">I = 0.005 #mA
width = 0.05 #mm
in = &#x27;${fparse -I/width/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;

sigma_a = 0.2 #mS/mm
sigma_e = 0.1 #mS/mm
sigma_cp = 0.05 #mS/mm
sigma_ca = 0.2 #mS/mm
sigma_cm = 0.05 #mS/mm

Phi_penalty = 10

cmin_a = 1e-4 #mmol/mm^3
cmax_a = 1e-3 #mmol/mm^3
c_e = 5e-4 #mmol/mm^3
cmax_c = 1e-3 #mmol/mm^3
c_ref_entropy = 5e-5
D_cp = 5e-5 #mm^2/s
D_cm = 1e-4 #mm^2/s
D_a = 5e-4 #mm^2/s
D_e = 1e-4 #mm^2/s

c_penalty = 1

R = 8.3145 #mJ/mmol/K
T0 = 300 #K
F = 96485 #mC/mmol

i0_a = 1e-1 #mA/mm^2
i0_c = 1e-1 #mA/mm^2

E_cp = 6e4
E_cm = 5e4
E_e = 5e4
E_a = 1e5
nu_cp = 0.3
nu_cm = 0.25
nu_e = 0.25
nu_a = 0.3

u_penalty = 1e8

Omega = 140
beta = 1e-4
CTE = 1e-5

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s
htc = 9.5e-3

T_penalty = 1

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
  thermal_deformation_gradient = Ft
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Problem]
  restart_file_base = &#x27;${outname}_CC_charging_cp/LATEST&#x27;
[]

[Mesh]
  [battery]
    type = FileMeshGenerator
    file = &#x27;../coarse.e&#x27;
  []
  [scale]
    type = TransformGenerator
    input = battery
    transform = SCALE
    vector_value = &#x27;1e-3 1e-3 1e-3&#x27; #um to mm
  []
  [cathode_particle]
    type = RenameBlockGenerator
    input = scale
    old_block = &#x27;1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44&#x27;
    new_block = &#x27;cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp&#x27;
  []
  [cathode_matrix]
    type = RenameBlockGenerator
    input = cathode_particle
    old_block = &#x27;48&#x27;
    new_block = &#x27;cm&#x27;
  []
  [elyte]
    type = RenameBlockGenerator
    input = cathode_matrix
    old_block = 49
    new_block = &#x27;e&#x27;
  []
  [anode]
    type = RenameBlockGenerator
    input = elyte
    old_block = 50
    new_block = &#x27;a&#x27;
  []
  [interfaces]
    type = BreakMeshByBlockGenerator
    input = anode
    add_interface_on_two_sides = true
    split_interface = true
  []
  [sidesets]
    type = SideSetsFromNormalsGenerator
    input = interfaces
    normals = &#x27;-1 0 0 1 0 0 0 -1 0 0 1 0 0 0 -1 0 0 1&#x27;
    new_boundary = &#x27;left right bottom top back front&#x27;
  []
  use_displaced_mesh = false
[]

[Variables]
  [Phi_ca]
    block = cm
  []
  [Phi]
  []
  [c]
  []
  [disp_x]
  []
  [disp_y]
  []
  [disp_z]
  []
  [T]
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
  [stress]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = pk1
      scalar_type = Hydrostatic
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Js]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = Fs
      scalar_type = ThirdInvariant
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Jt]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = Ft
      scalar_type = ThirdInvariant
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Phi0]
    [AuxKernel]
      type = ParsedAux
      function = &#x27;Phi&#x27;
      args = &#x27;Phi&#x27;
      execute_on = &#x27;INITIAL&#x27;
    []
  []
[]

[ICs]
  [c_ref_a]
    type = ConstantIC
    variable = c_ref
    value = ${cmin_a}
    block = &#x27;a&#x27;
  []
  [c_ref_e]
    type = ConstantIC
    variable = c_ref
    value = ${c_e}
    block = &#x27;cm e&#x27;
  []
  [c_ref_c]
    type = ConstantIC
    variable = c_ref
    value = ${cmax_c}
    block = &#x27;cp&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  [charge_balance_ca]
    type = RankOneDivergence
    variable = Phi_ca
    vector = i_ca
    block = cm
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
  [momentum_balance_z]
    type = RankTwoDivergence
    variable = disp_z
    component = 2
    tensor = pk1
    factor = -1
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [negative_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = 1
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    boundary = &#x27;a_e cm_cp e_a cp_cm&#x27;
  []
  [continuity_c]
    type = InterfaceContinuity
    variable = c
    neighbor_var = c
    penalty = ${c_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_Phi_ca]
    type = InterfaceContinuity
    variable = Phi_ca
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_cp&#x27;
  []
  [continuity_Phi]
    type = InterfaceContinuity
    variable = Phi
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_disp_x]
    type = InterfaceContinuity
    variable = disp_x
    neighbor_var = disp_x
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_disp_y]
    type = InterfaceContinuity
    variable = disp_y
    neighbor_var = disp_y
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_disp_z]
    type = InterfaceContinuity
    variable = disp_z
    neighbor_var = disp_z
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${in}&#x27;
  []
[]

[BCs]
  [current]
    type = CoupledVarDirichletBC
    variable = Phi
    boundary = right
    value = Phi0
  []
  [potential]
    type = DirichletBC
    variable = Phi_ca
    boundary = left
    value = 0
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  []
  [fix_z]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back&#x27;
  []
  [hconv]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;left right&#x27;
    value = -1
    boundary_material = qconv
  []
[]

[Constraints]
  [ev_y]
    type = EqualValueBoundaryConstraint
    variable = disp_y
    penalty = ${u_penalty}
    secondary = top
  []
  [ev_z]
    type = EqualValueBoundaryConstraint
    variable = disp_z
    penalty = ${u_penalty}
    secondary = front
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;a ${sigma_a} e ${sigma_e} cm ${sigma_cm} cp ${sigma_cp}&#x27;
  []
  [conductivity_ca]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma_ca&#x27;
    subdomain_to_prop_value = &#x27;cm ${sigma_ca}&#x27;
    block = cm
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [charge_transport_ca]
    type = BulkChargeTransport
    electrical_energy_density = q_ca
    electric_potential = Phi_ca
    electric_conductivity = sigma_ca
    temperature = T
    block = cm
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
    output_properties = i
    outputs = exodus
  []
  [current_density_ca]
    type = CurrentDensity
    current_density = i_ca
    electric_potential = Phi_ca
    output_properties = i_ca
    outputs = exodus
    block = cm
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;D&#x27;
    subdomain_to_prop_value = &#x27;a ${D_a} e ${D_e} cm ${D_cm} cp ${D_cp}&#x27;
  []
  [mobility]
    type = ADParsedMaterial
    f_name = M
    args = &#x27;c_ref T_ref&#x27;
    material_property_names = &#x27;D&#x27;
    function = &#x27;D*c_ref/${R}/T_ref&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T_ref
    reference_concentration = ${c_ref_entropy}
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
    energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta m&#x27;
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
    outputs = exodus
  []

  # Redox
  [ramp]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;ramp&#x27;
    prop_values = &#x27;if(t&lt;${t0},t/${t0},1)&#x27;
  []
  [OCP_anode_graphite]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_a}; 2.77e-4*x^2-0.0069*x+0.0785&#x27;
    # function = &#x27;x:=c/${cmax_a}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;a&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_c}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;cp&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;a_e&#x27;
  []
  [charge_transfer_elyte_anode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;e_a&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cp_cm&#x27;
  []
  [charge_transfer_elyte_cathode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cm_cp&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
    output_properties = h
    outputs = exodus
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
    output_properties = r
    outputs = exodus
  []
  [conv]
    type = ADParsedMaterial
    f_name = qconv
    function = &#x27;${htc}*(T-T_ref)&#x27;
    args = &#x27;T T_ref&#x27;
    boundary = &#x27;left right&#x27;
  []

  # Mechanical
  [stiffness_cp]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cp*nu_cp/(1+nu_cp)/(1-2*nu_cp)} ${fparse E_cp/2/(1+nu_cp)}&#x27;
    block = cp
  []
  [stiffness_cm]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cm*nu_cm/(1+nu_cm)/(1-2*nu_cm)} ${fparse E_cm/2/(1+nu_cm)}&#x27;
    block = cm
  []
  [stiffness_e]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_e*nu_e/(1+nu_e)/(1-2*nu_e)} ${fparse E_e/2/(1+nu_e)}&#x27;
    block = e
  []
  [stiffness_a]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_a*nu_a/(1+nu_a)/(1-2*nu_a)} ${fparse E_a/2/(1+nu_a)}&#x27;
    block = a
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;beta&#x27;
    prop_values = &#x27;${beta}&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = T_ref
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
    non_swelling_pressure = p
    output_properties = &#x27;p&#x27;
    outputs = exodus
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi_ca
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_l - V_r&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [I]
    type = ADSideIntegralMaterialProperty
    property = i
    component = 0
    boundary = right
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;dt*I&#x27;
    pp_names = &#x27;dt I&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[UserObjects]
  [kill_V]
    type = Terminator
    expression = &#x27;I &lt;= 1e-6&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options = &#x27;-ksp_converged_reason&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_interp_type -pc_hypre_boomeramg_coarsen_type -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths -pc_hypre_boomeramg_truncfactor&#x27;
  petsc_options_value = &#x27;hypre boomeramg 301 0.25 ext+i PMIS 4 2 0.4&#x27;
  automatic_scaling = true
  ignore_variables_for_autoscaling = &#x27;T&#x27;
  verbose = true
  line_search = none

  l_max_its = 300
  l_tol = 1e-6
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-9
  nl_max_its = 12

  [Predictor]
    type = SimplePredictor
    scale = 1
  []
  [TimeStepper]
    type = IterationAdaptiveDT
    dt = &#x27;${fparse t0/50}&#x27;
    optimal_iterations = 6
    iteration_window = 1
    growth_factor = 1.2
    cutback_factor = 0.2
    cutback_factor_at_failure = 0.1
    linear_iteration_ratio = 100
  []
  end_time = 10000
[]

[Outputs]
  file_base = &#x27;${outname}_CV_charging&#x27;
  exodus = true
  csv = true
  print_linear_residuals = false
  checkpoint = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="e2f639eb-9db4-406e-aabf-fa1b304d0dd3"><div class="modal-content"><h4>(examples/PCM-GF/charging_idling.i)</h4><pre class="moose-pre"><code class="language-text"># units are in meter kelvin second (m,kg,s)

tramp = 10
tcharge = 8000 # 3hr*3600
tidle = 86400 #24hr*3600
end_time = &#x27;${fparse tcharge+tidle}&#x27;

dtmax = 600
dt = 1

T_melting = &#x27;${fparse 718+273.15}&#x27; # Temperature at which the melting begins, Singh et al. Solar energy 159(2018) 270-282 (Prototype 1)
delta_T_pc = 8 # The temperature range of the melting/solidification process
L = 373.9e3 # Latent heat, from Singh et al. (2015)

sigma_foam_PCM = 5 # (from Wen&#x27;s measurement of Gfoam+PCM in radial direction) (from Cfoam 70% dense foam = 28571.43) S/m (1/electrical resistivity (0.000035 ohm-m))
kappa_foam_PCM = 10 #18.8 # (average of Kxy = 14 W/m-K, Kz = 23.6 W/mK at T=700C) #from Singh et al. Solar energy 159(2018) 270-282 (Prototype 1)
rho_foam_PCM = 2050 # kg/m^3 #from Singh et al. Solar energy 159(2018) 270-282 (Prototype 1)
cp_foam_PCM = 1074 # J/kg-K #from Singh et al. Solar energy 159(2018) 270-282 (Prototype 1)

sigma_htf_pipe = 750750.75 # S/m (resistivity 1.332e-6 ohm-m at T = 700C) #Special metal data sheet
kappa_htf_pipe = 23.9 # W/m-K (at 700C) #Special metal datasheet
rho_htf_pipe = 8359.33 #kg/m^3
cp_htf_pipe = 419 # J/kg-K

sigma_insul_ht = 1e-9
kappa_insul_ht = 0.12 # W/m-K(Durablanket S from UNIFRAX) Wen emailed on 2023-03-31
rho_insul_ht = 2730 # kg/m^3(Durablanket S from UNIFRAX) Wen emailed on 2023-03-31
cp_insul_ht = 1130 # J/kg-K(Durablanket S from UNIFRAX) Wen emailed on 2023-03-31

sigma_air = 1e-12
kappa_air = 0.03 #file:///C:/Users/barua/Downloads/PDS-FOAMGLAS%20ONE-US-en.pdf
rho_air = 1.29 #file:///C:/Users/barua/Downloads/PDS-FOAMGLAS%20ONE-US-en.pdf
cp_air = 1000 #file:///C:/Users/barua/Downloads/PDS-FOAMGLAS%20ONE-US-en.pdf

htc_insul = 5
T_inf_insul = 300
htc_pipe = 0.01
T_inf_pipe = 300
T0 = 300
# i = 1 # This is the maximum current in constant-current charging
V = 21 # This is the maximum voltage in constant-voltage charging

[GlobalParams]
  energy_densities = &#x27;E H&#x27;
[]

[Mesh]
  [fmg]
    type = FileMeshGenerator
    file = &#x27;gold/geo.e&#x27;
  []
  coord_type = RZ
  uniform_refine = 1
[]

[Variables]
  [Phi]
  []
  [T]
    initial_condition = ${T0}
  []
[]

[AuxVariables]
  [T_old]
    [AuxKernel]
      type = ParsedAux
      expression = &#x27;T&#x27;
      coupled_variables = &#x27;T&#x27;
      execute_on = &#x27;INITIAL TIMESTEP_BEGIN&#x27;
    []
  []
[]

[Kernels]
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cp
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [energy_balance_3]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[Functions]
  # [ramp_current]
  #   type = PiecewiseLinear
  #   x = &#x27;0 ${t0}&#x27;
  #   y = &#x27;0 ${i}&#x27;
  # []
  [ramp_voltage]
    type = PiecewiseLinear
    x = &#x27;0 ${tramp} ${tcharge} ${fparse tcharge+tramp} ${fparse tcharge+tidle}&#x27;
    y = &#x27;0 ${V} ${V} 0 0&#x27;
  []
[]

[BCs]
  [ground]
    type = DirichletBC
    variable = Phi
    boundary = &#x27;foam_id&#x27;
    value = 0
  []
  # [current]
  #   type = FunctionNeumannBC
  #   variable = Phi
  #   boundary = &#x27;foam_od&#x27;
  #   function = ramp_current
  # []
  [CV]
    type = FunctionDirichletBC
    variable = Phi
    boundary = &#x27;foam_od&#x27;
    function = ramp_voltage
  []
  [hconv_insul]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;insul_surf&#x27;
    value = -1
    boundary_material = qconv_insul
  []
  [hconv_pipe]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;pipe_id&#x27;
    value = -1
    boundary_material = qconv_pipe
  []
[]

[Materials]
  [electrical_conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = sigma
    subdomain_to_prop_value = &#x27;foam_PCM ${sigma_foam_PCM} htf_pipe ${sigma_htf_pipe} insul_ht ${sigma_insul_ht} air ${sigma_air}&#x27;
  []
  [charge_trasport]
    type = BulkChargeTransport
    electrical_energy_density = E
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [current]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
  []
  [thermal_conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = kappa
    subdomain_to_prop_value = &#x27;foam_PCM ${kappa_foam_PCM} htf_pipe ${kappa_htf_pipe} insul_ht ${kappa_insul_ht} air ${kappa_air}&#x27;
  []
  [density]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = rho
    subdomain_to_prop_value = &#x27;foam_PCM ${rho_foam_PCM} htf_pipe ${rho_htf_pipe} insul_ht ${rho_insul_ht} air ${rho_air}&#x27;
  []
  [gaussian_function]
    type = ADParsedMaterial
    property_name = D
    expression = &#x27;exp(-T*(T-Tm)^2/dT^2)/sqrt(3.1415926*dT^2)&#x27;
    coupled_variables = &#x27;T&#x27;
    constant_names = &#x27;Tm dT&#x27;
    constant_expressions = &#x27;${T_melting} ${delta_T_pc}&#x27;
  []
  [specific_heat_foam_PCM]
    type = ADParsedMaterial
    property_name = cp
    expression = &#x27;${cp_foam_PCM} + ${L} * D&#x27;
    material_property_names = &#x27;D&#x27;
    block = foam_PCM
    outputs = exodus
  []
  [specific_heat]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = cp
    subdomain_to_prop_value = &#x27;htf_pipe ${cp_htf_pipe} insul_ht ${cp_insul_ht} air ${cp_air}&#x27;
    block = &#x27;htf_pipe insul_ht air&#x27;
    outputs = exodus
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = H
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
  []
  [qconv_insul]
    type = ADParsedMaterial
    property_name = qconv_insul
    expression = &#x27;htc*(T-T_inf)&#x27;
    coupled_variables = &#x27;T&#x27;
    constant_names = &#x27;htc T_inf&#x27;
    constant_expressions = &#x27;${htc_insul} ${T_inf_insul}&#x27;
    boundary = &#x27;insul_surf&#x27;
  []
  [qconv_pipe]
    type = ADParsedMaterial
    property_name = qconv_pipe
    expression = &#x27;htc*(T-T_inf)&#x27;
    coupled_variables = &#x27;T&#x27;
    constant_names = &#x27;htc T_inf&#x27;
    constant_expressions = &#x27;${htc_pipe} ${T_inf_pipe}&#x27;
    boundary = &#x27;pipe_id&#x27;
  []
  [delta_enthalpy]
    type = ADParsedMaterial
    property_name = delta_enthalpy
    expression = &#x27;rho*cp*(T-T_old)/2&#x27;
    material_property_names = &#x27;rho cp&#x27;
    coupled_variables = &#x27;T T_old&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true

  end_time = ${end_time}
  dtmax = ${dtmax}
  dtmin = 0.01
  [TimeStepper]
    type = IterationAdaptiveDT
    dt = ${dt}
    cutback_factor = 0.2
    cutback_factor_at_failure = 0.1
    growth_factor = 1.2
    optimal_iterations = 7
    iteration_window = 2
    linear_iteration_ratio = 100000
  []
  [Predictor]
    type = SimplePredictor
    scale = 1
    skip_after_failed_timestep = true
  []

  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-6
  nl_max_its = 12

  # steady_state_detection = true
[]

[Postprocessors]
  [volume_PCM]
    type = VolumePostprocessor
    block = &#x27;foam_PCM&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    # outputs = none
  []
  [delta_energy_absorbed_by_PCM]
    type = ADElementIntegralMaterialProperty
    mat_prop = delta_enthalpy
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    block = &#x27;foam_PCM&#x27;
    outputs = none
  []
  [delta_energy_absorbed_by_insul_ht]
    type = ADElementIntegralMaterialProperty
    mat_prop = delta_enthalpy
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    block = &#x27;insul_ht&#x27;
    outputs = none
  []
  [delta_energy_absorbed_by_air]
    type = ADElementIntegralMaterialProperty
    mat_prop = delta_enthalpy
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    block = &#x27;air&#x27;
    outputs = none
  []
  [delta_energy_absorbed_by_pipe]
    type = ADElementIntegralMaterialProperty
    mat_prop = delta_enthalpy
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    block = &#x27;htf_pipe&#x27;
    outputs = none
  []
  [energy_absorbed_by_PCM]
    type = CumulativeValuePostprocessor
    postprocessor = delta_energy_absorbed_by_PCM
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [energy_absorbed_by_insul_ht]
    type = CumulativeValuePostprocessor
    postprocessor = delta_energy_absorbed_by_insul_ht
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [energy_absorbed_by_air]
    type = CumulativeValuePostprocessor
    postprocessor = delta_energy_absorbed_by_air
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [energy_absorbed_by_pipe]
    type = CumulativeValuePostprocessor
    postprocessor = delta_energy_absorbed_by_pipe
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [total_energy]
    type = ParsedPostprocessor
    pp_names = &#x27;energy_absorbed_by_PCM energy_absorbed_by_insul_ht energy_absorbed_by_air energy_absorbed_by_pipe&#x27;
    function = &#x27;energy_absorbed_by_PCM+energy_absorbed_by_insul_ht+energy_absorbed_by_air+energy_absorbed_by_pipe&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [max_energy]
    type = TimeExtremeValue
    postprocessor = total_energy
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    outputs = none
  []
  [energy_percentage]
    type = ParsedPostprocessor
    pp_names = &#x27;total_energy max_energy&#x27;
    function = &#x27;if(total_energy &lt; max_energy, total_energy/max_energy*100, 100)&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [power_input]
    type = ADElementIntegralMaterialProperty
    mat_prop = E
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    # outputs = none
  []
  [voltage]
    type = FunctionValuePostprocessor
    function = ramp_voltage
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    # outputs = none
  []
  [current_input]
    type = ParsedPostprocessor
    pp_names = &#x27;voltage power_input&#x27;
    function = &#x27;power_input / voltage&#x27;
    execute_on = &#x27;TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    outputs = none
  []
  [delta_energy_input]
    type = ParsedPostprocessor
    pp_names = &#x27;dt power_input&#x27;
    function = &#x27;power_input * dt&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    outputs = none
  []
  [energy_input]
    type = CumulativeValuePostprocessor
    postprocessor = delta_energy_input
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [PCM_max_temperature]
    type = NodalExtremeValue
    variable = T
    value_type = max
    block = &#x27;foam_PCM&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [PCM_min_temperature]
    type = NodalExtremeValue
    variable = T
    value_type = min
    block = &#x27;foam_PCM&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="6c7e4690-8876-4fef-80ac-1d76866f038a"><div class="modal-content"><h4>(examples/SSB/CC_discharging.i)</h4><pre class="moose-pre"><code class="language-text">I = 0.005 #mA
width = 0.05 #mm
in = &#x27;${fparse -I/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;

sigma_a = 0.2 #mS/mm
sigma_e = 0.1 #mS/mm
sigma_cp = 0.05 #mS/mm
sigma_ca = 0.2 #mS/mm
sigma_cm = 0.05 #mS/mm

Phi_penalty = 10

cmin_a = 1e-4 #mmol/mm^3
cmax_a = 1e-3 #mmol/mm^3
c_e = 5e-4 #mmol/mm^3
cmax_c = 1e-3 #mmol/mm^3
c_ref_entropy = 5e-5
D_cp = 5e-5 #mm^2/s
D_cm = 1e-4 #mm^2/s
D_a = 5e-4 #mm^2/s
D_e = 1e-4 #mm^2/s

c_penalty = 1

R = 8.3145 #mJ/mmol/K
T0 = 300 #K
F = 96485 #mC/mmol

i0_a = 1e-1 #mA/mm^2
i0_c = 1e-1 #mA/mm^2

E_cp = 6e4
E_cm = 5e4
E_e = 5e4
E_a = 1e5
nu_cp = 0.3
nu_cm = 0.25
nu_e = 0.25
nu_a = 0.3

u_penalty = 1e8

Omega = 140
beta = 1e-4
CTE = 1e-5

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s
htc = 9.5e-3

T_penalty = 1

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
  thermal_deformation_gradient = Ft
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Problem]
  restart_file_base = &#x27;CV_charging_out_cp/LATEST&#x27;
[]

[Mesh]
  [battery]
    type = FileMeshGenerator
    file = &#x27;gold/ssb.msh&#x27;
  []
  [interfaces]
    type = BreakMeshByBlockGenerator
    input = battery
    add_interface_on_two_sides = true
    split_interface = true
  []
  use_displaced_mesh = false
[]

[Variables]
  [Phi_ca]
    block = cm
  []
  [Phi]
  []
  [c]
  []
  [disp_x]
  []
  [disp_y]
  []
  [T]
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
  [stress]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = pk1
      scalar_type = Hydrostatic
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Js]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = Fs
      scalar_type = ThirdInvariant
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Jt]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = Ft
      scalar_type = ThirdInvariant
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Phi0]
  []
[]

[ICs]
  [c_ref_a]
    type = ConstantIC
    variable = c_ref
    value = ${cmin_a}
    block = &#x27;a&#x27;
  []
  [c_ref_e]
    type = ConstantIC
    variable = c_ref
    value = ${c_e}
    block = &#x27;cm e&#x27;
  []
  [c_ref_c]
    type = ConstantIC
    variable = c_ref
    value = ${cmax_c}
    block = &#x27;cp&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  [charge_balance_ca]
    type = RankOneDivergence
    variable = Phi_ca
    vector = i_ca
    block = cm
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [negative_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = 1
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    boundary = &#x27;a_e cm_cp e_a cp_cm&#x27;
  []
  [continuity_c]
    type = InterfaceContinuity
    variable = c
    neighbor_var = c
    penalty = ${c_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_Phi_ca]
    type = InterfaceContinuity
    variable = Phi_ca
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_cp&#x27;
  []
  [continuity_Phi]
    type = InterfaceContinuity
    variable = Phi
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_disp_x]
    type = InterfaceContinuity
    variable = disp_x
    neighbor_var = disp_x
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_disp_y]
    type = InterfaceContinuity
    variable = disp_y
    neighbor_var = disp_y
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${fparse -in}&#x27;
  []
[]

[BCs]
  [current]
    type = FunctionNeumannBC
    variable = Phi
    boundary = right
    function = in
  []
  [potential]
    type = DirichletBC
    variable = Phi_ca
    boundary = left
    value = 0
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  []
  [hconv]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;left right&#x27;
    value = -1
    boundary_material = qconv
  []
[]

[Constraints]
  [ev_y]
    type = EqualValueBoundaryConstraint
    variable = disp_y
    penalty = ${u_penalty}
    secondary = top
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;a ${sigma_a} e ${sigma_e} cm ${sigma_cm} cp ${sigma_cp}&#x27;
  []
  [conductivity_ca]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma_ca&#x27;
    subdomain_to_prop_value = &#x27;cm ${sigma_ca}&#x27;
    block = cm
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [charge_transport_ca]
    type = BulkChargeTransport
    electrical_energy_density = q_ca
    electric_potential = Phi_ca
    electric_conductivity = sigma_ca
    temperature = T
    block = cm
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
    output_properties = i
    outputs = exodus
  []
  [current_density_ca]
    type = CurrentDensity
    current_density = i_ca
    electric_potential = Phi_ca
    output_properties = i_ca
    outputs = exodus
    block = cm
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;D&#x27;
    subdomain_to_prop_value = &#x27;a ${D_a} e ${D_e} cm ${D_cm} cp ${D_cp}&#x27;
  []
  [mobility]
    type = ADParsedMaterial
    f_name = M
    args = &#x27;c_ref T_ref&#x27;
    material_property_names = &#x27;D&#x27;
    function = &#x27;D*c_ref/${R}/T_ref&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T_ref
    reference_concentration = ${c_ref_entropy}
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
    energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta m&#x27;
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
    outputs = exodus
  []

  # Redox
  [ramp]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;ramp&#x27;
    prop_values = &#x27;if(t&lt;${t0},t/${t0},1)&#x27;
  []
  [OCP_anode_graphite]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_a}; 2.77e-4*x^2-0.0069*x+0.0785&#x27;
    # function = &#x27;x:=c/${cmax_a}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;a&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_c}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;cp&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;a_e&#x27;
  []
  [charge_transfer_elyte_anode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;e_a&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cp_cm&#x27;
  []
  [charge_transfer_elyte_cathode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cm_cp&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
    output_properties = h
    outputs = exodus
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
    output_properties = r
    outputs = exodus
  []
  [conv]
    type = ADParsedMaterial
    f_name = qconv
    function = &#x27;${htc}*(T-T_ref)&#x27;
    args = &#x27;T T_ref&#x27;
    boundary = &#x27;left right&#x27;
  []

  # Mechanical
  [stiffness_cp]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cp*nu_cp/(1+nu_cp)/(1-2*nu_cp)} ${fparse E_cp/2/(1+nu_cp)}&#x27;
    block = cp
  []
  [stiffness_cm]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cm*nu_cm/(1+nu_cm)/(1-2*nu_cm)} ${fparse E_cm/2/(1+nu_cm)}&#x27;
    block = cm
  []
  [stiffness_e]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_e*nu_e/(1+nu_e)/(1-2*nu_e)} ${fparse E_e/2/(1+nu_e)}&#x27;
    block = e
  []
  [stiffness_a]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_a*nu_a/(1+nu_a)/(1-2*nu_a)} ${fparse E_a/2/(1+nu_a)}&#x27;
    block = a
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;beta&#x27;
    prop_values = &#x27;${beta}&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = T_ref
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
    non_swelling_pressure = p
    output_properties = &#x27;p&#x27;
    outputs = exodus
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi_ca
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_l - V_r&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [I]
    type = ADSideIntegralMaterialProperty
    property = i
    component = 0
    boundary = right
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;dt*I&#x27;
    pp_names = &#x27;dt I&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[UserObjects]
  [kill_V]
    type = Terminator
    expression = &#x27;V &lt;= 2.5&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options = &#x27;-ksp_converged_reason&#x27;
  # petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_interp_type -pc_hypre_boomeramg_coarsen_type -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths -pc_hypre_boomeramg_truncfactor&#x27;
  # petsc_options_value = &#x27;hypre boomeramg 301 0.25 ext+i PMIS 4 2 0.4&#x27;
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true
  ignore_variables_for_autoscaling = &#x27;T&#x27;
  verbose = true
  line_search = none

  l_max_its = 300
  l_tol = 1e-6
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-9
  nl_max_its = 12

  [Predictor]
    type = SimplePredictor
    scale = 1
  []
  [TimeStepper]
    type = IterationAdaptiveDT
    dt = &#x27;${fparse t0/50}&#x27;
    optimal_iterations = 6
    iteration_window = 1
    growth_factor = 1.2
    cutback_factor = 0.2
    cutback_factor_at_failure = 0.1
    linear_iteration_ratio = 100
  []
  end_time = 10000
[]

[Outputs]
  exodus = true
  csv = true
  print_linear_residuals = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="02e91eaa-e6e5-4cf3-8bc4-fc1a48d7947b"><div class="modal-content"><h4>(test/tests/chemical-electrical-thermal/thermal_effects.i)</h4><pre class="moose-pre"><code class="language-text">R = 8.3145 #mJ/mmol/K
F = 96485 #mC/mmol

I = 3e-3 #mA
width = 0.03 #mm
in = &#x27;${fparse -I/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;
dt = &#x27;${fparse t0/100}&#x27;
Vmax = 4.3 #V

vf_se = 0.3
vf_cp = 0.5
vf_ca = 0.2

sigma_a = 0.2 #mS/mm
sigma_se = 0.1 #mS/mm
sigma_cp = 0.05 #mS/mm
sigma_ca = 0.2 #mS/mm
sigma_e = ${sigma_se}
sigma_c = &#x27;${fparse vf_se*sigma_se + vf_cp*sigma_cp + vf_ca*sigma_ca}&#x27;

l0 = 0
l1 = 0.04
l2 = 0.07
l3 = 0.12

cmax = 1e-3 #mmol/mm^3
c0_a = 1e-4
c0_e = 5e-4
c0_c = 1e-3

M_a = 8e-11
M_se = 1e-11
M_cp = 4e-14
M_ca = 1e-13
M_e = ${M_se}
M_c = &#x27;${fparse vf_se*M_se + vf_cp*M_cp + vf_ca*M_ca}&#x27;

T0 = 300 #K

i0_a = 0.1 #mA/mm^2
i0_c = 0.1 #mA/mm^2

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s
hconv = 9.5e-3 #mJ/mm^2/K/s

T_penalty = 2e-1

[GlobalParams]
  energy_densities = &#x27;dot(psi_c) q zeta chi m&#x27;
[]

[Mesh]
  [battery]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = ${l0}
    xmax = ${l3}
    ymin = 0
    ymax = ${width}
    nx = 60
    ny = 15
  []
  [anode]
    type = SubdomainBoundingBoxGenerator
    input = battery
    block_id = 1
    block_name = anode
    bottom_left = &#x27;${l0} 0 0&#x27;
    top_right = &#x27;${l1} ${width} 0&#x27;
  []
  [elyte]
    type = SubdomainBoundingBoxGenerator
    input = anode
    block_id = 2
    block_name = elyte
    bottom_left = &#x27;${l1} 0 0&#x27;
    top_right = &#x27;${l2} ${width} 0&#x27;
  []
  [cathode]
    type = SubdomainBoundingBoxGenerator
    input = elyte
    block_id = 3
    block_name = cathode
    bottom_left = &#x27;${l2} 0 0&#x27;
    top_right = &#x27;${l3} ${width} 0&#x27;
  []
  [anode_elyte]
    type = BreakMeshByBlockGenerator
    input = cathode
    block_pairs = &#x27;1 2&#x27;
    add_interface_on_two_sides = true
    split_interface = true
  []
  [cathode_elyte]
    type = BreakMeshByBlockGenerator
    input = anode_elyte
    block_pairs = &#x27;2 3&#x27;
    add_interface_on_two_sides = true
    split_interface = true
  []
[]

[Variables]
  [Phi]
  []
  [c]
  []
  [T]
    initial_condition = ${T0}
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
[]

[ICs]
  [c_a]
    type = ConstantIC
    variable = c
    value = ${c0_a}
    block = &#x27;anode&#x27;
  []
  [c_e]
    type = ConstantIC
    variable = c
    value = ${c0_e}
    block = &#x27;elyte&#x27;
  []
  [c_c]
    type = ConstantIC
    variable = c
    value = ${c0_c}
    block = &#x27;cathode&#x27;
  []
  [c_ref_a]
    type = ConstantIC
    variable = c_ref
    value = ${c0_a}
    block = &#x27;anode&#x27;
  []
  [c_ref_e]
    type = ConstantIC
    variable = c_ref
    value = ${c0_e}
    block = &#x27;elyte&#x27;
  []
  [c_ref_c]
    type = ConstantIC
    variable = c_ref
    value = ${c0_c}
    block = &#x27;cathode&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    factor_neighbor = 1
    boundary = &#x27;cathode_elyte&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;anode_elyte&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    factor_neighbor = 1
    boundary = &#x27;anode_elyte cathode_elyte&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;anode_elyte cathode_elyte&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${in}&#x27;
  []
[]

[BCs]
  [left]
    type = FunctionNeumannBC
    variable = Phi
    boundary = left
    function = in
  []
  [right]
    type = DirichletBC
    variable = Phi
    boundary = right
    value = 0
  []
  [open]
    type = OpenBC
    variable = c
    flux = jm
    boundary = &#x27;left right&#x27;
  []
  [hconv]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;left right&#x27;
    value = -1
    boundary_material = qconv
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;anode ${sigma_a} elyte ${sigma_e} cathode ${sigma_c}&#x27;
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
  []

  # Migration
  [migration]
    type = Migration
    electrochemical_energy_density = m
    electric_potential = Phi
    chemical_potential = mu
    electric_conductivity = sigma
    faraday_constant = ${F}
  []
  [migration_flux]
    type = MassFlux
    mass_flux = jm
    energy_densities = &#x27;m&#x27;
    chemical_potential = mu
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;M&#x27;
    subdomain_to_prop_value = &#x27;anode ${M_a} elyte ${M_e} cathode ${M_c}&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T
    reference_concentration = c_ref
    reference_chemical_potential = 1e3
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
  []

  # Redox
  [ramp]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;ramp&#x27;
    prop_values = &#x27;if(t&lt;${t0},t/${t0},1)&#x27;
  []
  [OCP_anode_graphite]
    type = ADParsedMaterial
    property_name = U
    expression = &#x27;x:=c/${cmax}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)*ramp&#x27;
    coupled_variables = c
    material_property_names = &#x27;ramp&#x27;
    boundary = &#x27;anode_elyte&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    property_name = U
    expression = &#x27;x:=c/${cmax}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)*ramp&#x27;
    coupled_variables = c
    material_property_names = &#x27;ramp&#x27;
    boundary = &#x27;cathode_elyte&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;anode_elyte&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cathode_elyte&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
  []
  [qconv]
    type = ADParsedMaterial
    property_name = qconv
    expression = &#x27;htc*(T-T_inf)&#x27;
    coupled_variables = &#x27;T&#x27;
    constant_names = &#x27;htc T_inf&#x27;
    constant_expressions = &#x27;${hconv} ${T0}&#x27;
    boundary = &#x27;left right&#x27;
  []
  [enthalpy]
    type = ADParsedMaterial
    f_name = enthalpy
    function = &#x27;rho*cv*(T-T_ref)&#x27;
    args = &#x27;T T_ref&#x27;
    material_property_names = &#x27;rho cv&#x27;
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_r - V_l&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [in]
    type = FunctionValuePostprocessor
    function = in
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;-dt*in*${width}&#x27;
    pp_names = &#x27;dt in&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_a_max]
    type = NodalExtremeValue
    variable = c
    value_type = max
    block = anode
  []
  [c_c_min]
    type = NodalExtremeValue
    variable = c
    value_type = min
    block = cathode
  []
  [mass_a]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_e]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = elyte
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_c]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [H_a]
    type = ADElementIntegralMaterialProperty
    mat_prop = enthalpy
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [H_e]
    type = ADElementIntegralMaterialProperty
    mat_prop = enthalpy
    block = elyte
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [H_c]
    type = ADElementIntegralMaterialProperty
    mat_prop = enthalpy
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[UserObjects]
  [kill]
    type = Terminator
    expression = &#x27;V &gt;= ${Vmax}&#x27;
    message = &#x27;Voltage reached Vmax&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true
  line_search = none

  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-10
  nl_max_its = 20
  l_max_its = 150

  [Predictor]
    type = SimplePredictor
    scale = 1
    skip_after_failed_timestep = true
  []

  [TimeStepper]
    type = IterationAdaptiveDT
    dt = ${dt}
    optimal_iterations = 7
    iteration_window = 2
    growth_factor = 1.2
    cutback_factor = 0.5
    cutback_factor_at_failure = 0.2
    linear_iteration_ratio = 1000000
  []
  dtmax = 1
  end_time = 100000
[]

[Outputs]
  exodus = true
  print_linear_residuals = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="b810a154-b760-4fb5-b9fb-60a6e0ed98ef"><div class="modal-content"><h4>(test/tests/electrical-thermal/jh.i)</h4><pre class="moose-pre"><code class="language-text">n = 32

[GlobalParams]
  energy_densities = &#x27;E H&#x27;
[]

[Mesh]
  [battery]
    type = GeneratedMeshGenerator
    dim = 1
    xmin = 0
    xmax = 1
    nx = ${n}
  []
[]

[Variables]
  [Phi]
  []
  [T]
  []
[]

[Functions]
  [Phi]
    type = ParsedFunction
    expression = &#x27;3.565*exp(x)-4.71*x^2+7.1*x-3.4&#x27;
  []
  [sigma]
    type = ParsedFunction
    expression = &#x27;1+x&#x27;
  []
  [q]
    type = ParsedFunction
    expression = &#x27;2.32+exp(x)*(-7.13-3.565*x)+18.84*x&#x27;
  []
  [kappa]
    type = ParsedFunction
    expression = &#x27;-2.6*x+3&#x27;
  []
[]

[Kernels]
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  [charge]
    type = BodyForce
    variable = Phi
    function = q
  []
  [energy_balance_1]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [energy_balance_2]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[BCs]
  [fix]
    type = FunctionDirichletBC
    variable = Phi
    boundary = &#x27;left right&#x27;
    function = Phi
  []
  [hconv]
    type = ADMatNeumannBC
    variable = T
    boundary = right
    value = -1
    boundary_material = qconv
  []
[]

[Materials]
  [electric_constants]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;sigma&#x27;
    prop_values = &#x27;sigma&#x27;
  []
  [charge_trasport]
    type = BulkChargeTransport
    electrical_energy_density = E
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [current]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
  []
  [thermal_constants]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;kappa&#x27;
    prop_values = &#x27;kappa&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = H
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
  []
  [qconv]
    type = ADParsedMaterial
    property_name = qconv
    expression = &#x27;htc*(T-T_inf)&#x27;
    coupled_variables = &#x27;T&#x27;
    constant_names = &#x27;htc T_inf&#x27;
    constant_expressions = &#x27;1.35 300&#x27;
    boundary = right
  []
[]

[Postprocessors]
  [error]
    type = ElementL2Error
    variable = Phi
    function = Phi
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true

  num_steps = 1
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="4c6516b0-8945-44d8-aeae-619f2545d28f"><div class="modal-content"><h4>(examples/SSB/charging.i)</h4><pre class="moose-pre"><code class="language-text">I = 1.2e-3 #mA
width = 0.03 #mm
in = &#x27;${fparse -I/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;

sigma_a = 0.2 #mS/mm
sigma_e = 0.1 #mS/mm
sigma_cp = 0.05 #mS/mm
sigma_ca = 0.5 #mS/mm
sigma_cm = 0.05 #mS/mm

Phi_penalty = 1

cmin_a = 1e-4 #mmol/mm^3
cmax_a = 1e-3 #mmol/mm^3
c_e = 5e-4 #mmol/mm^3
cmin_c = 1e-4 #mmol/mm^3
cmax_c = 1e-3 #mmol/mm^3
c_ref_entropy = 5e-5
D_cp = 5e-5 #mm^2/s
D_cm = 1e-4 #mm^2/s
D_a = 5e-4 #mm^2/s
D_e = 1e-4 #mm^2/s

c_penalty = 1

R = 8.3145 #mJ/mmol/K
T0 = 300 #K
F = 96485 #mC/mmol

i0_a = 1e-4 #mA/mm^2
i0_c = 1e-1 #mA/mm^2

E_cp = 6e4
E_cm = 5e4
E_e = 5e4
E_a = 1e5
nu_cp = 0.3
nu_cm = 0.25
nu_e = 0.25
nu_a = 0.3

u_penalty = 1e8

Omega = 60
beta = 1e-4
CTE = 1e-5

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s

T_penalty = 1

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
  thermal_deformation_gradient = Ft
[]

[Mesh]
  [battery]
    type = FileMeshGenerator
    file = &#x27;gold/ssb.msh&#x27;
  []
  [interfaces]
    type = BreakMeshByBlockGenerator
    input = battery
    add_interface_on_two_sides = true
    split_interface = true
  []
[]

[Variables]
  [Phi_ca]
    block = cm
  []
  [Phi]
  []
  [c]
  []
  [disp_x]
  []
  [disp_y]
  []
  [T]
    initial_condition = ${T0}
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
  [stress]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = pk1
      scalar_type = VonMisesStress
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
[]

[ICs]
  [c_a]
    type = ConstantIC
    variable = c
    value = ${cmin_a}
    block = &#x27;a&#x27;
  []
  [c_e]
    type = ConstantIC
    variable = c
    value = ${c_e}
    block = &#x27;cm e&#x27;
  []
  [c_c]
    type = ConstantIC
    variable = c
    value = ${cmax_c}
    block = &#x27;cp&#x27;
  []
  [c_ref_a]
    type = ConstantIC
    variable = c_ref
    value = ${cmin_a}
    block = &#x27;a&#x27;
  []
  [c_ref_e]
    type = ConstantIC
    variable = c_ref
    value = ${c_e}
    block = &#x27;cm e&#x27;
  []
  [c_ref_c]
    type = ConstantIC
    variable = c_ref
    value = ${cmax_c}
    block = &#x27;cp&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  [charge_balance_ca]
    type = RankOneDivergence
    variable = Phi_ca
    vector = i_ca
    block = cm
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [negative_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = 1
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    boundary = &#x27;a_e cm_cp e_a cp_cm&#x27;
  []
  [continuity_c]
    type = InterfaceContinuity
    variable = c
    neighbor_var = c
    penalty = ${c_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_Phi_ca]
    type = InterfaceContinuity
    variable = Phi_ca
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_cp&#x27;
  []
  [continuity_Phi]
    type = InterfaceContinuity
    variable = Phi
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_disp_x]
    type = InterfaceContinuity
    variable = disp_x
    neighbor_var = disp_x
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_disp_y]
    type = InterfaceContinuity
    variable = disp_y
    neighbor_var = disp_y
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${in}&#x27;
  []
[]

[BCs]
  [current]
    type = FunctionNeumannBC
    variable = Phi
    boundary = right
    function = in
  []
  [electric_potential]
    type = DirichletBC
    variable = Phi_ca
    boundary = left
    value = 0
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;left right&#x27;
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;a ${sigma_a} e ${sigma_e} cm ${sigma_cm} cp ${sigma_cp}&#x27;
  []
  [conductivity_ca]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma_ca&#x27;
    subdomain_to_prop_value = &#x27;cm ${sigma_ca}&#x27;
    block = cm
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [charge_transport_ca]
    type = BulkChargeTransport
    electrical_energy_density = q_ca
    electric_potential = Phi_ca
    electric_conductivity = sigma_ca
    temperature = T
    block = cm
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
  []
  [current_density_ca]
    type = CurrentDensity
    current_density = i_ca
    electric_potential = Phi_ca
    block = cm
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;D&#x27;
    subdomain_to_prop_value = &#x27;a ${D_a} e ${D_e} cm ${D_cm} cp ${D_cp}&#x27;
  []
  [mobility]
    type = ADParsedMaterial
    f_name = M
    args = &#x27;c_ref T_ref&#x27;
    material_property_names = &#x27;D&#x27;
    function = &#x27;D*c_ref/${R}/T_ref&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T_ref
    reference_concentration = ${c_ref_entropy}
  []
  [diffusion]
    type = CondensedMassDiffusion
    mass_flux = j
    mobility = M
    concentration = c
    output_properties = &#x27;j&#x27;
    outputs = exodus
  []

  # Redox
  [ramp]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;ramp&#x27;
    prop_values = &#x27;if(t&lt;${t0},t/${t0},1)&#x27;
  []
  [OCP_anode_graphite]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_a}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;a&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_c}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;cp&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;a_e&#x27;
  []
  [charge_transfer_elyte_anode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;e_a&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cp_cm&#x27;
  []
  [charge_transfer_elyte_cathode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cm_cp&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
  []

  # Mechanical
  [stiffness_cp]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cp*nu_cp/(1+nu_cp)/(1-2*nu_cp)} ${fparse E_cp/2/(1+nu_cp)}&#x27;
    block = cp
  []
  [stiffness_cm]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cm*nu_cm/(1+nu_cm)/(1-2*nu_cm)} ${fparse E_cm/2/(1+nu_cm)}&#x27;
    block = cm
  []
  [stiffness_e]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_e*nu_e/(1+nu_e)/(1-2*nu_e)} ${fparse E_e/2/(1+nu_e)}&#x27;
    block = e
  []
  [stiffness_a]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_a*nu_a/(1+nu_a)/(1-2*nu_a)} ${fparse E_a/2/(1+nu_a)}&#x27;
    block = a
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;beta&#x27;
    prop_values = &#x27;${beta}&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = T_ref
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
    displacements = &#x27;disp_x disp_y&#x27;
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi_ca
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_l - V_r&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [in]
    type = FunctionValuePostprocessor
    function = in
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;-dt*in*${width}&#x27;
    pp_names = &#x27;dt in&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [cmin_c]
    type = NodalExtremeValue
    variable = c
    value_type = min
    block = &#x27;cp&#x27;
  []
  [cmax_a]
    type = NodalExtremeValue
    variable = c
    value_type = max
    block = &#x27;a&#x27;
  []
[]

[UserObjects]
  [kill_a]
    type = Terminator
    expression = &#x27;cmax_a &gt;= ${cmax_a}&#x27;
    message = &#x27;Concentration in anode exceeds the maximum allowable value.&#x27;
  []
  [kill_cp]
    type = Terminator
    expression = &#x27;cmin_c &lt;= ${cmin_c}&#x27;
    message = &#x27;Concentration in cathode particle is below the minimum allowable value.&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options = &#x27;-ksp_converged_reason&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_interp_type -pc_hypre_boomeramg_coarsen_type -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths -pc_hypre_boomeramg_truncfactor&#x27;
  petsc_options_value = &#x27;hypre boomeramg 151 0.25 ext+i PMIS 4 2 0.4&#x27;
  # petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  # petsc_options_value = &#x27;lu superlu_dist&#x27;
  automatic_scaling = true
  # line_search = none
  ignore_variables_for_autoscaling = &#x27;T&#x27;
  verbose = true

  l_tol = 1e-06
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-10
  nl_max_its = 12
  l_max_its = 150

  # [TimeStepper]
  #   type = IterationAdaptiveDT
  #   dt = ${dt}
  #   optimal_iterations = 7
  #   iteration_window = 2
  #   growth_factor = 1.2
  #   cutback_factor = 0.2
  #   cutback_factor_at_failure = 0.1
  #   linear_iteration_ratio = 100000
  # []
  [TimeStepper]
    type = FunctionDT
    function = &#x27;if(t&lt;${t0}, ${fparse t0/50}, ${fparse -1e-2/in})&#x27;
    growth_factor = 1.2
    cutback_factor_at_failure = 0.1
  []
  end_time = 100000
[]

[Outputs]
  file_base = &#x27;beta_${beta}&#x27;
  csv = true
  exodus = true
  print_linear_residuals = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="f293dc76-a556-4723-8380-c3b56c35ed4e"><div class="modal-content"><h4>(examples/creep-diffusion/bulk/creep-diffusion.i)</h4><pre class="moose-pre"><code class="language-text">lambda = 1e5
G = 8e4
alpha = 1
Omega = 100
sigma_y = 300
n = 5
A = 1e-6
ad = 1
Nr = 5e-12
Qv = 1e4

c0 = 1e-6
T0 = 800
M = 1e-8
mu0 = 1e3
R = 8.3145

load = 200
t0 = &#x27;${fparse load*60}&#x27;
dt = &#x27;${fparse t0/100}&#x27;
tf = 1e9
dtmax = &#x27;${fparse tf/100}&#x27;

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  strain = E
  swelling_strain = Es
  mechanical_strain = Em
  elastic_strain = Ee
  plastic_strain = Ep
  equivalent_plastic_strain = ep
  eigen_strain = Eg
  energy_densities = &#x27;dot(psi_m) dot(psi_c) Delta_p zeta&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  [gmg]
    type = GeneratedMeshGenerator
    dim = 3
    nx = 3
    ny = 3
    nz = 3
  []
  use_displaced_mesh = false
[]

[Variables]
  [disp_x]
  []
  [disp_y]
  []
  [disp_z]
  []
  [c]
    initial_condition = ${c0}
  []
[]

[AuxVariables]
  [c_ref]
    initial_condition = ${c0}
  []
  [T]
    initial_condition = ${T0}
  []
  [mu_old]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADMaterialRealAux
      property = mu
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
[]

[Kernels]
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = cauchy
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = cauchy
    factor = -1
  []
  [momentum_balance_z]
    type = RankTwoDivergence
    variable = disp_z
    component = 2
    tensor = cauchy
    factor = -1
  []
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  [mass_source]
    type = MaterialSource
    variable = c
    prop = m
    coefficient = -1
  []
[]

[Functions]
  [load]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${load}&#x27;
  []
[]

[BCs]
  [fix_x]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;left&#x27;
    value = 0
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;bottom&#x27;
    value = 0
  []
  [fix_z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;back&#x27;
    value = 0
  []
  [force_y]
    type = FunctionNeumannBC
    variable = disp_y
    boundary = &#x27;top&#x27;
    function = load
  []
[]

[Constraints]
  [ev_x]
    type = EqualValueBoundaryConstraint
    variable = disp_x
    secondary = right
    penalty = 1e8
  []
  [ev_y]
    type = EqualValueBoundaryConstraint
    variable = disp_y
    secondary = top
    penalty = 1e8
  []
  [ev_z]
    type = EqualValueBoundaryConstraint
    variable = disp_z
    secondary = front
    penalty = 1e8
  []
[]

[Materials]
  [chemical]
    type = ADGenericConstantMaterial
    prop_names = &#x27;M mu0&#x27;
    prop_values = &#x27;${M} ${mu0}&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T
    reference_concentration = c_ref
    reference_chemical_potential = mu0
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
    outputs = exodus
  []
  [mass_source]
    type = MassSource
    mass_source = m
    chemical_potential = mu
    outputs = exodus
  []
  [stiffness]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G sigma_y&#x27;
    prop_values = &#x27;${lambda} ${G} ${sigma_y}&#x27;
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;alpha Nr&#x27;
    prop_values = &#x27;${alpha} ${Nr}&#x27;
  []
  [swelling]
    type = SwellingStrain
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = alpha
  []
  [strain]
    type = Strain
  []
  [mechanical_strain]
    type = MechanicalStrain
  []
  [envelope]
    type = ADDerivativeParsedMaterial
    property_name = Delta_p
    expression = &#x27;sigma_y * ep_dot * (1 - exp(-${ad}*mu_old/${R}/T))&#x27;
    coupled_variables = &#x27;mu_old T&#x27;
    material_property_names = &#x27;sigma_y ep_dot mu0&#x27;
    additional_derivative_symbols = &#x27;ep_dot&#x27;
    derivative_order = 2
    compute = false
  []
  [vacancy_nucleation]
    type = ADParsedMaterial
    property_name = dDelta_p/dmu
    # expression = &#x27;sigma_y * ep_dot * exp(-${ad}*mu_old/${R}/T) * ${ad} / ${R} / T + if(p&gt;0,1,0) * p * Nr * exp(-${av}*mu_old/${R}/T) * ${av} / ${R} / T&#x27;
    expression = &#x27;sigma_y * ep_dot * exp(-${ad}*mu_old/${R}/T) * ${ad} / ${R} / T + if(p&gt;0,1,0) * p * Nr * exp(- ${Qv} / ${R} / T)&#x27;
    coupled_variables = &#x27;mu_old T&#x27;
    material_property_names = &#x27;sigma_y ep_dot Nr p&#x27;
  []
  [elastic_energy_density]
    type = SDElasticEnergyDensity
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    creep_exponent = ${n}
    creep_coefficient = ${A}
    plastic_dissipation_material = envelope
    plastic_power_density = Delta_p
    output_properties = &#x27;ep ddot(psi_m)/ddot(c)&#x27;
    outputs = &#x27;exodus&#x27;
  []
  [stress]
    type = SDStress
    cauchy_stress = cauchy
    strain_rate = &#x27;dot(E)&#x27;
    outputs = exodus
  []
  [hydrostatic_stress]
    type = ADRankTwoInvariant
    property_name = p
    rank_two_tensor = cauchy
    invariant = Hydrostatic
  []
  [strain_yy]
    type = ADRankTwoCartesianComponent
    property_name = Eyy
    rank_two_tensor = E
    index_i = 1
    index_j = 1
  []
  [strain_rate_yy]
    type = ADRankTwoCartesianComponent
    property_name = dot(Eyy)
    rank_two_tensor = dot(E)
    index_i = 1
    index_j = 1
  []
  [creep_strain_yy]
    type = ADRankTwoCartesianComponent
    property_name = Epyy
    rank_two_tensor = Ep
    index_i = 1
    index_j = 1
  []
  [swelling_strain_yy]
    type = ADRankTwoCartesianComponent
    property_name = Esyy
    rank_two_tensor = Es
    index_i = 1
    index_j = 1
  []
[]

[Postprocessors]
  [Eyy_dot]
    type = ADElementAverageMaterialProperty
    mat_prop = dot(Eyy)
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [Esyy]
    type = ADElementAverageMaterialProperty
    mat_prop = Esyy
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    outputs = none
  []
  [Epyy]
    type = ADElementAverageMaterialProperty
    mat_prop = Epyy
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    outputs = none
  []
  [dt]
    type = TimestepSize
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    outputs = none
  []
  [delta_Esyy]
    type = ChangeOverTimestepPostprocessor
    postprocessor = Esyy
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    outputs = none
  []
  [delta_Epyy]
    type = ChangeOverTimestepPostprocessor
    postprocessor = Epyy
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    outputs = none
  []
  [Esyy_dot]
    type = ParsedPostprocessor
    function = &#x27;delta_Esyy/dt&#x27;
    pp_names = &#x27;delta_Esyy dt&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [Epyy_dot]
    type = ParsedPostprocessor
    function = &#x27;delta_Epyy/dt&#x27;
    pp_names = &#x27;delta_Epyy dt&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [cavity_density]
    type = ElementAverageValue
    variable = c
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [cavity_potential]
    type = ADElementAverageMaterialProperty
    mat_prop = mu
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [p]
    type = ADElementAverageMaterialProperty
    mat_prop = p
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true
  line_search = none

  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-10
  nl_max_its = 20
  nl_forced_its = 1

  [TimeStepper]
    type = IterationAdaptiveDT
    dt = ${dt}
    optimal_iterations = 6
    iteration_window = 1
    growth_factor = 2
    cutback_factor = 0.5
    cutback_factor_at_failure = 0.2
    linear_iteration_ratio = 100000
  []
  end_time = ${tf}
  dtmax = ${dtmax}

  [Predictor]
    type = SimplePredictor
    scale = 1
    skip_after_failed_timestep = true
  []
[]

[Outputs]
  file_base = &#x27;load_${load}&#x27;
  csv = true
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="e4e048e0-dcd1-41fd-a4a5-527f01dac5b1"><div class="modal-content"><h4>(examples/SSB_3D/charging.i)</h4><pre class="moose-pre"><code class="language-text">I = 2.5e-4 #mA
width = 0.05 #mm
in = &#x27;${fparse -I/width/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;
dt = &#x27;${fparse t0/100}&#x27;

sigma_a = 0.2 #mS/mm
sigma_e = 0.1 #mS/mm
sigma_cp = 0.05 #mS/mm
sigma_ca = 0.5 #mS/mm
sigma_cm = 0.05 #mS/mm

Phi_penalty = 100

cmin_a = 1e-4 #mmol/mm^3
cmax_a = 1e-3 #mmol/mm^3
c_e = 5e-4 #mmol/mm^3
cmin_c = 1e-4 #mmol/mm^3
cmax_c = 1e-3 #mmol/mm^3
c_ref_entropy = 5e-5
D_cp = 5e-5 #mm^2/s
D_cm = 1e-4 #mm^2/s
D_a = 5e-4 #mm^2/s
D_e = 1e-4 #mm^2/s

c_penalty = 5e-1

R = 8.3145 #mJ/mmol/K
T0 = 300 #K
F = 96485 #mC/mmol

i0_a = 1e-4 #mA/mm^2
i0_c = 1e-1 #mA/mm^2

E_cp = 6e4
E_cm = 5e4
E_e = 5e4
E_a = 1e5
nu_cp = 0.3
nu_cm = 0.25
nu_e = 0.25
nu_a = 0.3

u_penalty = 1e8

Omega = 60
beta = 1e-4
CTE = 1e-5

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s

T_penalty = 2

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
  thermal_deformation_gradient = Ft
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  [battery]
    type = FileMeshGenerator
    file = &#x27;coarse.e&#x27;
  []
  [scale]
    type = TransformGenerator
    input = battery
    transform = SCALE
    vector_value = &#x27;1e-3 1e-3 1e-3&#x27; #um to mm
  []
  [cathode_particle]
    type = RenameBlockGenerator
    input = scale
    old_block = &#x27;1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44&#x27;
    new_block = &#x27;cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp&#x27;
  []
  [cathode_matrix]
    type = RenameBlockGenerator
    input = cathode_particle
    old_block = &#x27;48&#x27;
    new_block = &#x27;cm&#x27;
  []
  [elyte]
    type = RenameBlockGenerator
    input = cathode_matrix
    old_block = 49
    new_block = &#x27;e&#x27;
  []
  [anode]
    type = RenameBlockGenerator
    input = elyte
    old_block = 50
    new_block = &#x27;a&#x27;
  []
  [interfaces]
    type = BreakMeshByBlockGenerator
    input = anode
    add_interface_on_two_sides = true
    split_interface = true
  []
  [sidesets]
    type = SideSetsFromNormalsGenerator
    input = interfaces
    normals = &#x27;-1 0 0 1 0 0&#x27;
    new_boundary = &#x27;left right&#x27;
  []
  use_displaced_mesh = false
[]

[Variables]
  [Phi_ca]
    block = cm
  []
  [Phi]
  []
  [c]
  []
  [disp_x]
  []
  [disp_y]
  []
  [disp_z]
  []
  [T]
    initial_condition = ${T0}
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
  [stress]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = pk1
      scalar_type = VonMisesStress
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
[]

[ICs]
  [c_a]
    type = ConstantIC
    variable = c
    value = ${cmin_a}
    block = &#x27;a&#x27;
  []
  [c_e]
    type = ConstantIC
    variable = c
    value = ${c_e}
    block = &#x27;cm e&#x27;
  []
  [c_c]
    type = ConstantIC
    variable = c
    value = ${cmax_c}
    block = &#x27;cp&#x27;
  []
  [c_ref_a]
    type = ConstantIC
    variable = c_ref
    value = ${cmin_a}
    block = &#x27;a&#x27;
  []
  [c_ref_e]
    type = ConstantIC
    variable = c_ref
    value = ${c_e}
    block = &#x27;cm e&#x27;
  []
  [c_ref_c]
    type = ConstantIC
    variable = c_ref
    value = ${cmax_c}
    block = &#x27;cp&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  [charge_balance_ca]
    type = RankOneDivergence
    variable = Phi_ca
    vector = i_ca
    block = cm
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
  [momentum_balance_z]
    type = RankTwoDivergence
    variable = disp_z
    component = 2
    tensor = pk1
    factor = -1
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [negative_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = 1
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    boundary = &#x27;a_e cm_cp e_a cp_cm&#x27;
  []
  [continuity_c]
    type = InterfaceContinuity
    variable = c
    neighbor_var = c
    penalty = ${c_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_Phi_ca]
    type = InterfaceContinuity
    variable = Phi_ca
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_cp&#x27;
  []
  [continuity_Phi]
    type = InterfaceContinuity
    variable = Phi
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_disp_x]
    type = InterfaceContinuity
    variable = disp_x
    neighbor_var = disp_x
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_disp_y]
    type = InterfaceContinuity
    variable = disp_y
    neighbor_var = disp_y
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_disp_z]
    type = InterfaceContinuity
    variable = disp_z
    neighbor_var = disp_z
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${in}&#x27;
  []
[]

[BCs]
  [current]
    type = FunctionNeumannBC
    variable = Phi
    boundary = right
    function = in
  []
  [potential]
    type = DirichletBC
    variable = Phi_ca
    boundary = left
    value = 0
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_z]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;left right&#x27;
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;a ${sigma_a} e ${sigma_e} cm ${sigma_cm} cp ${sigma_cp}&#x27;
  []
  [conductivity_ca]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma_ca&#x27;
    subdomain_to_prop_value = &#x27;cm ${sigma_ca}&#x27;
    block = cm
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [charge_transport_ca]
    type = BulkChargeTransport
    electrical_energy_density = q_ca
    electric_potential = Phi_ca
    electric_conductivity = sigma_ca
    temperature = T
    block = cm
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
  []
  [current_density_ca]
    type = CurrentDensity
    current_density = i_ca
    electric_potential = Phi_ca
    block = cm
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;D&#x27;
    subdomain_to_prop_value = &#x27;a ${D_a} e ${D_e} cm ${D_cm} cp ${D_cp}&#x27;
  []
  [mobility]
    type = ADParsedMaterial
    f_name = M
    args = &#x27;c_ref T_ref&#x27;
    material_property_names = &#x27;D&#x27;
    function = &#x27;D*c_ref/${R}/T_ref&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T_ref
    reference_concentration = ${c_ref_entropy}
  []
  [diffusion]
    type = CondensedMassDiffusion
    mass_flux = j
    mobility = M
    concentration = c
  []

  # Redox
  [ramp]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;ramp&#x27;
    prop_values = &#x27;if(t&lt;${t0},t/${t0},1)&#x27;
  []
  [OCP_anode_graphite]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_a}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;a&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_c}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;cp&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;a_e&#x27;
  []
  [charge_transfer_elyte_anode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;e_a&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cp_cm&#x27;
  []
  [charge_transfer_elyte_cathode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cm_cp&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
  []

  # Mechanical
  [stiffness_cp]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cp*nu_cp/(1+nu_cp)/(1-2*nu_cp)} ${fparse E_cp/2/(1+nu_cp)}&#x27;
    block = cp
  []
  [stiffness_cm]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cm*nu_cm/(1+nu_cm)/(1-2*nu_cm)} ${fparse E_cm/2/(1+nu_cm)}&#x27;
    block = cm
  []
  [stiffness_e]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_e*nu_e/(1+nu_e)/(1-2*nu_e)} ${fparse E_e/2/(1+nu_e)}&#x27;
    block = e
  []
  [stiffness_a]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_a*nu_a/(1+nu_a)/(1-2*nu_a)} ${fparse E_a/2/(1+nu_a)}&#x27;
    block = a
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;beta&#x27;
    prop_values = &#x27;${beta}&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = T_ref
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi_ca
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_l - V_r&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [in]
    type = FunctionValuePostprocessor
    function = in
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;-dt*in*${width}&#x27;
    pp_names = &#x27;dt in&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [cmin_c]
    type = NodalExtremeValue
    variable = c
    value_type = min
    block = &#x27;cp&#x27;
  []
  [cmax_a]
    type = NodalExtremeValue
    variable = c
    value_type = max
    block = &#x27;a&#x27;
  []
[]

[UserObjects]
  [kill_a]
    type = Terminator
    expression = &#x27;cmax_a &gt;= ${cmax_a}&#x27;
    message = &#x27;Concentration in anode exceeds the maximum allowable value.&#x27;
  []
  [kill_cp]
    type = Terminator
    expression = &#x27;cmin_c &lt;= ${cmin_c}&#x27;
    message = &#x27;Concentration in cathode particle is below the minimum allowable value.&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options = &#x27;-ksp_converged_reason&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_interp_type -pc_hypre_boomeramg_coarsen_type -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths -pc_hypre_boomeramg_truncfactor&#x27;
  petsc_options_value = &#x27;hypre boomeramg 601 0.6 ext+i PMIS 4 2 0.4&#x27;
  automatic_scaling = true
  ignore_variables_for_autoscaling = &#x27;T&#x27;
  verbose = true

  l_max_its = 600
  l_tol = 1e-6
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-9
  nl_max_its = 12

  [TimeStepper]
    type = IterationAdaptiveDT
    dt = ${dt}
    optimal_iterations = 6
    iteration_window = 1
    growth_factor = 1.2
    cutback_factor = 0.2
    cutback_factor_at_failure = 0.1
    linear_iteration_ratio = 300
  []
  end_time = 10000
[]

[Outputs]
  [exo]
    type = Exodus
    interval = 5
    file_base = &#x27;${outname}_I_${I}&#x27;
  []
  [csv]
    type = CSV
    file_base = &#x27;${outname}_I_${I}&#x27;
  []
  print_linear_residuals = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="7113a2a0-e468-4807-8357-47635a87f651"><div class="modal-content"><h4>(test/tests/electrical/bv.i)</h4><pre class="moose-pre"><code class="language-text">n = 100
sigma = 10
alpha = 0.5
i0 = 1
F = 96485
R = 8.3145
T = 300
U = 0.1

[Mesh]
  [left]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = 0
    xmax = 1
    ymin = 0
    ymax = 1
    nx = ${n}
    ny = 1
    boundary_name_prefix = anode
  []
  [right]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = 1
    xmax = 2
    ymin = 0
    ymax = 1
    nx = ${n}
    ny = 1
    boundary_name_prefix = elyte
    boundary_id_offset = 100
  []
  [stitch]
    type = StitchedMeshGenerator
    inputs = &#x27;left right&#x27;
    stitch_boundaries_pairs = &#x27;anode_right elyte_left&#x27;
  []
  [rename]
    type = RenameBoundaryGenerator
    input = stitch
    old_boundary = &#x27;anode_left elyte_right&#x27;
    new_boundary = &#x27;left right&#x27;
  []
  [anode]
    type = SubdomainBoundingBoxGenerator
    input = rename
    bottom_left = &#x27;0 0 0&#x27;
    top_right = &#x27;1 1 0&#x27;
    block_id = 0
    block_name = anode
  []
  [elyte]
    type = SubdomainBoundingBoxGenerator
    input = anode
    bottom_left = &#x27;1 0 0&#x27;
    top_right = &#x27;2 1 0&#x27;
    block_id = 1
    block_name = elyte
  []
  [break]
    type = BreakMeshByBlockGenerator
    input = elyte
    split_interface = true
    add_interface_on_two_sides = true
  []
[]

[Variables]
  [Phi]
  []
[]

[AuxVariables]
  [T]
    initial_condition = ${T}
  []
[]

[Kernels]
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
[]

[InterfaceKernels]
  [current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ibv
    boundary = &#x27;anode_elyte&#x27;
  []
[]

[Functions]
  [in]
    type = ParsedFunction
    expression = &#x27;-t&#x27;
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = Phi
    boundary = left
    value = 0
  []
  [right]
    type = FunctionNeumannBC
    variable = Phi
    boundary = right
    function = in
  []
[]

[Materials]
  [electric_constants]
    type = ADGenericConstantMaterial
    prop_names = &#x27;sigma&#x27;
    prop_values = &#x27;${sigma}&#x27;
  []
  [charge_trasport]
    type = BulkChargeTransport
    electrical_energy_density = E
    electric_potential = Phi
    electric_conductivity = sigma
  []
  [current]
    type = CurrentDensity
    current_density = i
    energy_densities = &#x27;E&#x27;
    electric_potential = Phi
  []
  [OCP_anode]
    type = ADParsedMaterial
    property_name = U
    expression = &#x27;${U}&#x27;
    boundary = &#x27;anode_elyte&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    charge_transfer_current_density = ibv
    charge_transfer_mass_flux = jbv
    charge_transfer_heat_flux = hbv
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = ${alpha}
    exchange_current_density = ${i0}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;anode_elyte&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true

  dt = 1e-3
  end_time = 1

  timestep_tolerance = 1e-10
[]

[Postprocessors]
  [Phi_r]
    type = PointValue
    variable = Phi
    point = &#x27;2 0 0&#x27;
    outputs = none
  []
  [delta_Phi]
    type = ParsedPostprocessor
    function = &#x27;-Phi_r&#x27;
    pp_names = &#x27;Phi_r&#x27;
  []
  [in]
    type = FunctionValuePostprocessor
    function = in
  []
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="09dd01fb-52ea-4f44-866c-86526e443e39"><div class="modal-content"><h4>(examples/SSB/CV_charging.i)</h4><pre class="moose-pre"><code class="language-text">I = 0.005 #mA
width = 0.05 #mm
in = &#x27;${fparse -I/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;

sigma_a = 0.2 #mS/mm
sigma_e = 0.1 #mS/mm
sigma_cp = 0.05 #mS/mm
sigma_ca = 0.2 #mS/mm
sigma_cm = 0.05 #mS/mm

Phi_penalty = 10

cmin_a = 1e-4 #mmol/mm^3
cmax_a = 1e-3 #mmol/mm^3
c_e = 5e-4 #mmol/mm^3
cmax_c = 1e-3 #mmol/mm^3
c_ref_entropy = 5e-5
D_cp = 5e-5 #mm^2/s
D_cm = 1e-4 #mm^2/s
D_a = 5e-4 #mm^2/s
D_e = 1e-4 #mm^2/s

c_penalty = 1

R = 8.3145 #mJ/mmol/K
T0 = 300 #K
F = 96485 #mC/mmol

i0_a = 1e-1 #mA/mm^2
i0_c = 1e-1 #mA/mm^2

E_cp = 6e4
E_cm = 5e4
E_e = 5e4
E_a = 1e5
nu_cp = 0.3
nu_cm = 0.25
nu_e = 0.25
nu_a = 0.3

u_penalty = 1e8

Omega = 140
beta = 1e-4
CTE = 1e-5

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s
htc = 9.5e-3

T_penalty = 1

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
  thermal_deformation_gradient = Ft
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Problem]
  restart_file_base = &#x27;CC_charging_out_cp/LATEST&#x27;
[]

[Mesh]
  [battery]
    type = FileMeshGenerator
    file = &#x27;gold/ssb.msh&#x27;
  []
  [interfaces]
    type = BreakMeshByBlockGenerator
    input = battery
    add_interface_on_two_sides = true
    split_interface = true
  []
  use_displaced_mesh = false
[]

[Variables]
  [Phi_ca]
    block = cm
  []
  [Phi]
  []
  [c]
  []
  [disp_x]
  []
  [disp_y]
  []
  [T]
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
  [stress]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = pk1
      scalar_type = Hydrostatic
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Js]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = Fs
      scalar_type = ThirdInvariant
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Jt]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = Ft
      scalar_type = ThirdInvariant
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Phi0]
    [AuxKernel]
      type = ParsedAux
      function = &#x27;Phi&#x27;
      args = &#x27;Phi&#x27;
      execute_on = &#x27;INITIAL&#x27;
    []
  []
[]

[ICs]
  [c_ref_a]
    type = ConstantIC
    variable = c_ref
    value = ${cmin_a}
    block = &#x27;a&#x27;
  []
  [c_ref_e]
    type = ConstantIC
    variable = c_ref
    value = ${c_e}
    block = &#x27;cm e&#x27;
  []
  [c_ref_c]
    type = ConstantIC
    variable = c_ref
    value = ${cmax_c}
    block = &#x27;cp&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  [charge_balance_ca]
    type = RankOneDivergence
    variable = Phi_ca
    vector = i_ca
    block = cm
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [negative_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = 1
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    boundary = &#x27;a_e cm_cp e_a cp_cm&#x27;
  []
  [continuity_c]
    type = InterfaceContinuity
    variable = c
    neighbor_var = c
    penalty = ${c_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_Phi_ca]
    type = InterfaceContinuity
    variable = Phi_ca
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_cp&#x27;
  []
  [continuity_Phi]
    type = InterfaceContinuity
    variable = Phi
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_disp_x]
    type = InterfaceContinuity
    variable = disp_x
    neighbor_var = disp_x
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_disp_y]
    type = InterfaceContinuity
    variable = disp_y
    neighbor_var = disp_y
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${in}&#x27;
  []
[]

[BCs]
  [current]
    type = CoupledVarDirichletBC
    variable = Phi
    boundary = right
    value = Phi0
  []
  [potential]
    type = DirichletBC
    variable = Phi_ca
    boundary = left
    value = 0
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  []
  [hconv]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;left right&#x27;
    value = -1
    boundary_material = qconv
  []
[]

[Constraints]
  [ev_y]
    type = EqualValueBoundaryConstraint
    variable = disp_y
    penalty = ${u_penalty}
    secondary = top
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;a ${sigma_a} e ${sigma_e} cm ${sigma_cm} cp ${sigma_cp}&#x27;
  []
  [conductivity_ca]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma_ca&#x27;
    subdomain_to_prop_value = &#x27;cm ${sigma_ca}&#x27;
    block = cm
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [charge_transport_ca]
    type = BulkChargeTransport
    electrical_energy_density = q_ca
    electric_potential = Phi_ca
    electric_conductivity = sigma_ca
    temperature = T
    block = cm
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
    output_properties = i
    outputs = exodus
  []
  [current_density_ca]
    type = CurrentDensity
    current_density = i_ca
    electric_potential = Phi_ca
    output_properties = i_ca
    outputs = exodus
    block = cm
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;D&#x27;
    subdomain_to_prop_value = &#x27;a ${D_a} e ${D_e} cm ${D_cm} cp ${D_cp}&#x27;
  []
  [mobility]
    type = ADParsedMaterial
    f_name = M
    args = &#x27;c_ref T_ref&#x27;
    material_property_names = &#x27;D&#x27;
    function = &#x27;D*c_ref/${R}/T_ref&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T_ref
    reference_concentration = ${c_ref_entropy}
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
    energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta m&#x27;
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
    outputs = exodus
  []

  # Redox
  [ramp]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;ramp&#x27;
    prop_values = &#x27;if(t&lt;${t0},t/${t0},1)&#x27;
  []
  [OCP_anode_graphite]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_a}; 2.77e-4*x^2-0.0069*x+0.0785&#x27;
    # function = &#x27;x:=c/${cmax_a}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;a&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_c}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;cp&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;a_e&#x27;
  []
  [charge_transfer_elyte_anode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;e_a&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cp_cm&#x27;
  []
  [charge_transfer_elyte_cathode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cm_cp&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
    output_properties = h
    outputs = exodus
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
    output_properties = r
    outputs = exodus
  []
  [conv]
    type = ADParsedMaterial
    f_name = qconv
    function = &#x27;${htc}*(T-T_ref)&#x27;
    args = &#x27;T T_ref&#x27;
    boundary = &#x27;left right&#x27;
  []

  # Mechanical
  [stiffness_cp]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cp*nu_cp/(1+nu_cp)/(1-2*nu_cp)} ${fparse E_cp/2/(1+nu_cp)}&#x27;
    block = cp
  []
  [stiffness_cm]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cm*nu_cm/(1+nu_cm)/(1-2*nu_cm)} ${fparse E_cm/2/(1+nu_cm)}&#x27;
    block = cm
  []
  [stiffness_e]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_e*nu_e/(1+nu_e)/(1-2*nu_e)} ${fparse E_e/2/(1+nu_e)}&#x27;
    block = e
  []
  [stiffness_a]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_a*nu_a/(1+nu_a)/(1-2*nu_a)} ${fparse E_a/2/(1+nu_a)}&#x27;
    block = a
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;beta&#x27;
    prop_values = &#x27;${beta}&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = T_ref
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
    non_swelling_pressure = p
    output_properties = &#x27;p&#x27;
    outputs = exodus
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi_ca
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_l - V_r&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [I]
    type = ADSideIntegralMaterialProperty
    property = i
    component = 0
    boundary = right
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;dt*I&#x27;
    pp_names = &#x27;dt I&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[UserObjects]
  [kill_V]
    type = Terminator
    expression = &#x27;I &lt;= 1e-6&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options = &#x27;-ksp_converged_reason&#x27;
  # petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_interp_type -pc_hypre_boomeramg_coarsen_type -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths -pc_hypre_boomeramg_truncfactor&#x27;
  # petsc_options_value = &#x27;hypre boomeramg 301 0.25 ext+i PMIS 4 2 0.4&#x27;
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true
  ignore_variables_for_autoscaling = &#x27;T&#x27;
  verbose = true
  line_search = none

  l_max_its = 300
  l_tol = 1e-6
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-9
  nl_max_its = 12

  [Predictor]
    type = SimplePredictor
    scale = 1
  []
  [TimeStepper]
    type = IterationAdaptiveDT
    dt = &#x27;${fparse t0/50}&#x27;
    optimal_iterations = 6
    iteration_window = 1
    growth_factor = 1.2
    cutback_factor = 0.2
    cutback_factor_at_failure = 0.1
    linear_iteration_ratio = 100
  []
  end_time = 10000
[]

[Outputs]
  exodus = true
  csv = true
  print_linear_residuals = false
  checkpoint = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="27a6e54d-c8bb-4296-932e-c46299dfc74f"><div class="modal-content"><h4>(examples/LiB/CV_charging.i)</h4><pre class="moose-pre"><code class="language-text">I = 3e-3 #mA
width = 0.03 #mm
in = &#x27;${fparse -I/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;
dt = &#x27;${fparse t0/100}&#x27;

sigma_a = 1e0 #mS/mm
sigma_e = 1e-1 #mS/mm
sigma_c = 1e-2 #mS/mm

l0 = 0
l1 = 0.04
l2 = 0.07
l3 = 0.12

cmin = 1e-4 #mmol/mm^3
cmax = 1e-3 #mmol/mm^3
D_a = 1e-3 #mm^2/s
D_e = 1e-4 #mm^2/s
D_c = 5e-5 #mm^2/s

R = 8.3145 #mJ/mmol/K
T0 = 300 #K
F = 96485 #mC/mmol

i0_a = 1e-1 #mA/mm^2
i0_c = 1e-1 #mA/mm^2

E_c = 1e5
E_e = 1e4
E_a = 2e5
nu_c = 0.3
nu_e = 0.25
nu_a = 0.3

u_penalty = 1e8

Omega = 60
beta = 1e-3
CTE = 1e-5

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s

T_penalty = 2e-1

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q zeta m&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
  thermal_deformation_gradient = Ft
[]

[Problem]
  restart_file_base = &#x27;CC_charging_I_${I}_cp/LATEST&#x27;
[]

[Mesh]
  [battery]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = ${l0}
    xmax = ${l3}
    ymin = 0
    ymax = ${width}
    nx = 60
    ny = 15
  []
  [anode]
    type = SubdomainBoundingBoxGenerator
    input = battery
    block_id = 1
    block_name = anode
    bottom_left = &#x27;${l0} 0 0&#x27;
    top_right = &#x27;${l1} ${width} 0&#x27;
  []
  [elyte]
    type = SubdomainBoundingBoxGenerator
    input = anode
    block_id = 2
    block_name = elyte
    bottom_left = &#x27;${l1} 0 0&#x27;
    top_right = &#x27;${l2} ${width} 0&#x27;
  []
  [cathode]
    type = SubdomainBoundingBoxGenerator
    input = elyte
    block_id = 3
    block_name = cathode
    bottom_left = &#x27;${l2} 0 0&#x27;
    top_right = &#x27;${l3} ${width} 0&#x27;
  []
  [interfaces]
    type = BreakMeshByBlockGenerator
    input = cathode
    add_interface_on_two_sides = true
    split_interface = true
  []
[]

[Variables]
  [Phi]
  []
  [c]
  []
  [disp_x]
  []
  [disp_y]
  []
  [T]
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
  [Phi0]
  []
[]

[ICs]
  [c_ref_min]
    type = ConstantIC
    variable = c_ref
    value = ${cmin}
    block = &#x27;anode&#x27;
  []
  [c_ref_mid]
    type = ConstantIC
    variable = c_ref
    value = &#x27;${fparse (cmax+cmin)/2}&#x27;
    block = &#x27;elyte&#x27;
  []
  [c_ref_max]
    type = ConstantIC
    variable = c_ref
    value = ${cmax}
    block = &#x27;cathode&#x27;
  []
[]

[AuxKernels]
  [Phi0]
    type = ParsedAux
    variable = Phi0
    function = &#x27;Phi&#x27;
    args = &#x27;Phi&#x27;
    execute_on = &#x27;INITIAL&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    boundary = &#x27;elyte_anode cathode_elyte&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    boundary = &#x27;anode_elyte elyte_cathode elyte_anode cathode_elyte&#x27;
  []
  [continuity_disp_x]
    type = InterfaceContinuity
    variable = disp_x
    neighbor_var = disp_x
    penalty = ${u_penalty}
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
  [continuity_disp_y]
    type = InterfaceContinuity
    variable = disp_y
    neighbor_var = disp_y
    penalty = ${u_penalty}
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${in}&#x27;
  []
[]

[BCs]
  [Phi]
    type = CoupledVarDirichletBC
    variable = Phi
    boundary = &#x27;left right&#x27;
    value = Phi0
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  []
  [open]
    type = OpenBC
    variable = c
    flux = jm
    boundary = &#x27;left right&#x27;
  []
[]

[Constraints]
  [y]
    type = EqualValueBoundaryConstraint
    variable = disp_y
    penalty = ${u_penalty}
    secondary = top
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;anode ${sigma_a} elyte ${sigma_e} cathode ${sigma_c}&#x27;
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;D&#x27;
    subdomain_to_prop_value = &#x27;anode ${D_a} elyte ${D_e} cathode ${D_c}&#x27;
  []
  [mobility]
    type = ADParsedMaterial
    f_name = M
    args = &#x27;c_ref T_ref&#x27;
    material_property_names = &#x27;D&#x27;
    function = &#x27;D*c_ref/${R}/T_ref&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T
    reference_concentration = c_ref
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
  []

  # Migration
  [migration]
    type = Migration
    electrochemical_energy_density = m
    electric_potential = Phi
    chemical_potential = mu
    electric_conductivity = sigma
    faraday_constant = ${F}
  []
  [migration_flux]
    type = MassFlux
    mass_flux = jm
    energy_densities = &#x27;m&#x27;
    chemical_potential = mu
  []

  # Redox
  [OCP_anode_graphite]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)&#x27;
    args = c
    block = &#x27;anode&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)&#x27;
    args = c
    block = &#x27;cathode&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;anode_elyte&#x27;
  []
  [charge_transfer_elyte_anode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;elyte_anode&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cathode_elyte&#x27;
  []
  [charge_transfer_elyte_cathode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;elyte_cathode&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
  []

  # Mechanical
  [stiffness_c]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_c*nu_c/(1+nu_c)/(1-2*nu_c)} ${fparse E_c/2/(1+nu_c)}&#x27;
    block = cathode
  []
  [stiffness_e]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_e*nu_e/(1+nu_e)/(1-2*nu_e)} ${fparse E_e/2/(1+nu_e)}&#x27;
    block = elyte
  []
  [stiffness_a]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_a*nu_a/(1+nu_a)/(1-2*nu_a)} ${fparse E_a/2/(1+nu_a)}&#x27;
    block = anode
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;beta&#x27;
    prop_values = &#x27;${beta}&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = T_ref
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
    displacements = &#x27;disp_x disp_y&#x27;
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_r - V_l&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [I]
    type = ADSideIntegralMaterialProperty
    property = i
    component = 0
    boundary = right
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;-dt*I&#x27;
    pp_names = &#x27;dt I&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_a_max]
    type = NodalExtremeValue
    variable = c
    value_type = max
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_c_min]
    type = NodalExtremeValue
    variable = c
    value_type = min
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_a_min]
    type = NodalExtremeValue
    variable = c
    value_type = min
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_c_max]
    type = NodalExtremeValue
    variable = c
    value_type = max
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_a]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_e]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = elyte
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_c]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[UserObjects]
  [kill_i]
    type = Terminator
    expression = &#x27;-I &lt;= 1e-6&#x27;
    message = &#x27;No current.&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true

  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-10
  nl_max_its = 20

  [Predictor]
    type = SimplePredictor
    scale = 1
    skip_after_failed_timestep = true
  []
  [TimeStepper]
    type = IterationAdaptiveDT
    dt = ${dt}
    optimal_iterations = 7
    iteration_window = 2
    growth_factor = 1.2
    cutback_factor = 0.5
    cutback_factor_at_failure = 0.2
    linear_iteration_ratio = 1000000
  []
  start_time = 0
  end_time = 100000

  steady_state_start_time = 10
  steady_state_detection = true
[]

[Outputs]
  file_base = &#x27;CV_charging_I_${I}&#x27;
  csv = true
  exodus = true
  print_linear_residuals = false
  checkpoint = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="621bfab7-aec2-40d0-8801-54529bfe3f88"><div class="modal-content"><h4>(examples/LiB/CC_charging.i)</h4><pre class="moose-pre"><code class="language-text">I = 3e-3 #mA
width = 0.03 #mm
in = &#x27;${fparse -I/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;
dt = &#x27;${fparse t0/100}&#x27;

sigma_a = 1e0 #mS/mm
sigma_e = 1e-1 #mS/mm
sigma_c = 1e-2 #mS/mm

l0 = 0
l1 = 0.04
l2 = 0.07
l3 = 0.12

cmin = 1e-4 #mmol/mm^3
cmax = 1e-3 #mmol/mm^3
D_a = 1e-3 #mm^2/s
D_e = 1e-4 #mm^2/s
D_c = 5e-5 #mm^2/s

R = 8.3145 #mJ/mmol/K
T0 = 300 #K
F = 96485 #mC/mmol

i0_a = 1e-1 #mA/mm^2
i0_c = 1e-1 #mA/mm^2

E_c = 1e5
E_e = 1e4
E_a = 2e5
nu_c = 0.3
nu_e = 0.25
nu_a = 0.3

u_penalty = 1e8

Omega = 60
beta = 1e-3
CTE = 1e-5

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s

T_penalty = 2e-1

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q zeta m&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
  thermal_deformation_gradient = Ft
[]

[Mesh]
  [battery]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = ${l0}
    xmax = ${l3}
    ymin = 0
    ymax = ${width}
    nx = 60
    ny = 15
  []
  [anode]
    type = SubdomainBoundingBoxGenerator
    input = battery
    block_id = 1
    block_name = anode
    bottom_left = &#x27;${l0} 0 0&#x27;
    top_right = &#x27;${l1} ${width} 0&#x27;
  []
  [elyte]
    type = SubdomainBoundingBoxGenerator
    input = anode
    block_id = 2
    block_name = elyte
    bottom_left = &#x27;${l1} 0 0&#x27;
    top_right = &#x27;${l2} ${width} 0&#x27;
  []
  [cathode]
    type = SubdomainBoundingBoxGenerator
    input = elyte
    block_id = 3
    block_name = cathode
    bottom_left = &#x27;${l2} 0 0&#x27;
    top_right = &#x27;${l3} ${width} 0&#x27;
  []
  [interfaces]
    type = BreakMeshByBlockGenerator
    input = cathode
    add_interface_on_two_sides = true
    split_interface = true
  []
[]

[Variables]
  [Phi]
  []
  [c]
  []
  [disp_x]
  []
  [disp_y]
  []
  [T]
    initial_condition = ${T0}
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
[]

[ICs]
  [c_min]
    type = ConstantIC
    variable = c
    value = ${cmin}
    block = &#x27;anode&#x27;
  []
  [c_mid]
    type = ConstantIC
    variable = c
    value = &#x27;${fparse (cmax+cmin)/2}&#x27;
    block = &#x27;elyte&#x27;
  []
  [c_max]
    type = ConstantIC
    variable = c
    value = ${cmax}
    block = &#x27;cathode&#x27;
  []
  [c_ref_min]
    type = ConstantIC
    variable = c_ref
    value = ${cmin}
    block = &#x27;anode&#x27;
  []
  [c_ref_mid]
    type = ConstantIC
    variable = c_ref
    value = &#x27;${fparse (cmax+cmin)/2}&#x27;
    block = &#x27;elyte&#x27;
  []
  [c_ref_max]
    type = ConstantIC
    variable = c_ref
    value = ${cmax}
    block = &#x27;cathode&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    boundary = &#x27;elyte_anode cathode_elyte&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    boundary = &#x27;anode_elyte elyte_cathode elyte_anode cathode_elyte&#x27;
  []
  [continuity_disp_x]
    type = InterfaceContinuity
    variable = disp_x
    neighbor_var = disp_x
    penalty = ${u_penalty}
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
  [continuity_disp_y]
    type = InterfaceContinuity
    variable = disp_y
    neighbor_var = disp_y
    penalty = ${u_penalty}
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${in}&#x27;
  []
[]

[BCs]
  [left]
    type = FunctionNeumannBC
    variable = Phi
    boundary = left
    function = in
  []
  [right]
    type = DirichletBC
    variable = Phi
    boundary = right
    value = 0
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  []
  [open]
    type = OpenBC
    variable = c
    flux = jm
    boundary = &#x27;left right&#x27;
  []
[]

[Constraints]
  [y]
    type = EqualValueBoundaryConstraint
    variable = disp_y
    penalty = ${u_penalty}
    secondary = top
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;anode ${sigma_a} elyte ${sigma_e} cathode ${sigma_c}&#x27;
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;D&#x27;
    subdomain_to_prop_value = &#x27;anode ${D_a} elyte ${D_e} cathode ${D_c}&#x27;
  []
  [mobility]
    type = ADParsedMaterial
    f_name = M
    args = &#x27;c_ref T_ref&#x27;
    material_property_names = &#x27;D&#x27;
    function = &#x27;D*c_ref/${R}/T_ref&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T
    reference_concentration = c_ref
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
  []

  # Migration
  [migration]
    type = Migration
    electrochemical_energy_density = m
    electric_potential = Phi
    chemical_potential = mu
    electric_conductivity = sigma
    faraday_constant = ${F}
  []
  [migration_flux]
    type = MassFlux
    mass_flux = jm
    energy_densities = &#x27;m&#x27;
    chemical_potential = mu
  []

  # Redox
  [ramp]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;ramp&#x27;
    prop_values = &#x27;if(t&lt;${t0},t/${t0},1)&#x27;
  []
  [OCP_anode_graphite]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;anode&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;cathode&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;anode_elyte&#x27;
  []
  [charge_transfer_elyte_anode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;elyte_anode&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cathode_elyte&#x27;
  []
  [charge_transfer_elyte_cathode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;elyte_cathode&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
  []

  # Mechanical
  [stiffness_c]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_c*nu_c/(1+nu_c)/(1-2*nu_c)} ${fparse E_c/2/(1+nu_c)}&#x27;
    block = cathode
  []
  [stiffness_e]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_e*nu_e/(1+nu_e)/(1-2*nu_e)} ${fparse E_e/2/(1+nu_e)}&#x27;
    block = elyte
  []
  [stiffness_a]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_a*nu_a/(1+nu_a)/(1-2*nu_a)} ${fparse E_a/2/(1+nu_a)}&#x27;
    block = anode
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;beta&#x27;
    prop_values = &#x27;${beta}&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = T_ref
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
    displacements = &#x27;disp_x disp_y&#x27;
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_r - V_l&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [I]
    type = ADSideIntegralMaterialProperty
    property = i
    component = 0
    boundary = right
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;-dt*I&#x27;
    pp_names = &#x27;dt I&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_a_max]
    type = NodalExtremeValue
    variable = c
    value_type = max
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_c_min]
    type = NodalExtremeValue
    variable = c
    value_type = min
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_a_min]
    type = NodalExtremeValue
    variable = c
    value_type = min
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_c_max]
    type = NodalExtremeValue
    variable = c
    value_type = max
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_a]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_e]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = elyte
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_c]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[UserObjects]
  [kill_a]
    type = Terminator
    expression = &#x27;c_a_max &gt;= ${cmax}&#x27;
    message = &#x27;Concentration in anode exceeds the maximum allowable value.&#x27;
  []
  [kill_c]
    type = Terminator
    expression = &#x27;c_c_min &lt;= ${cmin}&#x27;
    message = &#x27;Concentration in cathode is below the minimum allowable value.&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true
  line_search = none

  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-10
  nl_max_its = 20

  [Predictor]
    type = SimplePredictor
    scale = 1
    skip_after_failed_timestep = true
  []
  [TimeStepper]
    type = IterationAdaptiveDT
    dt = ${dt}
    optimal_iterations = 7
    iteration_window = 2
    growth_factor = 1.2
    cutback_factor = 0.5
    cutback_factor_at_failure = 0.2
    linear_iteration_ratio = 1000000
  []
  end_time = 100000
[]

[Outputs]
  file_base = &#x27;CC_charging_I_${I}&#x27;
  csv = true
  exodus = true
  print_linear_residuals = false
  checkpoint = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="f68d3b18-65dd-4b7d-86af-2b1304c8e51b"><div class="modal-content"><h4>(examples/PCM-GF/equilibriate.i)</h4><pre class="moose-pre"><code class="language-text"># units are in meter kelvin second (m,kg,s)

end_time = 36000

dtmax = 100
dt = 1

sigma_PCM = 5 # (from Wen&#x27;s measurement of Gfoam+PCM in radial direction) (from Cfoam 70% dense foam = 28571.43) S/m (1/electrical resistivity (0.000035 ohm-m))
kappa_PCM = 10 #18.8 # (average of Kxy = 14 W/m-K, Kz = 23.6 W/mK at T=700C) #from Singh et al. Solar energy 159(2018) 270-282 (Prototype 1)
rho_PCM = 2050 # kg/m^3 #from Singh et al. Solar energy 159(2018) 270-282 (Prototype 1)
cp_PCM = 1074 # J/kg-K #from Singh et al. Solar energy 159(2018) 270-282 (Prototype 1)

sigma_pipe = 750750.75 # S/m (resistivity 1.332e-6 ohm-m at T = 700C) #Special metal data sheet
kappa_pipe = 23.9 # W/m-K (at 700C) #Special metal datasheet
rho_pipe = 8359.33 #kg/m^3
cp_pipe = 419 # J/kg-K

sigma_gas = 1e-12
kappa_gas = 0.03 #file:///C:/Users/barua/Downloads/PDS-FOAMGLAS%20ONE-US-en.pdf
rho_gas = 1.29 #file:///C:/Users/barua/Downloads/PDS-FOAMGLAS%20ONE-US-en.pdf
cp_gas = 1000 #file:///C:/Users/barua/Downloads/PDS-FOAMGLAS%20ONE-US-en.pdf

[GlobalParams]
  energy_densities = &#x27;E H&#x27;
[]

[Mesh]
  [fmg]
    type = FileMeshGenerator
    file = &#x27;gold/partial.msh&#x27;
  []
  coord_type = RZ
[]

[Variables]
  [Phi]
  []
  [T]
    initial_condition = 900
  []
[]

[AuxVariables]
  [T_old]
    [AuxKernel]
      type = ParsedAux
      expression = &#x27;T&#x27;
      coupled_variables = &#x27;T&#x27;
      execute_on = &#x27;INITIAL TIMESTEP_BEGIN&#x27;
    []
  []
[]

[Kernels]
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cp
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [energy_balance_3]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[BCs]
  [ground]
    type = DirichletBC
    variable = Phi
    boundary = &#x27;PCM_left&#x27;
    value = 0
  []
  [CV]
    type = FunctionDirichletBC
    variable = Phi
    boundary = &#x27;PCM_right&#x27;
    function = 0
  []
  [hconv]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;inlet&#x27;
    value = -1
    boundary_material = qconv
  []
[]

[Materials]
  [electrical_conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = sigma
    subdomain_to_prop_value = &#x27;PCM ${sigma_PCM} pipe ${sigma_pipe} gas ${sigma_gas}&#x27;
  []
  [charge_trasport]
    type = BulkChargeTransport
    electrical_energy_density = E
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [current]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
  []
  [thermal_conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = kappa
    subdomain_to_prop_value = &#x27;PCM ${kappa_PCM} pipe ${kappa_pipe} gas ${kappa_gas}&#x27;
  []
  [density]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = rho
    subdomain_to_prop_value = &#x27;PCM ${rho_PCM} pipe ${rho_pipe} gas ${rho_gas}&#x27;
  []
  [specific_heat]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = cp
    subdomain_to_prop_value = &#x27;PCM ${cp_PCM} pipe ${cp_pipe} gas ${cp_gas}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = H
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
  []
  [qconv]
    type = ADParsedMaterial
    property_name = qconv
    expression = &#x27;htc*(T-T_inf)&#x27;
    coupled_variables = &#x27;T&#x27;
    constant_names = &#x27;htc T_inf&#x27;
    constant_expressions = &#x27;100 300&#x27;
    boundary = &#x27;inlet&#x27;
  []
  [delta_enthalpy]
    type = ADParsedMaterial
    property_name = delta_enthalpy
    expression = &#x27;rho*cp*(T-T_old)/2&#x27;
    material_property_names = &#x27;rho cp&#x27;
    coupled_variables = &#x27;T T_old&#x27;
  []
[]

[Postprocessors]
  [Tin]
    type = SideExtremeValue
    variable = T
    value_type = min
    boundary = inlet
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true

  end_time = ${end_time}
  dtmax = ${dtmax}
  dtmin = 0.01
  [TimeStepper]
    type = IterationAdaptiveDT
    dt = ${dt}
    cutback_factor = 0.2
    cutback_factor_at_failure = 0.1
    growth_factor = 1.2
    optimal_iterations = 7
    iteration_window = 2
    linear_iteration_ratio = 100000
  []
  [Predictor]
    type = SimplePredictor
    scale = 1
    skip_after_failed_timestep = true
  []

  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-6
  nl_max_its = 12
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="bed5fba5-ac13-46cc-a11b-f55f1d27e768"><div class="modal-content"><h4>(test/tests/chemical-electrical/diffusion_vs_migration.i)</h4><pre class="moose-pre"><code class="language-text">m = 1 # larger m means more migration compared to diffusion
R = 8.3145 #mJ/mmol/K
F = 96485 #mC/mmol

I = 3e-3 #mA
width = 0.03 #mm
in = &#x27;${fparse -I/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;
dt = &#x27;${fparse t0/100}&#x27;
Vmax = 4.3 #V

vf_se = 0.3
vf_cp = 0.5
vf_ca = 0.2

sigma_a = 0.2 #mS/mm
sigma_se = 0.1 #mS/mm
sigma_cp = 0.05 #mS/mm
sigma_ca = 0.2 #mS/mm
sigma_e = ${sigma_se}
sigma_c = &#x27;${fparse vf_se*sigma_se + vf_cp*sigma_cp + vf_ca*sigma_ca}&#x27;

l0 = 0
l1 = 0.04
l2 = 0.07
l3 = 0.12

cmax = 1e-3 #mmol/mm^3
c0_a = 1e-4
c0_e = 5e-4
c0_c = 1e-3

M_a = 8e-11
M_se = &#x27;${fparse sigma_se/F/F/m}&#x27;
M_cp = 4e-14
M_ca = 1e-13
M_e = ${M_se}
M_c = &#x27;${fparse vf_se*M_se + vf_cp*M_cp + vf_ca*M_ca}&#x27;

T0 = 300 #K

i0_a = 1e-1 #mA/mm^2
i0_c = 1e-1 #mA/mm^2

[GlobalParams]
  energy_densities = &#x27;dot(psi_c) q zeta m&#x27;
[]

[Mesh]
  [battery]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = ${l0}
    xmax = ${l3}
    ymin = 0
    ymax = ${width}
    nx = 60
    ny = 15
  []
  [anode]
    type = SubdomainBoundingBoxGenerator
    input = battery
    block_id = 1
    block_name = anode
    bottom_left = &#x27;${l0} 0 0&#x27;
    top_right = &#x27;${l1} ${width} 0&#x27;
  []
  [elyte]
    type = SubdomainBoundingBoxGenerator
    input = anode
    block_id = 2
    block_name = elyte
    bottom_left = &#x27;${l1} 0 0&#x27;
    top_right = &#x27;${l2} ${width} 0&#x27;
  []
  [cathode]
    type = SubdomainBoundingBoxGenerator
    input = elyte
    block_id = 3
    block_name = cathode
    bottom_left = &#x27;${l2} 0 0&#x27;
    top_right = &#x27;${l3} ${width} 0&#x27;
  []
  [anode_elyte]
    type = BreakMeshByBlockGenerator
    input = cathode
    block_pairs = &#x27;1 2&#x27;
    add_interface_on_two_sides = true
    split_interface = true
  []
  [cathode_elyte]
    type = BreakMeshByBlockGenerator
    input = anode_elyte
    block_pairs = &#x27;2 3&#x27;
    add_interface_on_two_sides = true
    split_interface = true
  []
[]

[Variables]
  [Phi]
  []
  [c]
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T]
    initial_condition = ${T0}
  []
[]

[ICs]
  [c_a]
    type = ConstantIC
    variable = c
    value = ${c0_a}
    block = &#x27;anode&#x27;
  []
  [c_e]
    type = ConstantIC
    variable = c
    value = ${c0_e}
    block = &#x27;elyte&#x27;
  []
  [c_c]
    type = ConstantIC
    variable = c
    value = ${c0_c}
    block = &#x27;cathode&#x27;
  []
  [c_ref_a]
    type = ConstantIC
    variable = c_ref
    value = ${c0_a}
    block = &#x27;anode&#x27;
  []
  [c_ref_e]
    type = ConstantIC
    variable = c_ref
    value = ${c0_e}
    block = &#x27;elyte&#x27;
  []
  [c_ref_c]
    type = ConstantIC
    variable = c_ref
    value = ${c0_c}
    block = &#x27;cathode&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    factor_neighbor = 1
    boundary = &#x27;cathode_elyte&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;anode_elyte&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${in}&#x27;
  []
[]

[BCs]
  [left]
    type = FunctionNeumannBC
    variable = Phi
    boundary = left
    function = in
  []
  [right]
    type = DirichletBC
    variable = Phi
    boundary = right
    value = 0
  []
  [open]
    type = OpenBC
    variable = c
    flux = jm
    boundary = &#x27;left right&#x27;
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;anode ${sigma_a} elyte ${sigma_e} cathode ${sigma_c}&#x27;
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
  []

  # Migration
  [migration]
    type = Migration
    electrochemical_energy_density = m
    electric_potential = Phi
    chemical_potential = mu
    electric_conductivity = sigma
    faraday_constant = ${F}
  []
  [migration_flux]
    type = MassFlux
    mass_flux = jm
    energy_densities = &#x27;m&#x27;
    chemical_potential = mu
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;M&#x27;
    subdomain_to_prop_value = &#x27;anode ${M_a} elyte ${M_e} cathode ${M_c}&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T
    reference_concentration = c_ref
    reference_chemical_potential = 1e3
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
  []

  # Redox
  [ramp]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;ramp&#x27;
    prop_values = &#x27;if(t&lt;${t0},t/${t0},1)&#x27;
  []
  [OCP_anode_graphite]
    type = ADParsedMaterial
    property_name = U
    expression = &#x27;x:=c/${cmax}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)*ramp&#x27;
    coupled_variables = c
    material_property_names = &#x27;ramp&#x27;
    boundary = &#x27;anode_elyte&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    property_name = U
    expression = &#x27;x:=c/${cmax}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)*ramp&#x27;
    coupled_variables = c
    material_property_names = &#x27;ramp&#x27;
    boundary = &#x27;cathode_elyte&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;anode_elyte&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cathode_elyte&#x27;
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_r - V_l&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [in]
    type = FunctionValuePostprocessor
    function = in
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;-dt*in*${width}&#x27;
    pp_names = &#x27;dt in&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_a_max]
    type = NodalExtremeValue
    variable = c
    value_type = max
    block = anode
  []
  [c_c_min]
    type = NodalExtremeValue
    variable = c
    value_type = min
    block = cathode
  []
  [mass_a]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_e]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = elyte
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_c]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[UserObjects]
  [kill]
    type = Terminator
    expression = &#x27;V &gt;= ${Vmax}&#x27;
    message = &#x27;Voltage reached Vmax&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true
  line_search = none

  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-10
  nl_max_its = 20
  l_max_its = 150

  [Predictor]
    type = SimplePredictor
    scale = 1
    skip_after_failed_timestep = true
  []

  [TimeStepper]
    type = IterationAdaptiveDT
    dt = ${dt}
    optimal_iterations = 7
    iteration_window = 2
    growth_factor = 1.2
    cutback_factor = 0.5
    cutback_factor_at_failure = 0.2
    linear_iteration_ratio = 1000000
  []
  dtmax = 1
  end_time = 100000
[]

[Outputs]
  file_base = &#x27;diffusion_vs_migration&#x27;
  exodus = true
  print_linear_residuals = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="42a05f3e-3cf9-429d-93d7-2643568b6fae"><div class="modal-content"><h4>(examples/cable/cable.i)</h4><pre class="moose-pre"><code class="language-text">R = 8.3145 #mJ/mmol/K
T0 = 300 #K
F = 96485 #mC/mmol

in = &#x27;${fparse 1e3/pi/34^2}&#x27;

sigma_con = 1

c_ref = 1e-3
c_ref_ent = 1e-6
M_con = 1e-1

kappa_con = 398 #mJ/mm/K/s
kappa_air = 3.98 #mJ/mm/K/s
kappa_ins = 0.29 #mJ/mm/K/s
kappa_jac = 0.39 #mJ/mm/K/s

E_con = 1.1e5
E_air = 1e2
E_ins = 6e2
E_jac = 3e2
nu_con = 0.32
nu_air = 0.25
nu_ins = 0.4
nu_jac = 0.3

CTE = 1e-5

htc = 1e1

[GlobalParams]
  energy_densities = &#x27;q dot(psi_c) zeta m chi dot(psi_m)&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  thermal_deformation_gradient = Ft
[]

[Problem]
  kernel_coverage_check = false
  material_coverage_check = false
[]

[Mesh]
  [fmg]
    type = FileMeshGenerator
    file = &#x27;gold/cable.msh&#x27;
  []
  use_displaced_mesh = false
[]

[Variables]
  [Phi]
    block = &#x27;conductor&#x27;
  []
  [c]
    initial_condition = ${c_ref}
    block = &#x27;conductor&#x27;
  []
  [T]
    initial_condition = ${T0}
  []
  [disp_x]
  []
  [disp_y]
  []
  [disp_z]
  []
[]

[AuxVariables]
  [stress]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = pk1
      scalar_type = Hydrostatic
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
[]

[Functions]
  [current_density]
    type = PiecewiseLinear
    x = &#x27;0 100&#x27;
    y = &#x27;0 ${in}&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
    block = &#x27;conductor&#x27;
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
    block = &#x27;conductor&#x27;
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
    block = &#x27;conductor&#x27;
  []
  # Energy balance
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
  [momentum_balance_z]
    type = RankTwoDivergence
    variable = disp_z
    component = 2
    tensor = pk1
    factor = -1
  []
[]

[BCs]
  [current]
    type = FunctionNeumannBC
    variable = Phi
    boundary = &#x27;conductor_top&#x27;
    function = current_density
  []
  [Phi_ref]
    type = DirichletBC
    variable = Phi
    boundary = &#x27;conductor_bottom&#x27;
    value = 0
  []
  [hconv]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;outer&#x27;
    value = -1
    boundary_material = qconv
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;center piny&#x27;
    value = 0
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;center pinx&#x27;
    value = 0
  []
  [fix_z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;conductor_bottom air_bottom insulator_bottom jacket_bottom&#x27;
    value = 0
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;conductor ${sigma_con}&#x27;
    block = &#x27;conductor&#x27;
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
    block = &#x27;conductor&#x27;
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
    block = &#x27;conductor&#x27;
  []

  # Chemistry
  [mobility]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;M&#x27;
    subdomain_to_prop_value = &#x27;conductor ${M_con}&#x27;
    block = &#x27;conductor&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T
    reference_concentration = ${c_ref_ent}
    block = &#x27;conductor&#x27;
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
    block = &#x27;conductor&#x27;
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
    block = &#x27;conductor&#x27;
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
    block = &#x27;conductor&#x27;
  []

  # Migration
  [migration]
    type = Migration
    electrochemical_energy_density = m
    electric_potential = Phi
    chemical_potential = mu
    electric_conductivity = sigma
    faraday_constant = ${F}
    block = &#x27;conductor&#x27;
  []
  [migration_flux]
    type = MassFlux
    mass_flux = jm
    energy_densities = &#x27;m&#x27;
    chemical_potential = mu
    block = &#x27;conductor&#x27;
  []

  # Thermal
  [heat_conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;kappa&#x27;
    subdomain_to_prop_value = &#x27;conductor ${kappa_con} air ${kappa_air} insulator ${kappa_ins} jacket ${kappa_jac}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
  []
  [qconv]
    type = ADParsedMaterial
    f_name = qconv
    function = &#x27;htc*(T-T_inf)&#x27;
    args = &#x27;T&#x27;
    constant_names = &#x27;htc T_inf&#x27;
    constant_expressions = &#x27;${htc} ${T0}&#x27;
    boundary = &#x27;outer&#x27;
  []

  # Mechanics
  [youngs_modulus]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;lambda&#x27;
    subdomain_to_prop_value = &#x27;conductor ${fparse E_con*nu_con/(1+nu_con)/(1-2*nu_con)} air ${fparse E_air*nu_air/(1+nu_air)/(1-2*nu_air)} insulator ${fparse E_ins*nu_ins/(1+nu_ins)/(1-2*nu_ins)} jacket ${fparse E_jac*nu_jac/(1+nu_jac)/(1-2*nu_jac)}&#x27;
  []
  [poissons_ratio]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;G&#x27;
    subdomain_to_prop_value = &#x27;conductor ${fparse E_con/2/(1+nu_con)} air ${fparse E_air/2/(1+nu_air)} insulator ${fparse E_ins/2/(1+nu_ins)} jacket ${fparse E_jac/2/(1+nu_jac)}&#x27;
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = ${T0}
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [T_max]
    type = NodalExtremeValue
    variable = T
    block = &#x27;conductor&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options = &#x27;-ksp_converged_reason&#x27;
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  # petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_interp_type -pc_hypre_boomeramg_coarsen_type -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths -pc_hypre_boomeramg_truncfactor&#x27;
  # petsc_options_value = &#x27;hypre boomeramg 301 0.25 ext+i PMIS 4 2 0.4&#x27;
  automatic_scaling = true
  ignore_variables_for_autoscaling = &#x27;T c&#x27;
  verbose = true
  line_search = none

  l_max_its = 300
  l_tol = 1e-6
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-8
  nl_max_its = 12

  [Predictor]
    type = SimplePredictor
    scale = 1
  []
  [TimeStepper]
    type = FunctionDT
    function = &#x27;if(t&lt;100,10,100)&#x27;
  []
  end_time = 100
[]

[Outputs]
  exodus = true
  print_linear_residuals = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="edb5267d-6dc5-4cdf-9a83-8523da75fede"><div class="modal-content"><h4>(test/tests/electrical/mms.i)</h4><pre class="moose-pre"><code class="language-text">n = 32

[GlobalParams]
  energy_densities = &#x27;E&#x27;
[]

[Mesh]
  [battery]
    type = GeneratedMeshGenerator
    dim = 1
    xmin = 0
    xmax = 1
    nx = ${n}
  []
[]

[Variables]
  [Phi]
  []
[]

[Functions]
  [Phi]
    type = ParsedFunction
    expression = &#x27;3.565*exp(x)-4.71*x^2+7.1*x-3.4&#x27;
  []
  [sigma]
    type = ParsedFunction
    expression = &#x27;1+x&#x27;
  []
  [q]
    type = ParsedFunction
    expression = &#x27;2.32+exp(x)*(-7.13-3.565*x)+18.84*x&#x27;
  []
[]

[Kernels]
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  [charge]
    type = BodyForce
    variable = Phi
    function = q
  []
[]

[BCs]
  [fix]
    type = FunctionDirichletBC
    variable = Phi
    boundary = &#x27;left right&#x27;
    function = Phi
  []
[]

[Materials]
  [electric_constants]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;sigma&#x27;
    prop_values = &#x27;sigma&#x27;
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = E
    electric_potential = Phi
    electric_conductivity = sigma
  []
  [current]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
  []
[]

[Postprocessors]
  [error]
    type = ElementL2Error
    variable = Phi
    function = Phi
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true

  num_steps = 1
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="26626e2c-fa58-49bd-ba59-98d6eff8a222"><div class="modal-content"><h4>(examples/SSB_3D/CC_charging.i)</h4><pre class="moose-pre"><code class="language-text">I = 0.005 #mA
width = 0.05 #mm
in = &#x27;${fparse -I/width/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;

sigma_a = 0.2 #mS/mm
sigma_e = 0.1 #mS/mm
sigma_cp = 0.05 #mS/mm
sigma_ca = 0.2 #mS/mm
sigma_cm = 0.05 #mS/mm

Phi_penalty = 10

cmin_a = 1e-4 #mmol/mm^3
cmax_a = 1e-3 #mmol/mm^3
c_e = 5e-4 #mmol/mm^3
cmax_c = 1e-3 #mmol/mm^3
c_ref_entropy = 5e-5
D_cp = 5e-5 #mm^2/s
D_cm = 1e-4 #mm^2/s
D_a = 5e-4 #mm^2/s
D_e = 1e-4 #mm^2/s

c_penalty = 1

R = 8.3145 #mJ/mmol/K
T0 = 300 #K
F = 96485 #mC/mmol

i0_a = 1e-1 #mA/mm^2
i0_c = 1e-1 #mA/mm^2

E_cp = 6e4
E_cm = 5e4
E_e = 5e4
E_a = 1e5
nu_cp = 0.3
nu_cm = 0.25
nu_e = 0.25
nu_a = 0.3

u_penalty = 1e8

Omega = 140
beta = 1e-4
CTE = 1e-5

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s
htc = 9.5e-3

T_penalty = 1

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
  thermal_deformation_gradient = Ft
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  [battery]
    type = FileMeshGenerator
    file = &#x27;../coarse.e&#x27;
  []
  [scale]
    type = TransformGenerator
    input = battery
    transform = SCALE
    vector_value = &#x27;1e-3 1e-3 1e-3&#x27; #um to mm
  []
  [cathode_particle]
    type = RenameBlockGenerator
    input = scale
    old_block = &#x27;1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44&#x27;
    new_block = &#x27;cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp&#x27;
  []
  [cathode_matrix]
    type = RenameBlockGenerator
    input = cathode_particle
    old_block = &#x27;48&#x27;
    new_block = &#x27;cm&#x27;
  []
  [elyte]
    type = RenameBlockGenerator
    input = cathode_matrix
    old_block = 49
    new_block = &#x27;e&#x27;
  []
  [anode]
    type = RenameBlockGenerator
    input = elyte
    old_block = 50
    new_block = &#x27;a&#x27;
  []
  [interfaces]
    type = BreakMeshByBlockGenerator
    input = anode
    add_interface_on_two_sides = true
    split_interface = true
  []
  [sidesets]
    type = SideSetsFromNormalsGenerator
    input = interfaces
    normals = &#x27;-1 0 0 1 0 0 0 -1 0 0 1 0 0 0 -1 0 0 1&#x27;
    new_boundary = &#x27;left right bottom top back front&#x27;
  []
  use_displaced_mesh = false
[]

[Variables]
  [Phi_ca]
    block = cm
  []
  [Phi]
  []
  [c]
  []
  [disp_x]
  []
  [disp_y]
  []
  [disp_z]
  []
  [T]
    initial_condition = ${T0}
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
  [stress]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = pk1
      scalar_type = Hydrostatic
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Js]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = Fs
      scalar_type = ThirdInvariant
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Jt]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = Ft
      scalar_type = ThirdInvariant
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Phi0]
  []
[]

[ICs]
  [c_a]
    type = ConstantIC
    variable = c
    value = ${cmin_a}
    block = &#x27;a&#x27;
  []
  [c_e]
    type = ConstantIC
    variable = c
    value = ${c_e}
    block = &#x27;cm e&#x27;
  []
  [c_c]
    type = ConstantIC
    variable = c
    value = ${cmax_c}
    block = &#x27;cp&#x27;
  []
  [c_ref_a]
    type = ConstantIC
    variable = c_ref
    value = ${cmin_a}
    block = &#x27;a&#x27;
  []
  [c_ref_e]
    type = ConstantIC
    variable = c_ref
    value = ${c_e}
    block = &#x27;cm e&#x27;
  []
  [c_ref_c]
    type = ConstantIC
    variable = c_ref
    value = ${cmax_c}
    block = &#x27;cp&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  [charge_balance_ca]
    type = RankOneDivergence
    variable = Phi_ca
    vector = i_ca
    block = cm
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
  [momentum_balance_z]
    type = RankTwoDivergence
    variable = disp_z
    component = 2
    tensor = pk1
    factor = -1
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [negative_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = 1
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    boundary = &#x27;a_e cm_cp e_a cp_cm&#x27;
  []
  [continuity_c]
    type = InterfaceContinuity
    variable = c
    neighbor_var = c
    penalty = ${c_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_Phi_ca]
    type = InterfaceContinuity
    variable = Phi_ca
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_cp&#x27;
  []
  [continuity_Phi]
    type = InterfaceContinuity
    variable = Phi
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_disp_x]
    type = InterfaceContinuity
    variable = disp_x
    neighbor_var = disp_x
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_disp_y]
    type = InterfaceContinuity
    variable = disp_y
    neighbor_var = disp_y
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_disp_z]
    type = InterfaceContinuity
    variable = disp_z
    neighbor_var = disp_z
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${in}&#x27;
  []
[]

[BCs]
  [current]
    type = FunctionNeumannBC
    variable = Phi
    boundary = right
    function = in
  []
  [potential]
    type = DirichletBC
    variable = Phi_ca
    boundary = left
    value = 0
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  []
  [fix_z]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back&#x27;
  []
  [hconv]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;left right&#x27;
    value = -1
    boundary_material = qconv
  []
[]

[Constraints]
  [ev_y]
    type = EqualValueBoundaryConstraint
    variable = disp_y
    penalty = ${u_penalty}
    secondary = top
  []
  [ev_z]
    type = EqualValueBoundaryConstraint
    variable = disp_z
    penalty = ${u_penalty}
    secondary = front
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;a ${sigma_a} e ${sigma_e} cm ${sigma_cm} cp ${sigma_cp}&#x27;
  []
  [conductivity_ca]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma_ca&#x27;
    subdomain_to_prop_value = &#x27;cm ${sigma_ca}&#x27;
    block = cm
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [charge_transport_ca]
    type = BulkChargeTransport
    electrical_energy_density = q_ca
    electric_potential = Phi_ca
    electric_conductivity = sigma_ca
    temperature = T
    block = cm
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
    output_properties = i
    outputs = exodus
  []
  [current_density_ca]
    type = CurrentDensity
    current_density = i_ca
    electric_potential = Phi_ca
    output_properties = i_ca
    outputs = exodus
    block = cm
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;D&#x27;
    subdomain_to_prop_value = &#x27;a ${D_a} e ${D_e} cm ${D_cm} cp ${D_cp}&#x27;
  []
  [mobility]
    type = ADParsedMaterial
    f_name = M
    args = &#x27;c_ref T_ref&#x27;
    material_property_names = &#x27;D&#x27;
    function = &#x27;D*c_ref/${R}/T_ref&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T_ref
    reference_concentration = ${c_ref_entropy}
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
    energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta m&#x27;
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
    outputs = exodus
  []

  # Redox
  [ramp]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;ramp&#x27;
    prop_values = &#x27;if(t&lt;${t0},t/${t0},1)&#x27;
  []
  [OCP_anode_graphite]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_a}; 2.77e-4*x^2-0.0069*x+0.0785&#x27;
    # function = &#x27;x:=c/${cmax_a}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;a&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_c}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;cp&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;a_e&#x27;
  []
  [charge_transfer_elyte_anode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;e_a&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cp_cm&#x27;
  []
  [charge_transfer_elyte_cathode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cm_cp&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
    output_properties = h
    outputs = exodus
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
    output_properties = r
    outputs = exodus
  []
  [conv]
    type = ADParsedMaterial
    f_name = qconv
    function = &#x27;${htc}*(T-T_ref)&#x27;
    args = &#x27;T T_ref&#x27;
    boundary = &#x27;left right&#x27;
  []

  # Mechanical
  [stiffness_cp]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cp*nu_cp/(1+nu_cp)/(1-2*nu_cp)} ${fparse E_cp/2/(1+nu_cp)}&#x27;
    block = cp
  []
  [stiffness_cm]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cm*nu_cm/(1+nu_cm)/(1-2*nu_cm)} ${fparse E_cm/2/(1+nu_cm)}&#x27;
    block = cm
  []
  [stiffness_e]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_e*nu_e/(1+nu_e)/(1-2*nu_e)} ${fparse E_e/2/(1+nu_e)}&#x27;
    block = e
  []
  [stiffness_a]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_a*nu_a/(1+nu_a)/(1-2*nu_a)} ${fparse E_a/2/(1+nu_a)}&#x27;
    block = a
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;beta&#x27;
    prop_values = &#x27;${beta}&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = T_ref
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
    non_swelling_pressure = p
    output_properties = &#x27;p&#x27;
    outputs = exodus
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi_ca
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_l - V_r&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [I]
    type = ADSideIntegralMaterialProperty
    property = i
    component = 0
    boundary = right
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;dt*I&#x27;
    pp_names = &#x27;dt I&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[UserObjects]
  [kill_V]
    type = Terminator
    expression = &#x27;V &gt;= 4.6&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options = &#x27;-ksp_converged_reason&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_interp_type -pc_hypre_boomeramg_coarsen_type -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths -pc_hypre_boomeramg_truncfactor&#x27;
  petsc_options_value = &#x27;hypre boomeramg 301 0.7 ext+i PMIS 4 2 0.4&#x27;
  automatic_scaling = true
  ignore_variables_for_autoscaling = &#x27;T&#x27;
  verbose = true
  line_search = none

  l_max_its = 300
  l_tol = 1e-6
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-9
  nl_max_its = 12

  [Predictor]
    type = SimplePredictor
    scale = 1
  []
  [TimeStepper]
    type = IterationAdaptiveDT
    dt = &#x27;${fparse t0/50}&#x27;
    optimal_iterations = 6
    iteration_window = 1
    growth_factor = 1.2
    cutback_factor = 0.2
    cutback_factor_at_failure = 0.1
    linear_iteration_ratio = 100
  []
  end_time = 10000
[]

[Outputs]
  file_base = &#x27;${outname}_CC_charging&#x27;
  exodus = true
  csv = true
  print_linear_residuals = false
  checkpoint = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#c0e59d33-4525-4fcd-98ab-baba331b6b2c" class="tooltipped" data-position="left" data-tooltip="Overview">Overview</a></li><li><a href="#a2c4d853-c596-4340-b0dd-f4f3001839d3" class="tooltipped" data-position="left" data-tooltip="Example Input File Syntax">Example Input File Syntax</a></li><li><a href="#72695fcd-b115-48f6-89c8-4dff03bf9fee" class="tooltipped" data-position="left" data-tooltip="Input Parameters">Input Parameters</a></li><li><a href="#2b0603d0-871e-435c-81ac-7a3c246bf7ee" class="tooltipped" data-position="left" data-tooltip="Input Files">Input Files</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>