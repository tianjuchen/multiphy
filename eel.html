<!DOCTYPE html><head><meta charset="UTF-8"><title>Syntax | Eel</title><link href="contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="css/moose.css" type="text/css" rel="stylesheet"></link><link href="css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="css/katex_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Eel</a><a href="https://github.com/hugary1995/eel" class="right"><img src="media/framework/github-logo.png" class="github-mark"></img><img src="media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="eel.html">Documentation</a></li></ul><a href="#" class="sidenav-trigger" data-target="3b2c1797-6765-4496-93df-2000f9a398ba"><i class="material-icons">menu</i></a><ul class="sidenav" id="3b2c1797-6765-4496-93df-2000f9a398ba"><li><a href="eel.html">Documentation</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href="#" class="breadcrumb">eel</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="d7340811-862a-4f97-831e-27a5ae3bccb7" data-section-level="1" data-section-text="Syntax"><h1 id="syntax">Syntax</h1><section class="scrollspy" id="ed959f78-9210-4aa9-a8c4-1d811acd8351" data-section-level="2" data-section-text="The Eel syntax"><h2 id="the-eel-syntax">The Eel syntax</h2></section><section class="scrollspy" id="8c5ca366-098f-4b20-b14f-fd22c9a414aa" data-section-level="2" data-section-text="BCs"><h2 id="bcs"><a href="syntax/BCs/index.html">BCs</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Eel App</li><li class="collection-item"><a href="source/bcs/CoupledVarDirichletBC.html">CoupledVarDirichletBC</a>Imposes the essential boundary condition <span class="moose-katex-inline-equation" id="moose-equation-51229dc8-fad8-4e1d-861f-c867cd9c75cc"><script>var element = document.getElementById("moose-equation-51229dc8-fad8-4e1d-861f-c867cd9c75cc");katex.render("u=g", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span></li><li class="collection-item"><a href="source/bcs/OpenBC.html">OpenBC</a>An open BC where matters can freely flow in and out.</li></ul></section><section class="scrollspy" id="e354e966-8799-4b8b-9870-807832efcad7" data-section-level="2" data-section-text="FunctorMaterials"><h2 id="functormaterials"><a href="syntax/FunctorMaterials/index.html">FunctorMaterials</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Eel App</li><li class="collection-item"><a href="source/materials/electrodynamics/BulkChargeTransport.html">BulkChargeTransport</a>This class computes the electrical energy density and its corresponding thermodynamic forces. We assume the electrical energy density depends on at least the deformation gradient and the gradient of electrical potential This class defines the electrical potential for charge transfer in the bulk</li><li class="collection-item"><a href="source/materials/forces/CauchyStress.html">CauchyStress</a>This class computes the Cauchy stress given the PK1 stress</li><li class="collection-item"><a href="source/materials/electrodynamics/ChargeTransferReaction.html">ChargeTransferReaction</a>The Butler-Volmer condition for current density across the electrode/electrolyte interface.</li><li class="collection-item"><a href="source/materials/chemistry/ChemicalPotential.html">ChemicalPotential</a>This class defines the mass flux.</li><li class="collection-item"><a href="source/materials/forces/CurrentDensity.html">CurrentDensity</a>This class computes the current density associated with given energy densities.</li><li class="collection-item"><a href="source/materials/kinematics/DeformationGradient.html">DeformationGradient</a>This class computes the deformation gradient. The F-bar approach can optionally be used to correct volumetric locking.</li><li class="collection-item"><a href="source/materials/chemistry/EntropicChemicalEnergyDensity.html">EntropicChemicalEnergyDensity</a>This class computes the chemical energy density and its corresponding thermodynamic forces. We assume the chemical energy density depends on the chemical concentration.</li><li class="collection-item"><a href="source/materials/forces/FirstPiolaKirchhoffStress.html">FirstPiolaKirchhoffStress</a>This class computes the first Piola-Kirchhoff stress associated with given energy densities.</li><li class="collection-item"><a href="source/materials/thermology/FourierPotential.html">FourierPotential</a>This class computes the thermal energy density and its corresponding thermodynamic forces. We assume the thermal energy density depends on the gradient of log temperature. This class defines the Fourier potential for heat conduction.</li><li class="collection-item"><a href="source/materials/forces/HeatFlux.html">HeatFlux</a>This class computes the heat flux associated with given energy densities for a given species.</li><li class="collection-item"><a href="source/materials/mechanics/InterfaceTractionWithCreepDegradation.html">InterfaceTractionWithCreepDegradation</a>Base class for implementing cohesive zone constituive material models that can be formulated using the total displacement jump</li><li class="collection-item"><a href="source/materials/electrodynamics/JouleHeating.html">JouleHeating</a>This class computes volumetric heat source due to Joule heating from electric displacement.</li><li class="collection-item"><a href="source/materials/chemistry/MassDiffusion.html">MassDiffusion</a>This class computes the dual chemical energy density and its corresponding thermodynamic forces. We assume the dual chemical energy density depends on the gradient of chemical potential.</li><li class="collection-item"><a href="source/materials/forces/MassFlux.html">MassFlux</a>This class computes the mass flux associated with given energy densities for a given species.</li><li class="collection-item"><a href="source/materials/forces/MassSource.html">MassSource</a>This class computes the mass source associated with given energy densities for a given species.</li><li class="collection-item"><a href="source/materials/kinematics/MechanicalDeformationGradient.html">MechanicalDeformationGradient</a>This class computes the deformation gradient. The F-bar approach can optionally be used to correct volumetric locking. Eigen deformation gradients are extracted from the total deformation gradient.</li><li class="collection-item"><a href="source/materials/kinematics/MechanicalStrain.html">MechanicalStrain</a>Compute mechanical strain by subtracting eigenstrains from the total strain</li><li class="collection-item"><a href="source/materials/electrochemistry/Migration.html">Migration</a>This class computes the electrochemical energy density and its corresponding thermodynamic forces. We assume the electrochemical energy density depends on the gradients of electrical potential and chemical potential This class defines the electrochemical potential for the migration mechanism</li><li class="collection-item"><a href="source/materials/mechanics/NeoHookeanSolid.html">NeoHookeanSolid</a>This class computes the elastic energy density and its corresponding thermodynamic forces. We assume the mechanical energy density depends on the mechanical deformation gradient. This class defines the Neo-Hookean elastic energy density.</li><li class="collection-item"><a href="source/materials/mechanics/SDElasticEnergyDensity.html">SDElasticEnergyDensity</a>This class defines the small deformation elastic energy density.</li><li class="collection-item"><a href="source/materials/forces/SDStress.html">SDStress</a>This class computes the small deformation Cauchy stress associated with given energy densities.</li><li class="collection-item"><a href="source/materials/chemistry/SEIGrowth.html">SEIGrowth</a>This object models the growth of solid electrolyte interphase (SEI).</li><li class="collection-item"><a href="source/materials/kinematics/Strain.html">Strain</a>This class computes the total strain. The F-bar approach can optionally be used to correct volumetric locking.</li><li class="collection-item"><a href="source/materials/kinematics/SwellingDeformationGradient.html">SwellingDeformationGradient</a>This class computes the eigen deformation gradient due to swelling.</li><li class="collection-item"><a href="source/materials/kinematics/SwellingStrain.html">SwellingStrain</a>This class computes the eigenstrain due to swelling.</li><li class="collection-item"><a href="source/materials/kinematics/ThermalDeformationGradient.html">ThermalDeformationGradient</a>This class computes the thermal deformation gradient.</li><li class="collection-item"><a href="source/materials/forces/VariationalHeatSource.html">VariationalHeatSource</a>This class computes the heat source associated with given energy densities for a given species.</li><li class="collection-item"><a href="source/materials/mechanics/WeldedInterfaceTraction.html">WeldedInterfaceTraction</a>Base class for implementing cohesive zone constituive material models that can be formulated using the total displacement jump</li></ul></section><section class="scrollspy" id="b001c97e-7e24-40ee-a320-97fef005dff9" data-section-level="2" data-section-text="InterfaceKernels"><h2 id="interfacekernels"><a href="syntax/InterfaceKernels/index.html">InterfaceKernels</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Eel App</li><li class="collection-item"><a href="source/interfacekernels/InterfaceContinuity.html">InterfaceContinuity</a>Enforcing continuity across an interface</li><li class="collection-item"><a href="source/interfacekernels/InterfaceCoupledVarContinuity.html">InterfaceCoupledVarContinuity</a>Enforcing continuity of a coupled var across an interface</li><li class="collection-item"><a href="source/interfacekernels/MaterialInterfaceNeumannBC.html">MaterialInterfaceNeumannBC</a>Applies a Neumann BC on both sides of the interface. The value of the Neumann BC is specified by a material property.</li></ul></section><section class="scrollspy" id="3aa94de6-66cc-49c4-b2a4-f1007d6f391e" data-section-level="2" data-section-text="Kernels"><h2 id="kernels"><a href="syntax/Kernels/index.html">Kernels</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Eel App</li><li class="collection-item"><a href="source/kernels/EnergyBalanceTimeDerivative.html">EnergyBalanceTimeDerivative</a>Time derivative term <span class="moose-katex-inline-equation" id="moose-equation-b2567a52-f4c9-416e-9cea-872ba10305d3"><script>var element = document.getElementById("moose-equation-b2567a52-f4c9-416e-9cea-872ba10305d3");katex.render("\\rho c_p \\frac{\\partial T}{\\partial t}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> of the heat equation.</li><li class="collection-item"><a href="source/kernels/MaterialSource.html">MaterialSource</a>Source term defined by the material property</li><li class="collection-item"><a href="source/kernels/PrimalDualProjection.html">PrimalDualProjection</a>Projecting a primal variable onto a dual variable</li><li class="collection-item"><a href="source/kernels/RankOneDivergence.html">RankOneDivergence</a>This class implements the weak form for the divergence of a vector.</li><li class="collection-item"><a href="source/kernels/RankTwoDivergence.html">RankTwoDivergence</a>This class implements the weak form for the divergence of a second order tensor</li></ul></section><section class="scrollspy" id="f735fcb1-8b79-44f6-bc86-7aec21998f57" data-section-level="2" data-section-text="Materials"><h2 id="materials"><a href="syntax/Materials/index.html">Materials</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Eel App</li><li class="collection-item"><a href="source/materials/electrodynamics/BulkChargeTransport.html">BulkChargeTransport</a>This class computes the electrical energy density and its corresponding thermodynamic forces. We assume the electrical energy density depends on at least the deformation gradient and the gradient of electrical potential This class defines the electrical potential for charge transfer in the bulk</li><li class="collection-item"><a href="source/materials/forces/CauchyStress.html">CauchyStress</a>This class computes the Cauchy stress given the PK1 stress</li><li class="collection-item"><a href="source/materials/electrodynamics/ChargeTransferReaction.html">ChargeTransferReaction</a>The Butler-Volmer condition for current density across the electrode/electrolyte interface.</li><li class="collection-item"><a href="source/materials/chemistry/ChemicalPotential.html">ChemicalPotential</a>This class defines the mass flux.</li><li class="collection-item"><a href="source/materials/forces/CurrentDensity.html">CurrentDensity</a>This class computes the current density associated with given energy densities.</li><li class="collection-item"><a href="source/materials/kinematics/DeformationGradient.html">DeformationGradient</a>This class computes the deformation gradient. The F-bar approach can optionally be used to correct volumetric locking.</li><li class="collection-item"><a href="source/materials/chemistry/EntropicChemicalEnergyDensity.html">EntropicChemicalEnergyDensity</a>This class computes the chemical energy density and its corresponding thermodynamic forces. We assume the chemical energy density depends on the chemical concentration.</li><li class="collection-item"><a href="source/materials/forces/FirstPiolaKirchhoffStress.html">FirstPiolaKirchhoffStress</a>This class computes the first Piola-Kirchhoff stress associated with given energy densities.</li><li class="collection-item"><a href="source/materials/thermology/FourierPotential.html">FourierPotential</a>This class computes the thermal energy density and its corresponding thermodynamic forces. We assume the thermal energy density depends on the gradient of log temperature. This class defines the Fourier potential for heat conduction.</li><li class="collection-item"><a href="source/materials/forces/HeatFlux.html">HeatFlux</a>This class computes the heat flux associated with given energy densities for a given species.</li><li class="collection-item"><a href="source/materials/mechanics/InterfaceTractionWithCreepDegradation.html">InterfaceTractionWithCreepDegradation</a>Base class for implementing cohesive zone constituive material models that can be formulated using the total displacement jump</li><li class="collection-item"><a href="source/materials/electrodynamics/JouleHeating.html">JouleHeating</a>This class computes volumetric heat source due to Joule heating from electric displacement.</li><li class="collection-item"><a href="source/materials/chemistry/MassDiffusion.html">MassDiffusion</a>This class computes the dual chemical energy density and its corresponding thermodynamic forces. We assume the dual chemical energy density depends on the gradient of chemical potential.</li><li class="collection-item"><a href="source/materials/forces/MassFlux.html">MassFlux</a>This class computes the mass flux associated with given energy densities for a given species.</li><li class="collection-item"><a href="source/materials/forces/MassSource.html">MassSource</a>This class computes the mass source associated with given energy densities for a given species.</li><li class="collection-item"><a href="source/materials/kinematics/MechanicalDeformationGradient.html">MechanicalDeformationGradient</a>This class computes the deformation gradient. The F-bar approach can optionally be used to correct volumetric locking. Eigen deformation gradients are extracted from the total deformation gradient.</li><li class="collection-item"><a href="source/materials/kinematics/MechanicalStrain.html">MechanicalStrain</a>Compute mechanical strain by subtracting eigenstrains from the total strain</li><li class="collection-item"><a href="source/materials/electrochemistry/Migration.html">Migration</a>This class computes the electrochemical energy density and its corresponding thermodynamic forces. We assume the electrochemical energy density depends on the gradients of electrical potential and chemical potential This class defines the electrochemical potential for the migration mechanism</li><li class="collection-item"><a href="source/materials/mechanics/NeoHookeanSolid.html">NeoHookeanSolid</a>This class computes the elastic energy density and its corresponding thermodynamic forces. We assume the mechanical energy density depends on the mechanical deformation gradient. This class defines the Neo-Hookean elastic energy density.</li><li class="collection-item"><a href="source/materials/mechanics/SDElasticEnergyDensity.html">SDElasticEnergyDensity</a>This class defines the small deformation elastic energy density.</li><li class="collection-item"><a href="source/materials/forces/SDStress.html">SDStress</a>This class computes the small deformation Cauchy stress associated with given energy densities.</li><li class="collection-item"><a href="source/materials/chemistry/SEIGrowth.html">SEIGrowth</a>This object models the growth of solid electrolyte interphase (SEI).</li><li class="collection-item"><a href="source/materials/kinematics/Strain.html">Strain</a>This class computes the total strain. The F-bar approach can optionally be used to correct volumetric locking.</li><li class="collection-item"><a href="source/materials/kinematics/SwellingDeformationGradient.html">SwellingDeformationGradient</a>This class computes the eigen deformation gradient due to swelling.</li><li class="collection-item"><a href="source/materials/kinematics/SwellingStrain.html">SwellingStrain</a>This class computes the eigenstrain due to swelling.</li><li class="collection-item"><a href="source/materials/kinematics/ThermalDeformationGradient.html">ThermalDeformationGradient</a>This class computes the thermal deformation gradient.</li><li class="collection-item"><a href="source/materials/forces/VariationalHeatSource.html">VariationalHeatSource</a>This class computes the heat source associated with given energy densities for a given species.</li><li class="collection-item"><a href="source/materials/mechanics/WeldedInterfaceTraction.html">WeldedInterfaceTraction</a>Base class for implementing cohesive zone constituive material models that can be formulated using the total displacement jump</li></ul></section><section class="scrollspy" id="78cc7aab-e122-46eb-86f7-cd938e9045c5" data-section-level="2" data-section-text="The complete list of syntax"><h2 id="the-complete-list-of-syntax">The complete list of syntax</h2></section><section class="scrollspy" id="de3a9a8f-67a2-4230-b202-9a7ebb6e90dd" data-section-level="2" data-section-text="Adaptivity"><h2 id="adaptivity"><a href="syntax/Adaptivity/index.html">Adaptivity</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/SetAdaptivityOptionsAction.html">SetAdaptivityOptionsAction</a>Action for defining adaptivity parameters.</li><li class="collection-item"><a href="syntax/Adaptivity/Indicators/index.html">Indicators</a></li><li class="collection-item"><a href="syntax/Adaptivity/Markers/index.html">Markers</a></li></ul><section id="cbedb4b0-1161-4983-814e-64e5c17ed2c6" data-section-level="3" data-section-text="Adaptivity/Indicators"><h3 id="adaptivity/indicators"><a href="syntax/Adaptivity/Indicators/index.html">Adaptivity/Indicators</a></h3><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddElementalFieldAction.html">AddElementalFieldAction</a>Adds elemental auxiliary variable for adaptivity system.</li><li class="collection-item"><a href="source/actions/AddIndicatorAction.html">AddIndicatorAction</a>Add an Indicator object to a simulation.</li><li class="collection-item"><a href="source/indicators/AnalyticalIndicator.html">AnalyticalIndicator</a>Compute the square of the error as the difference between an unknown variable and an analytical solution.</li><li class="collection-item"><a href="source/variables/ArrayMooseVariable.html">ArrayMooseVariable</a>Used for grouping standard field variables with the same finite element family and order</li><li class="collection-item"><a href="source/indicators/GradientJumpIndicator.html">GradientJumpIndicator</a>Compute the jump of the solution gradient across element boundaries.</li><li class="collection-item"><a href="source/indicators/LaplacianJumpIndicator.html">LaplacianJumpIndicator</a>Compute the jump of the solution laplacian across element bondaries.</li><li class="collection-item"><a href="source/variables/MooseVariable.html">MooseVariable</a>Represents standard field variables, e.g. Lagrange, Hermite, or non-constant Monomials</li><li class="collection-item"><a href="source/variables/MooseVariableBase.html">MooseVariableBase</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/MooseVariableConstMonomial.html">MooseVariableConstMonomial</a>Specialization for constant monomials that avoids unnecessary loops</li><li class="collection-item"><a href="source/variables/MooseVariableFV.html">MooseVariableFVReal</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/MooseVariableScalar.html">MooseVariableScalar</a>Moose wrapper class around scalar variables</li><li class="collection-item"><a href="source/indicators/ValueJumpIndicator.html">ValueJumpIndicator</a>Compute the jump of the solution across element bondaries.</li><li class="collection-item"><a href="source/variables/VectorMooseVariable.html">VectorMooseVariable</a>Represents vector field variables, e.g. Vector Lagrange or Nedelec</li><li class="collection-header">Navier Stokes App</li><li class="collection-item"><a href="source/variables/BernoulliPressureVariable.html">BernoulliPressureVariable</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/INSFVEnergyVariable.html">INSFVEnergyVariable</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/INSFVPressureVariable.html">INSFVPressureVariable</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/INSFVScalarFieldVariable.html">INSFVScalarFieldVariable</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/INSFVVelocityVariable.html">INSFVVelocityVariable</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/PINSFVSuperficialVelocityVariable.html">PINSFVSuperficialVelocityVariable</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/PiecewiseConstantVariable.html">PiecewiseConstantVariable</a>Base class for Moose variables. This should never be the terminal object type</li></ul></section><section id="05f73800-f95d-485c-a462-2b4a41c180f6" data-section-level="3" data-section-text="Adaptivity/Markers"><h3 id="adaptivity/markers"><a href="syntax/Adaptivity/Markers/index.html">Adaptivity/Markers</a></h3><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddElementalFieldAction.html">AddElementalFieldAction</a>Adds elemental auxiliary variable for adaptivity system.</li><li class="collection-item"><a href="source/actions/AddMarkerAction.html">AddMarkerAction</a>Add a Marker object to a simulation.</li><li class="collection-item"><a href="source/variables/ArrayMooseVariable.html">ArrayMooseVariable</a>Used for grouping standard field variables with the same finite element family and order</li><li class="collection-item"><a href="source/markers/BoundaryMarker.html">BoundaryMarker</a>Marks all elements with sides on a given boundary for refinement/coarsening</li><li class="collection-item"><a href="source/markers/BoundaryPreservedMarker.html">BoundaryPreservedMarker</a>Marks elements for refinement or coarsening based on the provided marker value, while preserving the given boundary.</li><li class="collection-item"><a href="source/markers/BoxMarker.html">BoxMarker</a>Marks the region inside and outside of a &#x27;box&#x27; domain for refinement or coarsening.</li><li class="collection-item"><a href="source/markers/ComboMarker.html">ComboMarker</a>A marker that converts many markers into a single marker by considering the maximum value of the listed markers (i.e., refinement takes precedent).</li><li class="collection-item"><a href="source/markers/ErrorFractionMarker.html">ErrorFractionMarker</a>Marks elements for refinement or coarsening based on the fraction of the min/max error from the supplied indicator.</li><li class="collection-item"><a href="source/markers/ErrorToleranceMarker.html">ErrorToleranceMarker</a>Coarsen or refine elements based on an absolute tolerance allowed from the supplied indicator.</li><li class="collection-item"><a href="source/variables/MooseVariable.html">MooseVariable</a>Represents standard field variables, e.g. Lagrange, Hermite, or non-constant Monomials</li><li class="collection-item"><a href="source/variables/MooseVariableBase.html">MooseVariableBase</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/MooseVariableConstMonomial.html">MooseVariableConstMonomial</a>Specialization for constant monomials that avoids unnecessary loops</li><li class="collection-item"><a href="source/variables/MooseVariableFV.html">MooseVariableFVReal</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/MooseVariableScalar.html">MooseVariableScalar</a>Moose wrapper class around scalar variables</li><li class="collection-item"><a href="source/markers/OrientedBoxMarker.html">OrientedBoxMarker</a>Marks inside and outside a box that can have arbitrary orientation and center point.</li><li class="collection-item"><a href="source/markers/ReporterPointMarker.html">ReporterPointMarker</a>Marks the region inside or empty if it contains a reporter defined point for refinement or coarsening.</li><li class="collection-item"><a href="source/markers/UniformMarker.html">UniformMarker</a>Uniformly mark all elements for refinement or coarsening.</li><li class="collection-item"><a href="source/markers/ValueRangeMarker.html">ValueRangeMarker</a>Mark elements for adaptivity based on the supplied upper and lower bounds and the specified variable.</li><li class="collection-item"><a href="source/markers/ValueThresholdMarker.html">ValueThresholdMarker</a>The refinement state based on a threshold value compared to the specified variable.</li><li class="collection-item"><a href="source/variables/VectorMooseVariable.html">VectorMooseVariable</a>Represents vector field variables, e.g. Vector Lagrange or Nedelec</li><li class="collection-header">Navier Stokes App</li><li class="collection-item"><a href="source/variables/BernoulliPressureVariable.html">BernoulliPressureVariable</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/INSFVEnergyVariable.html">INSFVEnergyVariable</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/INSFVPressureVariable.html">INSFVPressureVariable</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/INSFVScalarFieldVariable.html">INSFVScalarFieldVariable</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/INSFVVelocityVariable.html">INSFVVelocityVariable</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/PINSFVSuperficialVelocityVariable.html">PINSFVSuperficialVelocityVariable</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/PiecewiseConstantVariable.html">PiecewiseConstantVariable</a>Base class for Moose variables. This should never be the terminal object type</li></ul></section></section><section class="scrollspy" id="bd02fc45-603c-4984-8408-3c2412388a27" data-section-level="2" data-section-text="AuxKernels"><h2 id="auxkernels"><a href="syntax/AuxKernels/index.html">AuxKernels</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddKernelAction.html">AddKernelAction</a>Add a Kernel object to the simulation.</li><li class="collection-item"><a href="source/auxkernels/DivergenceAux.html">ADDivergenceAux</a>Computes the divergence of a vector of functors.</li><li class="collection-item"><a href="source/auxkernels/FunctorElementalAux.html">ADFunctorElementalAux</a>Evaluates a functor (variable, function or functor material property) on the current element or quadrature point.</li><li class="collection-item"><a href="source/auxkernels/FunctorElementalGradientAux.html">ADFunctorElementalGradientAux</a>Evaluates the gradient of a functor (variable, function or functor material property) on the current element or quadrature point.</li><li class="collection-item"><a href="source/auxkernels/FunctorVectorElementalAux.html">ADFunctorVectorElementalAux</a>Evaluates a vector functor (material property usually) on the current element.For finite volume, this evaluates the vector functor at the centroid.</li><li class="collection-item"><a href="source/auxkernels/MaterialRankTwoTensorAux.html">ADMaterialRankTwoTensorAux</a>Access a component of a RankTwoTensor for automatic material property output</li><li class="collection-item"><a href="source/auxkernels/MaterialRateRealAux.html">ADMaterialRateRealAux</a>Outputs element material properties rate of change</li><li class="collection-item"><a href="source/auxkernels/MaterialRealAux.html">ADMaterialRealAux</a>Outputs element volume-averaged material properties</li><li class="collection-item"><a href="source/auxkernels/MaterialRealVectorValueAux.html">ADMaterialRealVectorValueAux</a>Capture a component of a vector material property in an auxiliary variable.</li><li class="collection-item"><a href="source/auxkernels/MaterialStdVectorAux.html">ADMaterialStdVectorAux</a>Extracts a component of a material type std::vector&lt;Real&gt; to an aux variable.  If the std::vector is not of sufficient size then zero is returned</li><li class="collection-item"><a href="source/auxkernels/VectorMaterialRealVectorValueAux.html">ADVectorMaterialRealVectorValueAux</a>Converts a vector-quantity material property into a vector auxiliary variable</li><li class="collection-item"><a href="source/auxkernels/ArrayParsedAux.html">ArrayParsedAux</a>Sets field array variable values to the evaluation of a parsed expression.</li><li class="collection-item"><a href="source/auxkernels/ArrayVarReductionAux.html">ArrayVarReductionAux</a>Takes an array variable and performs a reduction operation on it (max, min, sum, average) and stores as a standard variable.</li><li class="collection-item"><a href="source/auxkernels/ArrayVariableComponent.html">ArrayVariableComponent</a>Copy a component of an array variable.</li><li class="collection-item"><a href="source/auxkernels/BuildArrayVariableAux.html">BuildArrayVariableAux</a>Combines multiple standard variables into an array variable.</li><li class="collection-item"><a href="source/auxkernels/ConstantAux.html">ConstantAux</a>Creates a constant field in the domain.</li><li class="collection-item"><a href="source/auxkernels/ConstantBoundsAux.html">ConstantBoundsAux</a>Provides constant bound of a variable for the PETSc&#x27;s variational inequalities solver</li><li class="collection-item"><a href="source/auxkernels/ContainsPointAux.html">ContainsPointAux</a>Computes a binary field where the field is 1 in the elements that contain the point  and 0 everywhere else</li><li class="collection-item"><a href="source/auxkernels/CopyValueAux.html">CopyValueAux</a>Returns the specified variable as an auxiliary variable with a simple copy of the variable values.</li><li class="collection-item"><a href="source/auxkernels/DebugResidualAux.html">DebugResidualAux</a>Populate an auxiliary variable with the residual contribution of a variable.</li><li class="collection-item"><a href="source/auxkernels/DiffusionFluxAux.html">DiffusionFluxAux</a>Compute components of flux vector for diffusion problems <span class="moose-katex-inline-equation" id="moose-equation-75d60fd6-61d4-4c56-8d3c-be28a8db63a2"><script>var element = document.getElementById("moose-equation-75d60fd6-61d4-4c56-8d3c-be28a8db63a2");katex.render("(\\vec{J} = -D \\nabla C)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/auxkernels/DivergenceAux.html">DivergenceAux</a>Computes the divergence of a vector of functors.</li><li class="collection-item"><a href="source/auxkernels/ExtraElementIDAux.html">ElemExtraIDAux</a>Puts element extra IDs into an aux variable.</li><li class="collection-item"><a href="source/auxkernels/ElementH1ErrorFunctionAux.html">ElementH1ErrorFunctionAux</a>Computes the H1 or W^{1,p} error between an exact function and a coupled variable.</li><li class="collection-item"><a href="source/auxkernels/ElementIntegerAux.html">ElementIntegerAux</a>Creates a field showing the element integer.</li><li class="collection-item"><a href="source/auxkernels/ElementL2ErrorFunctionAux.html">ElementL2ErrorFunctionAux</a>A class for computing the element-wise L^2 (Euclidean) error between a function and a coupled variable.</li><li class="collection-item"><a href="source/auxkernels/ElementLengthAux.html">ElementLengthAux</a>Compute the element size using Elem::hmin() or Elem::hmax() from libMesh.</li><li class="collection-item"><a href="source/auxkernels/ElementLpNormAux.html">ElementLpNormAux</a>Compute an elemental field variable (single value per element) equal to the Lp-norm of a coupled Variable.</li><li class="collection-item"><a href="source/auxkernels/ElementQualityAux.html">ElementQualityAux</a>Generates a field containing the quality metric for each element.  Useful for visualizing mesh quality.</li><li class="collection-item"><a href="source/auxkernels/ElementUOAux.html">ElementUOAux</a>Aux Kernel to display generic spatial (elemental) information from a UserObject that satisfies the underlying ElementUOProvider interface.</li><li class="collection-item"><a href="source/auxkernels/ExtraElementIDAux.html">ExtraElementIDAux</a>Puts element extra IDs into an aux variable.</li><li class="collection-item"><a href="source/auxkernels/ForcingFunctionAux.html">ForcingFunctionAux</a>Auxiliary Kernel that adds a forcing function to the value of an AuxVariable from the previous time step.</li><li class="collection-item"><a href="source/auxkernels/FunctionArrayAux.html">FunctionArrayAux</a>Auxiliary Kernel that creates and updates an array field variable by sampling functions through space and time.</li><li class="collection-item"><a href="source/auxkernels/FunctionAux.html">FunctionAux</a>Auxiliary Kernel that creates and updates a field variable by sampling a function through space and time.</li><li class="collection-item"><a href="source/auxkernels/FunctorElementalAux.html">FunctorADMatPropElementalAux</a>Evaluates a functor (variable, function or functor material property) on the current element or quadrature point.</li><li class="collection-item"><a href="source/auxkernels/FunctorElementalAux.html">FunctorElementalAux</a>Evaluates a functor (variable, function or functor material property) on the current element or quadrature point.</li><li class="collection-item"><a href="source/auxkernels/FunctorElementalGradientAux.html">FunctorElementalGradientAux</a>Evaluates the gradient of a functor (variable, function or functor material property) on the current element or quadrature point.</li><li class="collection-item"><a href="source/auxkernels/FunctorElementalAux.html">FunctorMatPropElementalAux</a>Evaluates a functor (variable, function or functor material property) on the current element or quadrature point.</li><li class="collection-item"><a href="source/auxkernels/FunctorVectorElementalAux.html">FunctorVectorElementalAux</a>Evaluates a vector functor (material property usually) on the current element.For finite volume, this evaluates the vector functor at the centroid.</li><li class="collection-item"><a href="source/auxkernels/GapValueAux.html">GapValueAux</a>Return the nearest value of a variable on a boundary from across a gap.</li><li class="collection-item"><a href="source/auxkernels/GhostingAux.html">GhostingAux</a>Colors the elements ghosted to the chosen PID.</li><li class="collection-item"><a href="source/auxkernels/HardwareIDAux.html">HardwareIDAux</a>Creates a field showing the assignment of partitions to physical nodes in the cluster.</li><li class="collection-item"><a href="source/auxkernels/InterfaceValueUserObjectAux.html">InterfaceValueUserObjectAux</a>Get stored value from the specified InterfaceQpUserObjectBase.</li><li class="collection-item"><a href="source/auxkernels/MaterialRankFourTensorAux.html">MaterialRankFourTensorAux</a>Access a component of a RankFourTensor for automatic material property output</li><li class="collection-item"><a href="source/auxkernels/MaterialRankTwoTensorAux.html">MaterialRankTwoTensorAux</a>Access a component of a RankTwoTensor for automatic material property output</li><li class="collection-item"><a href="source/auxkernels/MaterialRateRealAux.html">MaterialRateRealAux</a>Outputs element material properties rate of change</li><li class="collection-item"><a href="source/auxkernels/MaterialRealAux.html">MaterialRealAux</a>Outputs element volume-averaged material properties</li><li class="collection-item"><a href="source/auxkernels/MaterialRealDenseMatrixAux.html">MaterialRealDenseMatrixAux</a>Populate an auxiliary variable with an entry from a dense matrix material property.</li><li class="collection-item"><a href="source/auxkernels/MaterialRealTensorValueAux.html">MaterialRealTensorValueAux</a>Object for extracting a component of a rank two tensor material property to populate an auxiliary variable.</li><li class="collection-item"><a href="source/auxkernels/MaterialRealVectorValueAux.html">MaterialRealVectorValueAux</a>Capture a component of a vector material property in an auxiliary variable.</li><li class="collection-item"><a href="source/auxkernels/MaterialStdVectorAux.html">MaterialStdVectorAux</a>Extracts a component of a material type std::vector&lt;Real&gt; to an aux variable.  If the std::vector is not of sufficient size then zero is returned</li><li class="collection-item"><a href="source/auxkernels/MaterialStdVectorRealGradientAux.html">MaterialStdVectorRealGradientAux</a>Extracts a component of a material&#x27;s std::vector&lt;RealGradient&gt; to an aux variable.  If the std::vector is not of sufficient size then zero is returned</li><li class="collection-item"><a href="source/auxkernels/NearestNodeDistanceAux.html">NearestNodeDistanceAux</a>Stores the distance between a block and boundary or between two boundaries.</li><li class="collection-item"><a href="source/auxkernels/NearestNodeValueAux.html">NearestNodeValueAux</a>Retrieves a field value from the closest node on the paired boundary and stores it on this boundary or block.</li><li class="collection-item"><a href="source/auxkernels/NormalizationAux.html">NormalizationAux</a>Normalizes a variable based on a Postprocessor value.</li><li class="collection-item"><a href="source/auxkernels/ParsedAux.html">ParsedAux</a>Sets a field variable value to the evaluation of a parsed expression.</li><li class="collection-item"><a href="source/auxkernels/ParsedVectorAux.html">ParsedVectorAux</a>Sets a field vector variable value to the evaluation of a parsed expression.</li><li class="collection-item"><a href="source/auxkernels/PenetrationAux.html">PenetrationAux</a>Auxiliary Kernel for computing several geometry related quantities between two contacting bodies.</li><li class="collection-item"><a href="source/auxkernels/ProcessorIDAux.html">ProcessorIDAux</a>Creates a field showing the processors and partitioning.</li><li class="collection-item"><a href="source/auxkernels/ProjectionAux.html">ProjectionAux</a>Returns the specified variable as an auxiliary variable with a projection of the source variable. If they are the same type, this amounts to a simple copy.</li><li class="collection-item"><a href="source/auxkernels/QuotientAux.html">QuotientAux</a>Divides two coupled variables.</li><li class="collection-item"><a href="source/auxkernels/SecondTimeDerivativeAux.html">SecondTimeDerivativeAux</a>Returns the second order time derivative of the specified variable as an auxiliary variable.</li><li class="collection-item"><a href="source/auxkernels/ProjectionAux.html">SelfAux</a>Returns the specified variable as an auxiliary variable with a projection of the source variable. If they are the same type, this amounts to a simple copy.</li><li class="collection-item"><a href="source/auxkernels/SolutionAux.html">SolutionAux</a>Creates fields by using information from a SolutionUserObject.</li><li class="collection-item"><a href="source/auxkernels/SpatialUserObjectAux.html">SpatialUserObjectAux</a>Populates an auxiliary variable with a spatial value returned from a UserObject spatialValue method.</li><li class="collection-item"><a href="source/auxkernels/TagMatrixAux.html">TagMatrixAux</a>Couple the diagonal of a tag matrix, and return its nodal value</li><li class="collection-item"><a href="source/auxkernels/TagVectorArrayVariableAux.html">TagVectorArrayVariableAux</a>Couple a tagged vector, and return its evaluations at degree of freedom indices corresponding to the coupled array variable.</li><li class="collection-item"><a href="source/auxkernels/TagVectorArrayVariableValueAux.html">TagVectorArrayVariableValueAux</a>Couple a tagged vector, and return its array value.</li><li class="collection-item"><a href="source/auxkernels/TagVectorAux.html">TagVectorAux</a>Couple a tag vector, and return its nodal value</li><li class="collection-item"><a href="source/auxkernels/TimeDerivativeAux.html">TimeDerivativeAux</a>Returns the time derivative of the specified variable/functor as an auxiliary variable.</li><li class="collection-item"><a href="source/auxkernels/VariableGradientComponent.html">VariableGradientComponent</a>Creates a field consisting of one component of the gradient of a coupled variable.</li><li class="collection-item"><a href="source/auxkernels/VariableOldValueBoundsAux.html">VariableOldValueBoundsAux</a>Uses the old variable values as the bounds for the new solve.</li><li class="collection-item"><a href="source/auxkernels/VariableTimeIntegrationAux.html">VariableTimeIntegrationAux</a>Integrates a field variable in time.</li><li class="collection-item"><a href="source/auxkernels/VectorFunctionAux.html">VectorFunctionAux</a>Auxiliary Kernel that creates and updates a vector field variable by sampling a Function object, via the vectorValue method, through space and time.</li><li class="collection-item"><a href="source/auxkernels/VectorMagnitudeAux.html">VectorMagnitudeAux</a>Creates a field representing the magnitude of three coupled variables using an Euclidean norm.</li><li class="collection-item"><a href="source/auxkernels/VectorMaterialRealVectorValueAux.html">VectorMaterialRealVectorValueAux</a>Converts a vector-quantity material property into a vector auxiliary variable</li><li class="collection-item"><a href="source/auxkernels/VectorPostprocessorVisualizationAux.html">VectorPostprocessorVisualizationAux</a>Read values from a VectorPostprocessor that is producing vectors that are &#x27;number of processors&#x27; * in length.  Puts the value for each processor into an elemental auxiliary field.</li><li class="collection-item"><a href="source/auxkernels/VectorVariableComponentAux.html">VectorVariableComponentAux</a>Creates a field consisting of one component of a coupled vector variable.</li><li class="collection-item"><a href="source/auxkernels/VectorVariableMagnitudeAux.html">VectorVariableMagnitudeAux</a>Creates a field consisting of the magnitude of a coupled vector variable.</li><li class="collection-item"><a href="source/auxkernels/VolumeAux.html">VolumeAux</a>Auxiliary Kernel that samples volumes.</li><li class="collection-item"><a href="source/auxkernels/WeightedGapAux.html">WeightedGapAux</a>Returns the specified variable as an auxiliary variable with the same value.</li><li class="collection-header">Navier Stokes App</li><li class="collection-item"><a href="source/auxkernels/Courant.html">Courant</a>Computes |u| dt / h_min.</li><li class="collection-item"><a href="source/auxkernels/EnthalpyAux.html">EnthalpyAux</a>This AuxKernel computes the specific enthalpy of the fluidfrom the total energy and the pressure.</li><li class="collection-item"><a href="source/auxkernels/HasPorosityJumpFace.html">HasPorosityJumpFace</a>Shows whether an element has any attached porosity jump faces</li><li class="collection-item"><a href="source/auxkernels/INSCourant.html">INSCourant</a>Computes h_min / |u|.</li><li class="collection-item"><a href="source/auxkernels/INSFVMixingLengthTurbulentViscosityAux.html">INSFVMixingLengthTurbulentViscosityAux</a>Computes the turbulent viscosity for the mixing length model.</li><li class="collection-item"><a href="source/auxkernels/INSQCriterionAux.html">INSQCriterionAux</a>This class computes the Q criterion, a scalar whichaids in vortex identification in turbulent flows</li><li class="collection-item"><a href="source/auxkernels/INSStressComponentAux.html">INSStressComponentAux</a>This class computes the stress component based on pressure and velocity for incompressible Navier-Stokes</li><li class="collection-item"><a href="source/auxkernels/InternalEnergyAux.html">InternalEnergyAux</a>This AuxKernel computes the internal energy based on the equation of state / fluid properties and the local pressure and density.</li><li class="collection-item"><a href="source/auxkernels/NSInternalEnergyAux.html">NSInternalEnergyAux</a>Auxiliary kernel for computing the internal energy of the fluid.</li><li class="collection-item"><a href="source/auxkernels/NSLiquidFractionAux.html">NSLiquidFractionAux</a>Computes liquid fraction <span class="moose-katex-inline-equation" id="moose-equation-85aa4cae-12d0-48ca-b38a-0e82fc46a0c3"><script>var element = document.getElementById("moose-equation-85aa4cae-12d0-48ca-b38a-0e82fc46a0c3");katex.render("f_l", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> given the temperature.</li><li class="collection-item"><a href="source/auxkernels/NSMachAux.html">NSMachAux</a>Auxiliary kernel for computing the Mach number assuming an ideal gas.</li><li class="collection-item"><a href="source/auxkernels/NSPressureAux.html">NSPressureAux</a>Nodal auxiliary variable, for computing pressure at the nodes.</li><li class="collection-item"><a href="source/auxkernels/NSSpecificTotalEnthalpyAux.html">NSSpecificTotalEnthalpyAux</a>Nodal auxiliary variable, for computing enthalpy at the nodes.</li><li class="collection-item"><a href="source/auxkernels/NSTemperatureAux.html">NSTemperatureAux</a>Temperature is an auxiliary value computed from the total energy based on the FluidProperties.</li><li class="collection-item"><a href="source/auxkernels/NSVelocityAux.html">NSVelocityAux</a>Velocity auxiliary value.</li><li class="collection-item"><a href="source/auxkernels/PecletNumberFunctorAux.html">PecletNumberFunctorAux</a>Computes the Peclet number: u*L/alpha.</li><li class="collection-item"><a href="source/auxkernels/ReynoldsNumberFunctorAux.html">ReynoldsNumberFunctorAux</a>Computes rho*u*L/mu.</li><li class="collection-item"><a href="source/auxkernels/SpecificInternalEnergyAux.html">SpecificInternalEnergyAux</a>This AuxKernel computes the specific internal energy based from the total and the kinetic energy.</li><li class="collection-item"><a href="source/auxkernels/SpecificVolumeAux.html">SpecificVolumeAux</a>This auxkernel computes the specific volume <span class="moose-katex-inline-equation" id="moose-equation-3833f6d2-3fc2-4dc0-b24a-38bcfb6d5735"><script>var element = document.getElementById("moose-equation-3833f6d2-3fc2-4dc0-b24a-38bcfb6d5735");katex.render("v", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> of the fluid.</li><li class="collection-item"><a href="source/auxkernels/WallDistanceMixingLengthAux.html">WallDistanceMixingLengthAux</a>Computes the turbulent mixing length by assuming that it is proportional to the distance from the nearest wall. The mixinglength is capped at a distance proportional to inputted parameter delta.</li><li class="collection-item"><a href="source/auxkernels/WallFunctionWallShearStressAux.html">WallFunctionWallShearStressAux</a>Calculates the wall shear stress based on algebraic standard velocity wall functions.</li><li class="collection-item"><a href="source/auxkernels/WallFunctionYPlusAux.html">WallFunctionYPlusAux</a>Calculates y+ value according to the algebraic velocity standard wall function.</li><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/auxkernels/KineticEnergyAux.html">ADKineticEnergyAux</a>Compute the kinetic energy of continuum-based finite elements</li><li class="collection-item"><a href="source/auxkernels/RankFourAux.html">ADRankFourAux</a>Access a component of a RankFourTensor</li><li class="collection-item"><a href="source/auxkernels/RankTwoAux.html">ADRankTwoAux</a>Access a component of a RankTwoTensor</li><li class="collection-item"><a href="source/auxkernels/RankTwoScalarAux.html">ADRankTwoScalarAux</a>Compute a scalar property of a RankTwoTensor</li><li class="collection-item"><a href="source/auxkernels/AccumulateAux.html">AccumulateAux</a></li><li class="collection-item"><a href="source/auxkernels/CylindricalRankTwoAux.html">CylindricalRankTwoAux</a>Takes RankTwoTensor material and outputs component in cylindrical coordinates</li><li class="collection-item"><a href="source/auxkernels/DomainIntegralQFunction.html">DomainIntegralQFunction</a>Computes the q-function for a segment along the crack front, used in the calculation of the J-integral</li><li class="collection-item"><a href="source/auxkernels/DomainIntegralTopologicalQFunction.html">DomainIntegralTopologicalQFunction</a>Determines if a node is within the ring of the crack front defintion; this object is normally created by the DomainIntegralAction.</li><li class="collection-item"><a href="source/auxkernels/ElasticEnergyAux.html">ElasticEnergyAux</a>Compute the local elastic energy</li><li class="collection-item"><a href="source/auxkernels/GlobalDisplacementAux.html">GlobalDisplacementAux</a>AuxKernel to visualize the displacements generated by the global strain tensor</li><li class="collection-item"><a href="source/auxkernels/KineticEnergyAux.html">KineticEnergyAux</a>Compute the kinetic energy of continuum-based finite elements</li><li class="collection-item"><a href="source/auxkernels/NewmarkAccelAux.html">NewmarkAccelAux</a>Computes the current acceleration using the Newmark method.</li><li class="collection-item"><a href="source/auxkernels/NewmarkVelAux.html">NewmarkVelAux</a>Calculates the current velocity using Newmark method.</li><li class="collection-item"><a href="source/auxkernels/NodalPatchRecoveryAux.html">NodalPatchRecoveryAux</a>This Auxkernel solves a least squares problem at each node to fit a value from quantities defined on quadrature points.</li><li class="collection-item"><a href="source/auxkernels/RadialDisplacementCylinderAux.html">RadialDisplacementCylinderAux</a>Compute the radial component of the displacement vector for cylindrical models.</li><li class="collection-item"><a href="source/auxkernels/RadialDisplacementSphereAux.html">RadialDisplacementSphereAux</a>Compute the radial component of the displacement vector for spherical models.</li><li class="collection-item"><a href="source/auxkernels/RankFourAux.html">RankFourAux</a>Access a component of a RankFourTensor</li><li class="collection-item"><a href="source/auxkernels/RankTwoAux.html">RankTwoAux</a>Access a component of a RankTwoTensor</li><li class="collection-item"><a href="source/auxkernels/RankTwoScalarAux.html">RankTwoScalarAux</a>Compute a scalar property of a RankTwoTensor</li><li class="collection-item"><a href="source/auxkernels/RotationAngle.html">RotationAngle</a>Compute the field of angular rotations of points around an axis defined by an origin point and a direction vector</li><li class="collection-item"><a href="source/auxkernels/TestNewmarkTI.html">TestNewmarkTI</a>Assigns the velocity/acceleration calculated by time integrator to the velocity/acceleration auxvariable.</li><li class="collection-header">Heat Conduction App</li><li class="collection-item"><a href="source/auxkernels/JouleHeatingHeatGeneratedAux.html">JouleHeatingHeatGeneratedAux</a>Compute heat generated from Joule heating <span class="moose-katex-inline-equation" id="moose-equation-00d8d3c1-2bbb-4507-b7d8-3b19a67a1662"><script>var element = document.getElementById("moose-equation-00d8d3c1-2bbb-4507-b7d8-3b19a67a1662");katex.render("(d\\vec{P}/d\\vec{V} = \\vec{E}^2 \\sigma )", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-header">Fluid Properties App</li><li class="collection-item"><a href="source/auxkernels/FluidDensityAux.html">FluidDensityAux</a>Computes density from pressure and temperature</li><li class="collection-item"><a href="source/auxkernels/PressureAux.html">PressureAux</a>Computes pressure given specific volume and specific internal energy</li><li class="collection-item"><a href="source/auxkernels/SaturationTemperatureAux.html">SaturationTemperatureAux</a>Computes saturation temperature from pressure and 2-phase fluid properties object</li><li class="collection-item"><a href="source/auxkernels/SpecificEnthalpyAux.html">SpecificEnthalpyAux</a>Computes specific enthalpy from pressure and temperature</li><li class="collection-item"><a href="source/auxkernels/StagnationPressureAux.html">StagnationPressureAux</a>Computes stagnation pressure from specific volume, specific internal energy, and velocity</li><li class="collection-item"><a href="source/auxkernels/StagnationTemperatureAux.html">StagnationTemperatureAux</a>Computes stagnation temperature from specific volume, specific internal energy, and velocity</li><li class="collection-item"><a href="source/auxkernels/TemperatureAux.html">TemperatureAux</a>Computes temperature given specific volume and specific internal energy</li></ul></section><section class="scrollspy" id="e867c560-9c72-41a8-87bf-07855e7b6670" data-section-level="2" data-section-text="AuxScalarKernels"><h2 id="auxscalarkernels"><a href="syntax/AuxScalarKernels/index.html">AuxScalarKernels</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddScalarKernelAction.html">AddScalarKernelAction</a>Add a AuxScalarKernel object to the simulation.</li><li class="collection-item"><a href="source/auxkernels/ConstantScalarAux.html">ConstantScalarAux</a>Sets an auxiliary field variable to a controllable constant value.</li><li class="collection-item"><a href="source/auxkernels/FunctionScalarAux.html">FunctionScalarAux</a>Sets a value of a scalar variable based on a function.</li><li class="collection-item"><a href="source/auxkernels/QuotientScalarAux.html">QuotientScalarAux</a>Compute the ratio of two scalar variables.</li><li class="collection-item"><a href="source/auxkernels/ScalarTagMatrixAux.html">ScalarTagMatrixAux</a>Couple a tag matrix, and return its nodal value</li><li class="collection-item"><a href="source/auxkernels/ScalarTagVectorAux.html">ScalarTagVectorAux</a>Couple a tag vector, and return its value</li><li class="collection-item"><a href="source/auxkernels/SolutionScalarAux.html">SolutionScalarAux</a>Sets scalar variable by using information from a SolutionUserObject.</li><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/auxkernels/GeneralizedPlaneStrainReferenceResidual.html">GeneralizedPlaneStrainReferenceResidual</a>Generalized Plane Strain Reference Residual Scalar Kernel</li></ul></section><section class="scrollspy" id="22c465ed-6f63-4bdf-a71b-0f14964e443d" data-section-level="2" data-section-text="AuxVariables"><h2 id="auxvariables"><a href="syntax/AuxVariables/index.html">AuxVariables</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddAuxVariableAction.html">AddAuxVariableAction</a>Add auxiliary variable to the simulation.</li><li class="collection-item"><a href="source/actions/CopyNodalVarsAction.html">CopyNodalVarsAction</a>Copies variable information from a file.</li><li class="collection-item"><a href="source/variables/ArrayMooseVariable.html">ArrayMooseVariable</a>Used for grouping standard field variables with the same finite element family and order</li><li class="collection-item"><a href="source/variables/MooseVariable.html">MooseVariable</a>Represents standard field variables, e.g. Lagrange, Hermite, or non-constant Monomials</li><li class="collection-item"><a href="source/variables/MooseVariableBase.html">MooseVariableBase</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/MooseVariableConstMonomial.html">MooseVariableConstMonomial</a>Specialization for constant monomials that avoids unnecessary loops</li><li class="collection-item"><a href="source/variables/MooseVariableFV.html">MooseVariableFVReal</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/MooseVariableScalar.html">MooseVariableScalar</a>Moose wrapper class around scalar variables</li><li class="collection-item"><a href="source/variables/VectorMooseVariable.html">VectorMooseVariable</a>Represents vector field variables, e.g. Vector Lagrange or Nedelec</li><li class="collection-header">Navier Stokes App</li><li class="collection-item"><a href="source/variables/BernoulliPressureVariable.html">BernoulliPressureVariable</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/INSFVEnergyVariable.html">INSFVEnergyVariable</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/INSFVPressureVariable.html">INSFVPressureVariable</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/INSFVScalarFieldVariable.html">INSFVScalarFieldVariable</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/INSFVVelocityVariable.html">INSFVVelocityVariable</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/PINSFVSuperficialVelocityVariable.html">PINSFVSuperficialVelocityVariable</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/PiecewiseConstantVariable.html">PiecewiseConstantVariable</a>Base class for Moose variables. This should never be the terminal object type</li></ul></section><section class="scrollspy" id="0bea22c2-960e-4320-82a1-8d23fdc89294" data-section-level="2" data-section-text="BCs"><h2 id="bcs"><a href="syntax/BCs/index.html">BCs</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddBCAction.html">AddBCAction</a>Add a BoundaryCondition object to the simulation.</li><li class="collection-item"><a href="source/bcs/ADDirichletBC.html">ADDirichletBC</a>Imposes the essential boundary condition <span class="moose-katex-inline-equation" id="moose-equation-dba3720c-259f-463d-a4e0-b1f9ea2ba989"><script>var element = document.getElementById("moose-equation-dba3720c-259f-463d-a4e0-b1f9ea2ba989");katex.render("u=g", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-566af141-1a36-4a53-862e-f55c9978ff15"><script>var element = document.getElementById("moose-equation-566af141-1a36-4a53-862e-f55c9978ff15");katex.render("g", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is a constant, controllable value.</li><li class="collection-item"><a href="source/bcs/ADFunctionDirichletBC.html">ADFunctionDirichletBC</a>Imposes the essential boundary condition <span class="moose-katex-inline-equation" id="moose-equation-54d76c33-6ec6-451e-8117-ab82e427533d"><script>var element = document.getElementById("moose-equation-54d76c33-6ec6-451e-8117-ab82e427533d");katex.render("u=g", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-3e2c9124-27da-4697-9987-9ecfc84e0532"><script>var element = document.getElementById("moose-equation-3e2c9124-27da-4697-9987-9ecfc84e0532");katex.render("g", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is calculated by a function.</li><li class="collection-item"><a href="source/bcs/ADFunctionNeumannBC.html">ADFunctionNeumannBC</a>Imposes the integrated boundary condition <span class="moose-katex-inline-equation" id="moose-equation-9f3ec34a-78a9-4269-9a7d-adc1d001fbb1"><script>var element = document.getElementById("moose-equation-9f3ec34a-78a9-4269-9a7d-adc1d001fbb1");katex.render("\\frac{\\partial u}{\\partial n}=h(t,\\vec{x})", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-421af9f6-d246-41f2-b73f-340b4a3f5b5d"><script>var element = document.getElementById("moose-equation-421af9f6-d246-41f2-b73f-340b4a3f5b5d");katex.render("h", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is a (possibly) time and space-dependent MOOSE Function.</li><li class="collection-item"><a href="source/bcs/ADFunctionPenaltyDirichletBC.html">ADFunctionPenaltyDirichletBC</a>Enforces a (possibly) time and space-dependent MOOSE Function Dirichlet boundary condition in a weak sense by penalizing differences between the current solution and the Dirichlet data.</li><li class="collection-item"><a href="source/bcs/MatNeumannBC.html">ADMatNeumannBC</a>Imposes the integrated boundary condition <span class="moose-katex-inline-equation" id="moose-equation-ad7a7712-eafb-42ac-b37f-234afef907a8"><script>var element = document.getElementById("moose-equation-ad7a7712-eafb-42ac-b37f-234afef907a8");katex.render("\\frac{C \\partial u}{\\partial n}=M*h", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-f63cc053-91cd-489a-90da-2883849b9c9a"><script>var element = document.getElementById("moose-equation-f63cc053-91cd-489a-90da-2883849b9c9a");katex.render("h", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is a constant, <span class="moose-katex-inline-equation" id="moose-equation-003c96a3-cc15-4e82-a64e-6495ffc29246"><script>var element = document.getElementById("moose-equation-003c96a3-cc15-4e82-a64e-6495ffc29246");katex.render("M", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is a material property, and <span class="moose-katex-inline-equation" id="moose-equation-e2414e2e-73b7-43da-b7dc-5485004f4b5f"><script>var element = document.getElementById("moose-equation-e2414e2e-73b7-43da-b7dc-5485004f4b5f");katex.render("C", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is a coefficient defined by the kernel for <span class="moose-katex-inline-equation" id="moose-equation-5dc011dd-4083-4d00-bedc-7bec05d9a54e"><script>var element = document.getElementById("moose-equation-5dc011dd-4083-4d00-bedc-7bec05d9a54e");katex.render("u", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/bcs/MatchedValueBC.html">ADMatchedValueBC</a>Implements a NodalBC which equates two different Variables&#x27; values on a specified boundary.</li><li class="collection-item"><a href="source/bcs/NeumannBC.html">ADNeumannBC</a>Imposes the integrated boundary condition <span class="moose-katex-inline-equation" id="moose-equation-dbe512b6-4977-4d5a-bda1-71af8e5d26f0"><script>var element = document.getElementById("moose-equation-dbe512b6-4977-4d5a-bda1-71af8e5d26f0");katex.render("\\frac{\\partial u}{\\partial n}=h", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-75c5487f-c6d4-4a5c-a9bb-035ed82d4fa7"><script>var element = document.getElementById("moose-equation-75c5487f-c6d4-4a5c-a9bb-035ed82d4fa7");katex.render("h", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is a constant, controllable value.</li><li class="collection-item"><a href="source/bcs/ADPenaltyDirichletBC.html">ADPenaltyDirichletBC</a>Enforces a Dirichlet boundary condition in a weak sense by penalizing differences between the current solution and the Dirichlet data.</li><li class="collection-item"><a href="source/bcs/ADVectorFunctionDirichletBC.html">ADVectorFunctionDirichletBC</a>Imposes the essential boundary condition <span class="moose-katex-inline-equation" id="moose-equation-9e72cd57-3418-4c56-a8e9-da789c5bd0fc"><script>var element = document.getElementById("moose-equation-9e72cd57-3418-4c56-a8e9-da789c5bd0fc");katex.render("\\vec{u}=\\vec{g}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-ba35e5ae-3bf4-493d-a1a4-5571dea042b6"><script>var element = document.getElementById("moose-equation-ba35e5ae-3bf4-493d-a1a4-5571dea042b6");katex.render("\\vec{g}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> components are calculated with functions.</li><li class="collection-item"><a href="source/bcs/ADVectorFunctionNeumannBC.html">ADVectorFunctionNeumannBC</a>Imposes the integrated boundary condition <span class="moose-katex-inline-equation" id="moose-equation-4fdcaa5f-62c8-43b5-9058-22ec09835bba"><script>var element = document.getElementById("moose-equation-4fdcaa5f-62c8-43b5-9058-22ec09835bba");katex.render("\\frac{\\partial \\vec{u}}{\\partial n} = \\vec{h}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-9411bc4f-f00c-425e-87b8-b7be2c90a4f7"><script>var element = document.getElementById("moose-equation-9411bc4f-f00c-425e-87b8-b7be2c90a4f7");katex.render("\\vec{h}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is a (possibly) time and space-dependent MOOSE Function.</li><li class="collection-item"><a href="source/bcs/ADVectorMatchedValueBC.html">ADVectorMatchedValueBC</a>Implements a ADVectorNodalBC which equates two different Variables&#x27; values on a specified boundary.</li><li class="collection-item"><a href="source/bcs/ArrayDirichletBC.html">ArrayDirichletBC</a>Imposes the essential boundary condition <span class="moose-katex-inline-equation" id="moose-equation-83e6cf29-52db-49cf-9e52-910a86d24c84"><script>var element = document.getElementById("moose-equation-83e6cf29-52db-49cf-9e52-910a86d24c84");katex.render("\\vec{u}=\\vec{g}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-8a15ff92-11c1-45cd-a739-8ce7f7deebcf"><script>var element = document.getElementById("moose-equation-8a15ff92-11c1-45cd-a739-8ce7f7deebcf");katex.render("\\vec{g}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> are constant, controllable values.</li><li class="collection-item"><a href="source/bcs/ArrayHFEMDirichletBC.html">ArrayHFEMDirichletBC</a>Imposes the Dirichlet BC with HFEM.</li><li class="collection-item"><a href="source/bcs/ArrayNeumannBC.html">ArrayNeumannBC</a>Imposes the integrated boundary condition <span class="moose-katex-inline-equation" id="moose-equation-da125341-1990-4b0c-8dd2-d1ad8def32ef"><script>var element = document.getElementById("moose-equation-da125341-1990-4b0c-8dd2-d1ad8def32ef");katex.render("\\frac{\\partial u}{\\partial n}=h", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-8c889fb6-05a5-4e5c-ac78-d86e8f24c8a5"><script>var element = document.getElementById("moose-equation-8c889fb6-05a5-4e5c-ac78-d86e8f24c8a5");katex.render("h", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is a constant, controllable value.</li><li class="collection-item"><a href="source/bcs/ArrayPenaltyDirichletBC.html">ArrayPenaltyDirichletBC</a>Enforces a Dirichlet boundary condition in a weak sense with <span class="moose-katex-inline-equation" id="moose-equation-ceb2a31e-316b-41bc-a900-3f3a92c185c3"><script>var element = document.getElementById("moose-equation-ceb2a31e-316b-41bc-a900-3f3a92c185c3");katex.render("p(\\vec{u}^\\ast, \\vec{u} - \\vec{u}_0)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-ab205060-7742-4119-935e-ea4906a1aaa5"><script>var element = document.getElementById("moose-equation-ab205060-7742-4119-935e-ea4906a1aaa5");katex.render("p", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is the constant scalar penalty; <span class="moose-katex-inline-equation" id="moose-equation-eaaad6ca-6227-4ba6-8243-cf7f78960c29"><script>var element = document.getElementById("moose-equation-eaaad6ca-6227-4ba6-8243-cf7f78960c29");katex.render("\\vec{u}^\\ast", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is the test functions and <span class="moose-katex-inline-equation" id="moose-equation-59d0b146-7ff5-4814-b840-247c6fa8b227"><script>var element = document.getElementById("moose-equation-59d0b146-7ff5-4814-b840-247c6fa8b227");katex.render("\\vec{u} - \\vec{u}_0", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is the differences between the current solution and the Dirichlet data.</li><li class="collection-item"><a href="source/bcs/ArrayVacuumBC.html">ArrayVacuumBC</a>Imposes the Robin boundary condition <span class="moose-katex-inline-equation" id="moose-equation-7615428c-b441-4fe6-b23c-a21b4e2caea9"><script>var element = document.getElementById("moose-equation-7615428c-b441-4fe6-b23c-a21b4e2caea9");katex.render("\\partial_n \\vec{u}=-\\frac{\\vec{\\alpha}}{2}\\vec{u}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/bcs/ConvectiveFluxBC.html">ConvectiveFluxBC</a>Determines boundary values via the initial and final values, flux, and exposure duration</li><li class="collection-item"><a href="source/bcs/CoupledVarNeumannBC.html">CoupledVarNeumannBC</a>Imposes the integrated boundary condition <span class="moose-katex-inline-equation" id="moose-equation-ef6bd3b8-54cc-43a9-ba7d-21fd8a2da75a"><script>var element = document.getElementById("moose-equation-ef6bd3b8-54cc-43a9-ba7d-21fd8a2da75a");katex.render("\\frac{\\partial u}{\\partial n}=v", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-f9677216-605e-4ffd-a8ed-376c15b137bf"><script>var element = document.getElementById("moose-equation-f9677216-605e-4ffd-a8ed-376c15b137bf");katex.render("v", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is a variable.</li><li class="collection-item"><a href="source/bcs/DGFunctionDiffusionDirichletBC.html">DGFunctionDiffusionDirichletBC</a>Diffusion Dirichlet boundary condition for discontinuous Galerkin method.</li><li class="collection-item"><a href="source/bcs/DiffusionFluxBC.html">DiffusionFluxBC</a>Computes a boundary residual contribution consistent with the Diffusion Kernel. Does not impose a boundary condition; instead computes the boundary contribution corresponding to the current value of grad(u) and accumulates it in the residual vector.</li><li class="collection-item"><a href="source/bcs/DirichletBC.html">DirichletBC</a>Imposes the essential boundary condition <span class="moose-katex-inline-equation" id="moose-equation-47ef0494-1367-4079-901c-06936fcbeda9"><script>var element = document.getElementById("moose-equation-47ef0494-1367-4079-901c-06936fcbeda9");katex.render("u=g", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-598607b1-8c43-4d25-8944-d68242eea663"><script>var element = document.getElementById("moose-equation-598607b1-8c43-4d25-8944-d68242eea663");katex.render("g", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is a constant, controllable value.</li><li class="collection-item"><a href="source/bcs/EigenArrayDirichletBC.html">EigenArrayDirichletBC</a>Array Dirichlet BC for eigenvalue solvers</li><li class="collection-item"><a href="source/bcs/EigenDirichletBC.html">EigenDirichletBC</a>Dirichlet BC for eigenvalue solvers</li><li class="collection-item"><a href="source/bcs/FunctionDirichletBC.html">FunctionDirichletBC</a>Imposes the essential boundary condition <span class="moose-katex-inline-equation" id="moose-equation-f89236df-7aad-461a-b688-e5a9709dc725"><script>var element = document.getElementById("moose-equation-f89236df-7aad-461a-b688-e5a9709dc725");katex.render("u=g(t,\\vec{x})", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-b1fd3d94-6aa2-4deb-a8f0-74156df2ef16"><script>var element = document.getElementById("moose-equation-b1fd3d94-6aa2-4deb-a8f0-74156df2ef16");katex.render("g", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is a (possibly) time and space-dependent MOOSE Function.</li><li class="collection-item"><a href="source/bcs/FunctionGradientNeumannBC.html">FunctionGradientNeumannBC</a>Imposes the integrated boundary condition arising from integration by parts of a diffusion/heat conduction operator, and where the exact solution can be specified.</li><li class="collection-item"><a href="source/bcs/FunctionNeumannBC.html">FunctionNeumannBC</a>Imposes the integrated boundary condition <span class="moose-katex-inline-equation" id="moose-equation-3a794856-3713-45f7-87b1-fd79ecec71be"><script>var element = document.getElementById("moose-equation-3a794856-3713-45f7-87b1-fd79ecec71be");katex.render("\\frac{\\partial u}{\\partial n}=h(t,\\vec{x})", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-e26d69d7-4d0c-4a5a-9843-c5fbcadcc334"><script>var element = document.getElementById("moose-equation-e26d69d7-4d0c-4a5a-9843-c5fbcadcc334");katex.render("h", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is a (possibly) time and space-dependent MOOSE Function.</li><li class="collection-item"><a href="source/bcs/FunctionPenaltyDirichletBC.html">FunctionPenaltyDirichletBC</a>Enforces a (possibly) time and space-dependent MOOSE Function Dirichlet boundary condition in a weak sense by penalizing differences between the current solution and the Dirichlet data.</li><li class="collection-item"><a href="source/bcs/HFEMDirichletBC.html">HFEMDirichletBC</a>Imposes the Dirichlet BC with HFEM.</li><li class="collection-item"><a href="source/bcs/VectorDirichletBC.html">LagrangeVecDirichletBC</a>Imposes the essential boundary condition <span class="moose-katex-inline-equation" id="moose-equation-ee402611-faa1-44d5-baed-4106e2d7c0e9"><script>var element = document.getElementById("moose-equation-ee402611-faa1-44d5-baed-4106e2d7c0e9");katex.render("\\vec{u}=\\vec{g}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-c4ff03da-e6e5-4ea9-b1a5-20640a72ae5c"><script>var element = document.getElementById("moose-equation-c4ff03da-e6e5-4ea9-b1a5-20640a72ae5c");katex.render("\\vec{g}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> are constant, controllable values.</li><li class="collection-item"><a href="source/bcs/VectorFunctionDirichletBC.html">LagrangeVecFunctionDirichletBC</a>Imposes the essential boundary condition <span class="moose-katex-inline-equation" id="moose-equation-f87da035-aa95-4b9d-a72c-113b7a05a36c"><script>var element = document.getElementById("moose-equation-f87da035-aa95-4b9d-a72c-113b7a05a36c");katex.render("\\vec{u}=\\vec{g}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-6a6221b1-e3e1-4946-865a-0d81dc2696b2"><script>var element = document.getElementById("moose-equation-6a6221b1-e3e1-4946-865a-0d81dc2696b2");katex.render("\\vec{g}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> components are calculated with functions.</li><li class="collection-item"><a href="source/bcs/MatNeumannBC.html">MatNeumannBC</a>Imposes the integrated boundary condition <span class="moose-katex-inline-equation" id="moose-equation-386c41ee-83c4-41e7-abd7-2332f2136690"><script>var element = document.getElementById("moose-equation-386c41ee-83c4-41e7-abd7-2332f2136690");katex.render("\\frac{C \\partial u}{\\partial n}=M*h", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-48b494a3-e8b8-495f-9b5a-391fc0366ef4"><script>var element = document.getElementById("moose-equation-48b494a3-e8b8-495f-9b5a-391fc0366ef4");katex.render("h", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is a constant, <span class="moose-katex-inline-equation" id="moose-equation-f6e6136d-3584-4192-91b1-e13042dc118a"><script>var element = document.getElementById("moose-equation-f6e6136d-3584-4192-91b1-e13042dc118a");katex.render("M", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is a material property, and <span class="moose-katex-inline-equation" id="moose-equation-62c5039c-c022-484a-8b6e-27df84694c2c"><script>var element = document.getElementById("moose-equation-62c5039c-c022-484a-8b6e-27df84694c2c");katex.render("C", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is a coefficient defined by the kernel for <span class="moose-katex-inline-equation" id="moose-equation-1dc55190-92c2-4685-a6e4-b4b8751114fc"><script>var element = document.getElementById("moose-equation-1dc55190-92c2-4685-a6e4-b4b8751114fc");katex.render("u", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/bcs/MatchedValueBC.html">MatchedValueBC</a>Implements a NodalBC which equates two different Variables&#x27; values on a specified boundary.</li><li class="collection-item"><a href="source/bcs/NeumannBC.html">NeumannBC</a>Imposes the integrated boundary condition <span class="moose-katex-inline-equation" id="moose-equation-5f7d0df3-9a31-46d8-9c7d-0daa1185ddf1"><script>var element = document.getElementById("moose-equation-5f7d0df3-9a31-46d8-9c7d-0daa1185ddf1");katex.render("\\frac{\\partial u}{\\partial n}=h", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-5a979b9c-779a-43d3-af5d-5f89be9e2d4d"><script>var element = document.getElementById("moose-equation-5a979b9c-779a-43d3-af5d-5f89be9e2d4d");katex.render("h", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is a constant, controllable value.</li><li class="collection-item"><a href="source/bcs/OneDEqualValueConstraintBC.html">OneDEqualValueConstraintBC</a>Computes the integral of lambda times dg term from the mortar method (for two 1D domains only).</li><li class="collection-item"><a href="source/bcs/PenaltyDirichletBC.html">PenaltyDirichletBC</a>Enforces a Dirichlet boundary condition in a weak sense by penalizing differences between the current solution and the Dirichlet data.</li><li class="collection-item"><a href="source/bcs/PostprocessorDirichletBC.html">PostprocessorDirichletBC</a>Dirichlet boundary condition with value prescribed by a Postprocessor value.</li><li class="collection-item"><a href="source/bcs/PostprocessorNeumannBC.html">PostprocessorNeumannBC</a>Neumann boundary condition with value prescribed by a Postprocessor value.</li><li class="collection-item"><a href="source/bcs/SinDirichletBC.html">SinDirichletBC</a>Imposes a time-varying essential boundary condition <span class="moose-katex-inline-equation" id="moose-equation-8f0c2007-2368-4abd-822d-f3d78e61e523"><script>var element = document.getElementById("moose-equation-8f0c2007-2368-4abd-822d-f3d78e61e523");katex.render("u=g(t)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-8cb08a8e-80ac-413b-9bbf-caf244b0dcdd"><script>var element = document.getElementById("moose-equation-8cb08a8e-80ac-413b-9bbf-caf244b0dcdd");katex.render("g(t)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> varies from an given initial value at time <span class="moose-katex-inline-equation" id="moose-equation-7f5bda82-f69e-408e-9f5a-b37284ca5549"><script>var element = document.getElementById("moose-equation-7f5bda82-f69e-408e-9f5a-b37284ca5549");katex.render("t=0", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> to a given final value over a specified duration.</li><li class="collection-item"><a href="source/bcs/SinNeumannBC.html">SinNeumannBC</a>Imposes a time-varying flux boundary condition <span class="moose-katex-inline-equation" id="moose-equation-eb787467-727b-4eef-b109-e07a6edac6cd"><script>var element = document.getElementById("moose-equation-eb787467-727b-4eef-b109-e07a6edac6cd");katex.render("\\frac{\\partial u}{\\partial n}=g(t)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-6d744d84-d48e-4e2f-a6fe-48fa0b52c473"><script>var element = document.getElementById("moose-equation-6d744d84-d48e-4e2f-a6fe-48fa0b52c473");katex.render("g(t)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> varies from an given initial value at time <span class="moose-katex-inline-equation" id="moose-equation-f71e567e-f845-424a-8426-e3c9a600d26c"><script>var element = document.getElementById("moose-equation-f71e567e-f845-424a-8426-e3c9a600d26c");katex.render("t=0", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> to a given final value over a specified duration.</li><li class="collection-item">TargetFeedbackDirichletBCDirichlet boundary condition with simple linear feedback control</li><li class="collection-item"><a href="source/bcs/VacuumBC.html">VacuumBC</a>Vacuum boundary condition for diffusion.</li><li class="collection-item"><a href="source/bcs/VectorCurlPenaltyDirichletBC.html">VectorCurlPenaltyDirichletBC</a>Enforces a Dirichlet boundary condition for the curl of vector nonlinear variables in a weak sense by applying a penalty to the difference in the current solution and the Dirichlet data.</li><li class="collection-item"><a href="source/bcs/VectorDirichletBC.html">VectorDirichletBC</a>Imposes the essential boundary condition <span class="moose-katex-inline-equation" id="moose-equation-ff88804b-9b67-4695-8e4b-4b035d13eb2f"><script>var element = document.getElementById("moose-equation-ff88804b-9b67-4695-8e4b-4b035d13eb2f");katex.render("\\vec{u}=\\vec{g}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-f230e6fa-8b32-42d4-9996-b2b6f46dba56"><script>var element = document.getElementById("moose-equation-f230e6fa-8b32-42d4-9996-b2b6f46dba56");katex.render("\\vec{g}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> are constant, controllable values.</li><li class="collection-item"><a href="source/bcs/VectorFunctionDirichletBC.html">VectorFunctionDirichletBC</a>Imposes the essential boundary condition <span class="moose-katex-inline-equation" id="moose-equation-1599f5f4-5215-4ca1-a46c-1e93ba62cbf8"><script>var element = document.getElementById("moose-equation-1599f5f4-5215-4ca1-a46c-1e93ba62cbf8");katex.render("\\vec{u}=\\vec{g}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-fa76e92c-49a8-4d7c-8512-db0c33648937"><script>var element = document.getElementById("moose-equation-fa76e92c-49a8-4d7c-8512-db0c33648937");katex.render("\\vec{g}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> components are calculated with functions.</li><li class="collection-item"><a href="source/bcs/VectorNeumannBC.html">VectorNeumannBC</a>Imposes the integrated boundary condition <span class="moose-katex-inline-equation" id="moose-equation-d54a5baa-0b1d-47f7-b7fc-61116c57c0e0"><script>var element = document.getElementById("moose-equation-d54a5baa-0b1d-47f7-b7fc-61116c57c0e0");katex.render("\\frac{\\partial u}{\\partial n}=\\vec{V}\\cdot\\hat{n}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-23014fa5-f170-40db-b39a-0e4b63fede2d"><script>var element = document.getElementById("moose-equation-23014fa5-f170-40db-b39a-0e4b63fede2d");katex.render("\\vec{V}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is a user-defined, constant vector.</li><li class="collection-item"><a href="source/bcs/VectorPenaltyDirichletBC.html">VectorPenaltyDirichletBC</a>Enforces a Dirichlet boundary condition for vector nonlinear variables in a weak sense by applying a penalty to the difference in the current solution and the Dirichlet data.</li><li class="collection-item"><a href="source/bcs/WeakGradientBC.html">WeakGradientBC</a>Computes a boundary residual contribution consistent with the Diffusion Kernel. Does not impose a boundary condition; instead computes the boundary contribution corresponding to the current value of grad(u) and accumulates it in the residual vector.</li><li class="collection-item"><a href="syntax/BCs/Periodic/index.html">Periodic</a></li><li class="collection-header">Navier Stokes App</li><li class="collection-item"><a href="source/bcs/AdvectionBC.html">AdvectionBC</a>Boundary conditions for outflow/outflow of advected quantities:  phi * velocity * normal, where phi is the advected quantitiy</li><li class="collection-item"><a href="source/bcs/EnergyFreeBC.html">EnergyFreeBC</a>Implements free advective flow boundary conditions for the energy equation.</li><li class="collection-item"><a href="source/bcs/INSFEFluidWallMomentumBC.html">FluidWallMomentumBC</a>Implicitly sets normal component of velocity to zero if the advection term of the momentum equation is integrated by parts</li><li class="collection-item"><a href="source/bcs/INSADMomentumNoBCBC.html">INSADMomentumNoBCBC</a>This class implements the &#x27;No BC&#x27; boundary condition based on the &#x27;Laplace&#x27; form of the viscous stress tensor.</li><li class="collection-item"><a href="source/bcs/INSFEFluidEnergyBC.html">INSFEFluidEnergyBC</a>Specifies flow of energy through a boundary</li><li class="collection-item"><a href="source/bcs/INSFEFluidEnergyDirichletBC.html">INSFEFluidEnergyDirichletBC</a>Imposes a Dirichlet condition on temperature at inlets. Is not applied at outlets</li><li class="collection-item"><a href="source/bcs/INSFEFluidMassBC.html">INSFEFluidMassBC</a>Specifies flow of mass through a boundary given a velocity function or postprocessor</li><li class="collection-item"><a href="source/bcs/INSFEFluidMomentumBC.html">INSFEFluidMomentumBC</a>Specifies flow of momentum through a boundary</li><li class="collection-item"><a href="source/bcs/INSFEFluidWallMomentumBC.html">INSFEFluidWallMomentumBC</a>Implicitly sets normal component of velocity to zero if the advection term of the momentum equation is integrated by parts</li><li class="collection-item"><a href="source/bcs/INSFEMomentumFreeSlipBC.html">INSFEMomentumFreeSlipBC</a>Implements free slip boundary conditions for the Navier Stokesmomentum equation.</li><li class="collection-item"><a href="source/bcs/INSMomentumNoBCBCLaplaceForm.html">INSMomentumNoBCBCLaplaceForm</a>This class implements the &#x27;No BC&#x27; boundary condition based on the &#x27;Laplace&#x27; form of the viscous stress tensor.</li><li class="collection-item"><a href="source/bcs/INSMomentumNoBCBCTractionForm.html">INSMomentumNoBCBCTractionForm</a>This class implements the &#x27;No BC&#x27; boundary condition based on the &#x27;traction&#x27; form of the viscous stress tensor.</li><li class="collection-item"><a href="source/bcs/INSTemperatureNoBCBC.html">INSTemperatureNoBCBC</a>This class implements the &#x27;No BC&#x27; boundary condition discussed by Griffiths, Papanastiou, and others.</li><li class="collection-item"><a href="source/bcs/ImplicitNeumannBC.html">ImplicitNeumannBC</a>This class implements a form of the Neumann boundary condition in which the boundary term is treated &#x27;implicitly&#x27;.</li><li class="collection-item"><a href="source/bcs/INSFEFluidEnergyBC.html">MDFluidEnergyBC</a>Specifies flow of energy through a boundary</li><li class="collection-item"><a href="source/bcs/INSFEFluidEnergyDirichletBC.html">MDFluidEnergyDirichletBC</a>Imposes a Dirichlet condition on temperature at inlets. Is not applied at outlets</li><li class="collection-item"><a href="source/bcs/INSFEFluidMassBC.html">MDFluidMassBC</a>Specifies flow of mass through a boundary given a velocity function or postprocessor</li><li class="collection-item"><a href="source/bcs/INSFEFluidMomentumBC.html">MDFluidMomentumBC</a>Specifies flow of momentum through a boundary</li><li class="collection-item"><a href="source/bcs/INSFEMomentumFreeSlipBC.html">MDMomentumFreeSlipBC</a>Implements free slip boundary conditions for the Navier Stokesmomentum equation.</li><li class="collection-item"><a href="source/bcs/MassFreeBC.html">MassFreeBC</a>Implements free advective flow boundary conditions for the mass equation.</li><li class="collection-item"><a href="source/bcs/MomentumFreeBC.html">MomentumFreeBC</a>Implements free flow boundary conditions for one of the momentum equations.</li><li class="collection-item"><a href="source/bcs/MomentumFreeSlipBC.html">MomentumFreeSlipBC</a>Implements free slip boundary conditions for the Navier Stokesmomentum equation.</li><li class="collection-item"><a href="source/bcs/NSEnergyInviscidSpecifiedBC.html">NSEnergyInviscidSpecifiedBC</a>This class corresponds to the inviscid part of the &#x27;natural&#x27; boundary condition for the energy equation.</li><li class="collection-item"><a href="source/bcs/NSEnergyInviscidSpecifiedDensityAndVelocityBC.html">NSEnergyInviscidSpecifiedDensityAndVelocityBC</a>This class corresponds to the inviscid part of the &#x27;natural&#x27; boundary condition for the energy equation.</li><li class="collection-item"><a href="source/bcs/NSEnergyInviscidSpecifiedNormalFlowBC.html">NSEnergyInviscidSpecifiedNormalFlowBC</a>This class corresponds to the inviscid part of the &#x27;natural&#x27; boundary condition for the energy equation.</li><li class="collection-item"><a href="source/bcs/NSEnergyInviscidSpecifiedPressureBC.html">NSEnergyInviscidSpecifiedPressureBC</a>This class corresponds to the inviscid part of the &#x27;natural&#x27; boundary condition for the energy equation.</li><li class="collection-item"><a href="source/bcs/NSEnergyInviscidUnspecifiedBC.html">NSEnergyInviscidUnspecifiedBC</a>This class corresponds to the inviscid part of the &#x27;natural&#x27; boundary condition for the energy equation.</li><li class="collection-item"><a href="source/bcs/NSEnergyViscousBC.html">NSEnergyViscousBC</a>This class couples together all the variables for the compressible Navier-Stokes equations to allow them to be used in derived IntegratedBC classes.</li><li class="collection-item"><a href="source/bcs/NSEnergyWeakStagnationBC.html">NSEnergyWeakStagnationBC</a>The inviscid energy BC term with specified normal flow.</li><li class="collection-item"><a href="source/bcs/NSImposedVelocityBC.html">NSImposedVelocityBC</a>Impose Velocity BC.</li><li class="collection-item"><a href="source/bcs/NSImposedVelocityDirectionBC.html">NSImposedVelocityDirectionBC</a>This class imposes a velocity direction component as a Dirichlet condition on the appropriate momentum equation.</li><li class="collection-item"><a href="source/bcs/NSInflowThermalBC.html">NSInflowThermalBC</a>This class is used on a boundary where the incoming flow values (rho, u, v, T) are all completely specified.</li><li class="collection-item"><a href="source/bcs/NSMassSpecifiedNormalFlowBC.html">NSMassSpecifiedNormalFlowBC</a>This class implements the mass equation boundary term with a specified value of rho*(u.n) imposed weakly.</li><li class="collection-item"><a href="source/bcs/NSMassUnspecifiedNormalFlowBC.html">NSMassUnspecifiedNormalFlowBC</a>This class implements the mass equation boundary term with the rho*(u.n) boundary integral computed implicitly.</li><li class="collection-item"><a href="source/bcs/NSMassWeakStagnationBC.html">NSMassWeakStagnationBC</a>The inviscid energy BC term with specified normal flow.</li><li class="collection-item"><a href="source/bcs/NSMomentumConvectiveWeakStagnationBC.html">NSMomentumConvectiveWeakStagnationBC</a>The convective part (sans pressure term) of the momentum equation boundary integral evaluated at specified stagnation temperature, stagnation pressure, and flow direction values.</li><li class="collection-item"><a href="source/bcs/NSMomentumInviscidNoPressureImplicitFlowBC.html">NSMomentumInviscidNoPressureImplicitFlowBC</a>Momentum equation boundary condition used when pressure <em>is not</em> integrated by parts.</li><li class="collection-item"><a href="source/bcs/NSMomentumInviscidSpecifiedNormalFlowBC.html">NSMomentumInviscidSpecifiedNormalFlowBC</a>Momentum equation boundary condition in which pressure is specified (given) and the value of the convective part is allowed to vary (is computed implicitly).</li><li class="collection-item"><a href="source/bcs/NSMomentumInviscidSpecifiedPressureBC.html">NSMomentumInviscidSpecifiedPressureBC</a>Momentum equation boundary condition in which pressure is specified (given) and the value of the convective part is allowed to vary (is computed implicitly).</li><li class="collection-item"><a href="source/bcs/NSMomentumPressureWeakStagnationBC.html">NSMomentumPressureWeakStagnationBC</a>This class implements the pressure term of the momentum equation boundary integral for use in weak stagnation boundary conditions.</li><li class="collection-item"><a href="source/bcs/NSMomentumViscousBC.html">NSMomentumViscousBC</a>This class corresponds to the viscous part of the &#x27;natural&#x27; boundary condition for the momentum equations.</li><li class="collection-item"><a href="source/bcs/NSPenalizedNormalFlowBC.html">NSPenalizedNormalFlowBC</a>This class penalizes the the value of u.n on the boundary so that it matches some desired value.</li><li class="collection-item"><a href="source/bcs/NSPressureNeumannBC.html">NSPressureNeumannBC</a>This kernel is appropriate for use with a &#x27;zero normal flow&#x27; boundary condition in the context of the Euler equations.</li><li class="collection-item"><a href="source/bcs/NSStagnationPressureBC.html">NSStagnationPressureBC</a>This Dirichlet condition imposes the condition p_0 = p_0_desired.</li><li class="collection-item"><a href="source/bcs/NSStagnationTemperatureBC.html">NSStagnationTemperatureBC</a>This Dirichlet condition imposes the condition T_0 = T_0_desired.</li><li class="collection-item"><a href="source/bcs/NSThermalBC.html">NSThermalBC</a>NS thermal BC.</li><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/bcs/PenaltyInclinedNoDisplacementBC.html">ADPenaltyInclinedNoDisplacementBC</a>Penalty Enforcement of an inclined boundary condition</li><li class="collection-item"><a href="source/bcs/Pressure.html">ADPressure</a>Applies a pressure on a given boundary in a given direction</li><li class="collection-item"><a href="source/bcs/Torque.html">ADTorque</a>Apply a moment as tractions distributed over a surface around a pivot point. This should operate on the displaced mesh for large deformations.</li><li class="collection-item"><a href="source/bcs/CoupledPressureBC.html">CoupledPressureBC</a>Applies a pressure from a variable on a given boundary in a given direction</li><li class="collection-item"><a href="source/bcs/DashpotBC.html">DashpotBC</a></li><li class="collection-item"><a href="source/bcs/DisplacementAboutAxis.html">DisplacementAboutAxis</a>Implements a boundary condition that enforces rotationaldisplacement around an axis on a boundary</li><li class="collection-item"><a href="source/bcs/InteractionIntegralBenchmarkBC.html">InteractionIntegralBenchmarkBC</a>Implements a boundary condition that enforces a displacement field around a crack tip based on applied stress intensity factors.</li><li class="collection-item"><a href="source/bcs/PenaltyInclinedNoDisplacementBC.html">PenaltyInclinedNoDisplacementBC</a>Penalty Enforcement of an inclined boundary condition</li><li class="collection-item"><a href="source/bcs/PresetAcceleration.html">PresetAcceleration</a>Prescribe acceleration on a given boundary in a given direction</li><li class="collection-item"><a href="source/bcs/PresetDisplacement.html">PresetDisplacement</a>Prescribe the displacement on a given boundary in a given direction.</li><li class="collection-item"><a href="source/bcs/PresetVelocity.html">PresetVelocity</a></li><li class="collection-item"><a href="source/bcs/Pressure.html">Pressure</a>Applies a pressure on a given boundary in a given direction</li><li class="collection-item"><a href="source/bcs/StickyBC.html">StickyBC</a>Imposes the boundary condition <span class="moose-katex-inline-equation" id="moose-equation-3098814c-ad84-4d21-97e2-a8601b17360e"><script>var element = document.getElementById("moose-equation-3098814c-ad84-4d21-97e2-a8601b17360e");katex.render("u = u_{old}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> if <span class="moose-katex-inline-equation" id="moose-equation-9fda618d-1027-41eb-8e95-c9b10af784d1"><script>var element = document.getElementById("moose-equation-9fda618d-1027-41eb-8e95-c9b10af784d1");katex.render("u_{old}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> exceeds the bounds provided</li><li class="collection-item"><a href="source/bcs/Torque.html">Torque</a>Apply a moment as tractions distributed over a surface around a pivot point. This should operate on the displaced mesh for large deformations.</li><li class="collection-item"><a href="syntax/BCs/CavityPressure/index.html">CavityPressure</a></li><li class="collection-item"><a href="syntax/BCs/CoupledPressure/index.html">CoupledPressure</a></li><li class="collection-item"><a href="syntax/BCs/InclinedNoDisplacementBC/index.html">InclinedNoDisplacementBC</a></li><li class="collection-item"><a href="syntax/BCs/Pressure/index.html">Pressure</a></li><li class="collection-header">Rdg App</li><li class="collection-item"><a href="source/bcs/AEFVBC.html">AEFVBC</a>A boundary condition kernel for the advection equation using a cell-centered finite volume method.</li><li class="collection-header">Heat Conduction App</li><li class="collection-item"><a href="source/bcs/ADConvectiveHeatFluxBC.html">ADConvectiveHeatFluxBC</a>Convective heat transfer boundary condition with temperature and heat transfer coefficent given by material properties.</li><li class="collection-item"><a href="source/bcs/FunctionRadiativeBC.html">ADFunctionRadiativeBC</a>Boundary condition for radiative heat exchange where the emissivity function is supplied by a Function.</li><li class="collection-item"><a href="source/bcs/InfiniteCylinderRadiativeBC.html">ADInfiniteCylinderRadiativeBC</a>Boundary condition for radiative heat exchange with a cylinderwhere the boundary is approximated as a cylinder as well.</li><li class="collection-item"><a href="source/bcs/ConvectiveFluxFunction.html">ConvectiveFluxFunction</a>Determines boundary value by fluid heat transfer coefficient and far-field temperature</li><li class="collection-item"><a href="source/bcs/ConvectiveHeatFluxBC.html">ConvectiveHeatFluxBC</a>Convective heat transfer boundary condition with temperature and heat transfer coefficent given by material properties.</li><li class="collection-item"><a href="source/bcs/CoupledConvectiveFlux.html">CoupledConvectiveFlux</a></li><li class="collection-item"><a href="source/bcs/CoupledConvectiveHeatFluxBC.html">CoupledConvectiveHeatFluxBC</a>Convective heat transfer boundary condition with temperature and heat transfer coefficent given by auxiliary variables.</li><li class="collection-item"><a href="source/bcs/DirectionalFluxBC.html">DirectionalFluxBC</a>Applies a directional flux multiplied by the surface normal vector. Can utilize the self shadowing calculation from a SelfShadowSideUserObject.</li><li class="collection-item"><a href="source/bcs/FunctionRadiativeBC.html">FunctionRadiativeBC</a>Boundary condition for radiative heat exchange where the emissivity function is supplied by a Function.</li><li class="collection-item"><a href="source/bcs/GapHeatTransfer.html">GapHeatTransfer</a>Transfers heat across a gap between two surfaces dependent on the gap geometry specified.</li><li class="collection-item"><a href="source/bcs/GaussianEnergyFluxBC.html">GaussianEnergyFluxBC</a>Describes an incoming heat flux beam with a Gaussian profile</li><li class="collection-item"><a href="source/bcs/GrayLambertNeumannBC.html">GrayLambertNeumannBC</a>This BC imposes a heat flux density that is computed from the GrayLambertSurfaceRadiationBase userobject.</li><li class="collection-item"><a href="source/bcs/HeatConductionBC.html">HeatConductionBC</a></li><li class="collection-item"><a href="source/bcs/InfiniteCylinderRadiativeBC.html">InfiniteCylinderRadiativeBC</a>Boundary condition for radiative heat exchange with a cylinderwhere the boundary is approximated as a cylinder as well.</li><li class="collection-header">Eel App</li><li class="collection-item"><a href="source/bcs/CoupledVarDirichletBC.html">CoupledVarDirichletBC</a>Imposes the essential boundary condition <span class="moose-katex-inline-equation" id="moose-equation-42e9535c-51e3-4402-9be8-def354cf395e"><script>var element = document.getElementById("moose-equation-42e9535c-51e3-4402-9be8-def354cf395e");katex.render("u=g", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span></li><li class="collection-item"><a href="source/bcs/OpenBC.html">OpenBC</a>An open BC where matters can freely flow in and out.</li></ul><section id="1b82c175-7007-4129-9b0b-6e0156b57e2d" data-section-level="3" data-section-text="BCs/CavityPressure"><h3 id="bcs/cavitypressure"><a href="syntax/BCs/CavityPressure/index.html">BCs/CavityPressure</a></h3><ul class="moose-syntax-list collection with-header"><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/actions/CavityPressureAction.html">CavityPressureAction</a>Action to setup cavity pressure boundary condition</li><li class="collection-item"><a href="source/actions/CavityPressurePPAction.html">CavityPressurePPAction</a>This Action creates a CavityPressurePostprocessor.</li><li class="collection-item"><a href="source/actions/CavityPressureUOAction.html">CavityPressureUOAction</a>Action to add user objects for cavity pressure</li></ul></section><section id="ecf7cdef-ffda-4410-8a12-97b0d37b65e2" data-section-level="3" data-section-text="BCs/CoupledPressure"><h3 id="bcs/coupledpressure"><a href="syntax/BCs/CoupledPressure/index.html">BCs/CoupledPressure</a></h3><ul class="moose-syntax-list collection with-header"><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/actions/CoupledPressureAction.html">CoupledPressureAction</a>Set up Coupled Pressure boundary conditions</li></ul></section><section id="14377268-8ebc-4bb0-98c8-9b113981ec51" data-section-level="3" data-section-text="BCs/InclinedNoDisplacementBC"><h3 id="bcs/inclinednodisplacementbc"><a href="syntax/BCs/InclinedNoDisplacementBC/index.html">BCs/InclinedNoDisplacementBC</a></h3><ul class="moose-syntax-list collection with-header"><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/actions/InclinedNoDisplacementBCAction.html">InclinedNoDisplacementBCAction</a>Set up inclined no displacement boundary conditions</li></ul></section><section id="11e4e0e4-1a72-4a0e-875b-2d489f6d616b" data-section-level="3" data-section-text="BCs/Periodic"><h3 id="bcs/periodic"><a href="syntax/BCs/Periodic/index.html">BCs/Periodic</a></h3><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddPeriodicBCAction.html">AddPeriodicBCAction</a>Action that adds periodic boundary conditions</li></ul></section><section id="f05c1551-4ade-435f-b0ef-1a3210d0e700" data-section-level="3" data-section-text="BCs/Pressure"><h3 id="bcs/pressure"><a href="syntax/BCs/Pressure/index.html">BCs/Pressure</a></h3><ul class="moose-syntax-list collection with-header"><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/actions/PressureAction.html">PressureAction</a>Set up Pressure boundary conditions</li></ul></section></section><section class="scrollspy" id="6aa6c69e-b58d-4202-9f0d-5520c38713c3" data-section-level="2" data-section-text="Bounds"><h2 id="bounds"><a href="syntax/Bounds/index.html">Bounds</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddBoundsVectorsAction.html">AddBoundsVectorsAction</a>Action to add vectors to nonlinear system when using the Bounds syntax.</li><li class="collection-item"><a href="source/actions/AddKernelAction.html">AddKernelAction</a>Add a Kernel object to the simulation.</li><li class="collection-item"><a href="source/auxkernels/DivergenceAux.html">ADDivergenceAux</a>Computes the divergence of a vector of functors.</li><li class="collection-item"><a href="source/auxkernels/FunctorElementalAux.html">ADFunctorElementalAux</a>Evaluates a functor (variable, function or functor material property) on the current element or quadrature point.</li><li class="collection-item"><a href="source/auxkernels/FunctorElementalGradientAux.html">ADFunctorElementalGradientAux</a>Evaluates the gradient of a functor (variable, function or functor material property) on the current element or quadrature point.</li><li class="collection-item"><a href="source/auxkernels/FunctorVectorElementalAux.html">ADFunctorVectorElementalAux</a>Evaluates a vector functor (material property usually) on the current element.For finite volume, this evaluates the vector functor at the centroid.</li><li class="collection-item"><a href="source/auxkernels/MaterialRankTwoTensorAux.html">ADMaterialRankTwoTensorAux</a>Access a component of a RankTwoTensor for automatic material property output</li><li class="collection-item"><a href="source/auxkernels/MaterialRateRealAux.html">ADMaterialRateRealAux</a>Outputs element material properties rate of change</li><li class="collection-item"><a href="source/auxkernels/MaterialRealAux.html">ADMaterialRealAux</a>Outputs element volume-averaged material properties</li><li class="collection-item"><a href="source/auxkernels/MaterialRealVectorValueAux.html">ADMaterialRealVectorValueAux</a>Capture a component of a vector material property in an auxiliary variable.</li><li class="collection-item"><a href="source/auxkernels/MaterialStdVectorAux.html">ADMaterialStdVectorAux</a>Extracts a component of a material type std::vector&lt;Real&gt; to an aux variable.  If the std::vector is not of sufficient size then zero is returned</li><li class="collection-item"><a href="source/auxkernels/VectorMaterialRealVectorValueAux.html">ADVectorMaterialRealVectorValueAux</a>Converts a vector-quantity material property into a vector auxiliary variable</li><li class="collection-item"><a href="source/auxkernels/ArrayParsedAux.html">ArrayParsedAux</a>Sets field array variable values to the evaluation of a parsed expression.</li><li class="collection-item"><a href="source/auxkernels/ArrayVarReductionAux.html">ArrayVarReductionAux</a>Takes an array variable and performs a reduction operation on it (max, min, sum, average) and stores as a standard variable.</li><li class="collection-item"><a href="source/auxkernels/ArrayVariableComponent.html">ArrayVariableComponent</a>Copy a component of an array variable.</li><li class="collection-item"><a href="source/auxkernels/BuildArrayVariableAux.html">BuildArrayVariableAux</a>Combines multiple standard variables into an array variable.</li><li class="collection-item"><a href="source/auxkernels/ConstantAux.html">ConstantAux</a>Creates a constant field in the domain.</li><li class="collection-item"><a href="source/auxkernels/ConstantBoundsAux.html">ConstantBoundsAux</a>Provides constant bound of a variable for the PETSc&#x27;s variational inequalities solver</li><li class="collection-item"><a href="source/auxkernels/ContainsPointAux.html">ContainsPointAux</a>Computes a binary field where the field is 1 in the elements that contain the point  and 0 everywhere else</li><li class="collection-item"><a href="source/auxkernels/CopyValueAux.html">CopyValueAux</a>Returns the specified variable as an auxiliary variable with a simple copy of the variable values.</li><li class="collection-item"><a href="source/auxkernels/DebugResidualAux.html">DebugResidualAux</a>Populate an auxiliary variable with the residual contribution of a variable.</li><li class="collection-item"><a href="source/auxkernels/DiffusionFluxAux.html">DiffusionFluxAux</a>Compute components of flux vector for diffusion problems <span class="moose-katex-inline-equation" id="moose-equation-a7e428ea-1a47-4bdc-9bed-b6e7855ae3f8"><script>var element = document.getElementById("moose-equation-a7e428ea-1a47-4bdc-9bed-b6e7855ae3f8");katex.render("(\\vec{J} = -D \\nabla C)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/auxkernels/DivergenceAux.html">DivergenceAux</a>Computes the divergence of a vector of functors.</li><li class="collection-item"><a href="source/auxkernels/ExtraElementIDAux.html">ElemExtraIDAux</a>Puts element extra IDs into an aux variable.</li><li class="collection-item"><a href="source/auxkernels/ElementH1ErrorFunctionAux.html">ElementH1ErrorFunctionAux</a>Computes the H1 or W^{1,p} error between an exact function and a coupled variable.</li><li class="collection-item"><a href="source/auxkernels/ElementIntegerAux.html">ElementIntegerAux</a>Creates a field showing the element integer.</li><li class="collection-item"><a href="source/auxkernels/ElementL2ErrorFunctionAux.html">ElementL2ErrorFunctionAux</a>A class for computing the element-wise L^2 (Euclidean) error between a function and a coupled variable.</li><li class="collection-item"><a href="source/auxkernels/ElementLengthAux.html">ElementLengthAux</a>Compute the element size using Elem::hmin() or Elem::hmax() from libMesh.</li><li class="collection-item"><a href="source/auxkernels/ElementLpNormAux.html">ElementLpNormAux</a>Compute an elemental field variable (single value per element) equal to the Lp-norm of a coupled Variable.</li><li class="collection-item"><a href="source/auxkernels/ElementQualityAux.html">ElementQualityAux</a>Generates a field containing the quality metric for each element.  Useful for visualizing mesh quality.</li><li class="collection-item"><a href="source/auxkernels/ElementUOAux.html">ElementUOAux</a>Aux Kernel to display generic spatial (elemental) information from a UserObject that satisfies the underlying ElementUOProvider interface.</li><li class="collection-item"><a href="source/auxkernels/ExtraElementIDAux.html">ExtraElementIDAux</a>Puts element extra IDs into an aux variable.</li><li class="collection-item"><a href="source/auxkernels/ForcingFunctionAux.html">ForcingFunctionAux</a>Auxiliary Kernel that adds a forcing function to the value of an AuxVariable from the previous time step.</li><li class="collection-item"><a href="source/auxkernels/FunctionArrayAux.html">FunctionArrayAux</a>Auxiliary Kernel that creates and updates an array field variable by sampling functions through space and time.</li><li class="collection-item"><a href="source/auxkernels/FunctionAux.html">FunctionAux</a>Auxiliary Kernel that creates and updates a field variable by sampling a function through space and time.</li><li class="collection-item"><a href="source/auxkernels/FunctorElementalAux.html">FunctorADMatPropElementalAux</a>Evaluates a functor (variable, function or functor material property) on the current element or quadrature point.</li><li class="collection-item"><a href="source/auxkernels/FunctorElementalAux.html">FunctorElementalAux</a>Evaluates a functor (variable, function or functor material property) on the current element or quadrature point.</li><li class="collection-item"><a href="source/auxkernels/FunctorElementalGradientAux.html">FunctorElementalGradientAux</a>Evaluates the gradient of a functor (variable, function or functor material property) on the current element or quadrature point.</li><li class="collection-item"><a href="source/auxkernels/FunctorElementalAux.html">FunctorMatPropElementalAux</a>Evaluates a functor (variable, function or functor material property) on the current element or quadrature point.</li><li class="collection-item"><a href="source/auxkernels/FunctorVectorElementalAux.html">FunctorVectorElementalAux</a>Evaluates a vector functor (material property usually) on the current element.For finite volume, this evaluates the vector functor at the centroid.</li><li class="collection-item"><a href="source/auxkernels/GapValueAux.html">GapValueAux</a>Return the nearest value of a variable on a boundary from across a gap.</li><li class="collection-item"><a href="source/auxkernels/GhostingAux.html">GhostingAux</a>Colors the elements ghosted to the chosen PID.</li><li class="collection-item"><a href="source/auxkernels/HardwareIDAux.html">HardwareIDAux</a>Creates a field showing the assignment of partitions to physical nodes in the cluster.</li><li class="collection-item"><a href="source/auxkernels/InterfaceValueUserObjectAux.html">InterfaceValueUserObjectAux</a>Get stored value from the specified InterfaceQpUserObjectBase.</li><li class="collection-item"><a href="source/auxkernels/MaterialRankFourTensorAux.html">MaterialRankFourTensorAux</a>Access a component of a RankFourTensor for automatic material property output</li><li class="collection-item"><a href="source/auxkernels/MaterialRankTwoTensorAux.html">MaterialRankTwoTensorAux</a>Access a component of a RankTwoTensor for automatic material property output</li><li class="collection-item"><a href="source/auxkernels/MaterialRateRealAux.html">MaterialRateRealAux</a>Outputs element material properties rate of change</li><li class="collection-item"><a href="source/auxkernels/MaterialRealAux.html">MaterialRealAux</a>Outputs element volume-averaged material properties</li><li class="collection-item"><a href="source/auxkernels/MaterialRealDenseMatrixAux.html">MaterialRealDenseMatrixAux</a>Populate an auxiliary variable with an entry from a dense matrix material property.</li><li class="collection-item"><a href="source/auxkernels/MaterialRealTensorValueAux.html">MaterialRealTensorValueAux</a>Object for extracting a component of a rank two tensor material property to populate an auxiliary variable.</li><li class="collection-item"><a href="source/auxkernels/MaterialRealVectorValueAux.html">MaterialRealVectorValueAux</a>Capture a component of a vector material property in an auxiliary variable.</li><li class="collection-item"><a href="source/auxkernels/MaterialStdVectorAux.html">MaterialStdVectorAux</a>Extracts a component of a material type std::vector&lt;Real&gt; to an aux variable.  If the std::vector is not of sufficient size then zero is returned</li><li class="collection-item"><a href="source/auxkernels/MaterialStdVectorRealGradientAux.html">MaterialStdVectorRealGradientAux</a>Extracts a component of a material&#x27;s std::vector&lt;RealGradient&gt; to an aux variable.  If the std::vector is not of sufficient size then zero is returned</li><li class="collection-item"><a href="source/auxkernels/NearestNodeDistanceAux.html">NearestNodeDistanceAux</a>Stores the distance between a block and boundary or between two boundaries.</li><li class="collection-item"><a href="source/auxkernels/NearestNodeValueAux.html">NearestNodeValueAux</a>Retrieves a field value from the closest node on the paired boundary and stores it on this boundary or block.</li><li class="collection-item"><a href="source/auxkernels/NormalizationAux.html">NormalizationAux</a>Normalizes a variable based on a Postprocessor value.</li><li class="collection-item"><a href="source/auxkernels/ParsedAux.html">ParsedAux</a>Sets a field variable value to the evaluation of a parsed expression.</li><li class="collection-item"><a href="source/auxkernels/ParsedVectorAux.html">ParsedVectorAux</a>Sets a field vector variable value to the evaluation of a parsed expression.</li><li class="collection-item"><a href="source/auxkernels/PenetrationAux.html">PenetrationAux</a>Auxiliary Kernel for computing several geometry related quantities between two contacting bodies.</li><li class="collection-item"><a href="source/auxkernels/ProcessorIDAux.html">ProcessorIDAux</a>Creates a field showing the processors and partitioning.</li><li class="collection-item"><a href="source/auxkernels/ProjectionAux.html">ProjectionAux</a>Returns the specified variable as an auxiliary variable with a projection of the source variable. If they are the same type, this amounts to a simple copy.</li><li class="collection-item"><a href="source/auxkernels/QuotientAux.html">QuotientAux</a>Divides two coupled variables.</li><li class="collection-item"><a href="source/auxkernels/SecondTimeDerivativeAux.html">SecondTimeDerivativeAux</a>Returns the second order time derivative of the specified variable as an auxiliary variable.</li><li class="collection-item"><a href="source/auxkernels/ProjectionAux.html">SelfAux</a>Returns the specified variable as an auxiliary variable with a projection of the source variable. If they are the same type, this amounts to a simple copy.</li><li class="collection-item"><a href="source/auxkernels/SolutionAux.html">SolutionAux</a>Creates fields by using information from a SolutionUserObject.</li><li class="collection-item"><a href="source/auxkernels/SpatialUserObjectAux.html">SpatialUserObjectAux</a>Populates an auxiliary variable with a spatial value returned from a UserObject spatialValue method.</li><li class="collection-item"><a href="source/auxkernels/TagMatrixAux.html">TagMatrixAux</a>Couple the diagonal of a tag matrix, and return its nodal value</li><li class="collection-item"><a href="source/auxkernels/TagVectorArrayVariableAux.html">TagVectorArrayVariableAux</a>Couple a tagged vector, and return its evaluations at degree of freedom indices corresponding to the coupled array variable.</li><li class="collection-item"><a href="source/auxkernels/TagVectorArrayVariableValueAux.html">TagVectorArrayVariableValueAux</a>Couple a tagged vector, and return its array value.</li><li class="collection-item"><a href="source/auxkernels/TagVectorAux.html">TagVectorAux</a>Couple a tag vector, and return its nodal value</li><li class="collection-item"><a href="source/auxkernels/TimeDerivativeAux.html">TimeDerivativeAux</a>Returns the time derivative of the specified variable/functor as an auxiliary variable.</li><li class="collection-item"><a href="source/auxkernels/VariableGradientComponent.html">VariableGradientComponent</a>Creates a field consisting of one component of the gradient of a coupled variable.</li><li class="collection-item"><a href="source/auxkernels/VariableOldValueBoundsAux.html">VariableOldValueBoundsAux</a>Uses the old variable values as the bounds for the new solve.</li><li class="collection-item"><a href="source/auxkernels/VariableTimeIntegrationAux.html">VariableTimeIntegrationAux</a>Integrates a field variable in time.</li><li class="collection-item"><a href="source/auxkernels/VectorFunctionAux.html">VectorFunctionAux</a>Auxiliary Kernel that creates and updates a vector field variable by sampling a Function object, via the vectorValue method, through space and time.</li><li class="collection-item"><a href="source/auxkernels/VectorMagnitudeAux.html">VectorMagnitudeAux</a>Creates a field representing the magnitude of three coupled variables using an Euclidean norm.</li><li class="collection-item"><a href="source/auxkernels/VectorMaterialRealVectorValueAux.html">VectorMaterialRealVectorValueAux</a>Converts a vector-quantity material property into a vector auxiliary variable</li><li class="collection-item"><a href="source/auxkernels/VectorPostprocessorVisualizationAux.html">VectorPostprocessorVisualizationAux</a>Read values from a VectorPostprocessor that is producing vectors that are &#x27;number of processors&#x27; * in length.  Puts the value for each processor into an elemental auxiliary field.</li><li class="collection-item"><a href="source/auxkernels/VectorVariableComponentAux.html">VectorVariableComponentAux</a>Creates a field consisting of one component of a coupled vector variable.</li><li class="collection-item"><a href="source/auxkernels/VectorVariableMagnitudeAux.html">VectorVariableMagnitudeAux</a>Creates a field consisting of the magnitude of a coupled vector variable.</li><li class="collection-item"><a href="source/auxkernels/VolumeAux.html">VolumeAux</a>Auxiliary Kernel that samples volumes.</li><li class="collection-item"><a href="source/auxkernels/WeightedGapAux.html">WeightedGapAux</a>Returns the specified variable as an auxiliary variable with the same value.</li><li class="collection-header">Navier Stokes App</li><li class="collection-item"><a href="source/auxkernels/Courant.html">Courant</a>Computes |u| dt / h_min.</li><li class="collection-item"><a href="source/auxkernels/EnthalpyAux.html">EnthalpyAux</a>This AuxKernel computes the specific enthalpy of the fluidfrom the total energy and the pressure.</li><li class="collection-item"><a href="source/auxkernels/HasPorosityJumpFace.html">HasPorosityJumpFace</a>Shows whether an element has any attached porosity jump faces</li><li class="collection-item"><a href="source/auxkernels/INSCourant.html">INSCourant</a>Computes h_min / |u|.</li><li class="collection-item"><a href="source/auxkernels/INSFVMixingLengthTurbulentViscosityAux.html">INSFVMixingLengthTurbulentViscosityAux</a>Computes the turbulent viscosity for the mixing length model.</li><li class="collection-item"><a href="source/auxkernels/INSQCriterionAux.html">INSQCriterionAux</a>This class computes the Q criterion, a scalar whichaids in vortex identification in turbulent flows</li><li class="collection-item"><a href="source/auxkernels/INSStressComponentAux.html">INSStressComponentAux</a>This class computes the stress component based on pressure and velocity for incompressible Navier-Stokes</li><li class="collection-item"><a href="source/auxkernels/InternalEnergyAux.html">InternalEnergyAux</a>This AuxKernel computes the internal energy based on the equation of state / fluid properties and the local pressure and density.</li><li class="collection-item"><a href="source/auxkernels/NSInternalEnergyAux.html">NSInternalEnergyAux</a>Auxiliary kernel for computing the internal energy of the fluid.</li><li class="collection-item"><a href="source/auxkernels/NSLiquidFractionAux.html">NSLiquidFractionAux</a>Computes liquid fraction <span class="moose-katex-inline-equation" id="moose-equation-31801b7a-b72b-478f-9b00-bcd33d5f490a"><script>var element = document.getElementById("moose-equation-31801b7a-b72b-478f-9b00-bcd33d5f490a");katex.render("f_l", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> given the temperature.</li><li class="collection-item"><a href="source/auxkernels/NSMachAux.html">NSMachAux</a>Auxiliary kernel for computing the Mach number assuming an ideal gas.</li><li class="collection-item"><a href="source/auxkernels/NSPressureAux.html">NSPressureAux</a>Nodal auxiliary variable, for computing pressure at the nodes.</li><li class="collection-item"><a href="source/auxkernels/NSSpecificTotalEnthalpyAux.html">NSSpecificTotalEnthalpyAux</a>Nodal auxiliary variable, for computing enthalpy at the nodes.</li><li class="collection-item"><a href="source/auxkernels/NSTemperatureAux.html">NSTemperatureAux</a>Temperature is an auxiliary value computed from the total energy based on the FluidProperties.</li><li class="collection-item"><a href="source/auxkernels/NSVelocityAux.html">NSVelocityAux</a>Velocity auxiliary value.</li><li class="collection-item"><a href="source/auxkernels/PecletNumberFunctorAux.html">PecletNumberFunctorAux</a>Computes the Peclet number: u*L/alpha.</li><li class="collection-item"><a href="source/auxkernels/ReynoldsNumberFunctorAux.html">ReynoldsNumberFunctorAux</a>Computes rho*u*L/mu.</li><li class="collection-item"><a href="source/auxkernels/SpecificInternalEnergyAux.html">SpecificInternalEnergyAux</a>This AuxKernel computes the specific internal energy based from the total and the kinetic energy.</li><li class="collection-item"><a href="source/auxkernels/SpecificVolumeAux.html">SpecificVolumeAux</a>This auxkernel computes the specific volume <span class="moose-katex-inline-equation" id="moose-equation-82ef0a1d-330e-4254-af3f-2233d3dab39b"><script>var element = document.getElementById("moose-equation-82ef0a1d-330e-4254-af3f-2233d3dab39b");katex.render("v", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> of the fluid.</li><li class="collection-item"><a href="source/auxkernels/WallDistanceMixingLengthAux.html">WallDistanceMixingLengthAux</a>Computes the turbulent mixing length by assuming that it is proportional to the distance from the nearest wall. The mixinglength is capped at a distance proportional to inputted parameter delta.</li><li class="collection-item"><a href="source/auxkernels/WallFunctionWallShearStressAux.html">WallFunctionWallShearStressAux</a>Calculates the wall shear stress based on algebraic standard velocity wall functions.</li><li class="collection-item"><a href="source/auxkernels/WallFunctionYPlusAux.html">WallFunctionYPlusAux</a>Calculates y+ value according to the algebraic velocity standard wall function.</li><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/auxkernels/KineticEnergyAux.html">ADKineticEnergyAux</a>Compute the kinetic energy of continuum-based finite elements</li><li class="collection-item"><a href="source/auxkernels/RankFourAux.html">ADRankFourAux</a>Access a component of a RankFourTensor</li><li class="collection-item"><a href="source/auxkernels/RankTwoAux.html">ADRankTwoAux</a>Access a component of a RankTwoTensor</li><li class="collection-item"><a href="source/auxkernels/RankTwoScalarAux.html">ADRankTwoScalarAux</a>Compute a scalar property of a RankTwoTensor</li><li class="collection-item"><a href="source/auxkernels/AccumulateAux.html">AccumulateAux</a></li><li class="collection-item"><a href="source/auxkernels/CylindricalRankTwoAux.html">CylindricalRankTwoAux</a>Takes RankTwoTensor material and outputs component in cylindrical coordinates</li><li class="collection-item"><a href="source/auxkernels/DomainIntegralQFunction.html">DomainIntegralQFunction</a>Computes the q-function for a segment along the crack front, used in the calculation of the J-integral</li><li class="collection-item"><a href="source/auxkernels/DomainIntegralTopologicalQFunction.html">DomainIntegralTopologicalQFunction</a>Determines if a node is within the ring of the crack front defintion; this object is normally created by the DomainIntegralAction.</li><li class="collection-item"><a href="source/auxkernels/ElasticEnergyAux.html">ElasticEnergyAux</a>Compute the local elastic energy</li><li class="collection-item"><a href="source/auxkernels/GlobalDisplacementAux.html">GlobalDisplacementAux</a>AuxKernel to visualize the displacements generated by the global strain tensor</li><li class="collection-item"><a href="source/auxkernels/KineticEnergyAux.html">KineticEnergyAux</a>Compute the kinetic energy of continuum-based finite elements</li><li class="collection-item"><a href="source/auxkernels/NewmarkAccelAux.html">NewmarkAccelAux</a>Computes the current acceleration using the Newmark method.</li><li class="collection-item"><a href="source/auxkernels/NewmarkVelAux.html">NewmarkVelAux</a>Calculates the current velocity using Newmark method.</li><li class="collection-item"><a href="source/auxkernels/NodalPatchRecoveryAux.html">NodalPatchRecoveryAux</a>This Auxkernel solves a least squares problem at each node to fit a value from quantities defined on quadrature points.</li><li class="collection-item"><a href="source/auxkernels/RadialDisplacementCylinderAux.html">RadialDisplacementCylinderAux</a>Compute the radial component of the displacement vector for cylindrical models.</li><li class="collection-item"><a href="source/auxkernels/RadialDisplacementSphereAux.html">RadialDisplacementSphereAux</a>Compute the radial component of the displacement vector for spherical models.</li><li class="collection-item"><a href="source/auxkernels/RankFourAux.html">RankFourAux</a>Access a component of a RankFourTensor</li><li class="collection-item"><a href="source/auxkernels/RankTwoAux.html">RankTwoAux</a>Access a component of a RankTwoTensor</li><li class="collection-item"><a href="source/auxkernels/RankTwoScalarAux.html">RankTwoScalarAux</a>Compute a scalar property of a RankTwoTensor</li><li class="collection-item"><a href="source/auxkernels/RotationAngle.html">RotationAngle</a>Compute the field of angular rotations of points around an axis defined by an origin point and a direction vector</li><li class="collection-item"><a href="source/auxkernels/TestNewmarkTI.html">TestNewmarkTI</a>Assigns the velocity/acceleration calculated by time integrator to the velocity/acceleration auxvariable.</li><li class="collection-header">Heat Conduction App</li><li class="collection-item"><a href="source/auxkernels/JouleHeatingHeatGeneratedAux.html">JouleHeatingHeatGeneratedAux</a>Compute heat generated from Joule heating <span class="moose-katex-inline-equation" id="moose-equation-bc0c2e67-854e-4793-9448-78a952d49353"><script>var element = document.getElementById("moose-equation-bc0c2e67-854e-4793-9448-78a952d49353");katex.render("(d\\vec{P}/d\\vec{V} = \\vec{E}^2 \\sigma )", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-header">Fluid Properties App</li><li class="collection-item"><a href="source/auxkernels/FluidDensityAux.html">FluidDensityAux</a>Computes density from pressure and temperature</li><li class="collection-item"><a href="source/auxkernels/PressureAux.html">PressureAux</a>Computes pressure given specific volume and specific internal energy</li><li class="collection-item"><a href="source/auxkernels/SaturationTemperatureAux.html">SaturationTemperatureAux</a>Computes saturation temperature from pressure and 2-phase fluid properties object</li><li class="collection-item"><a href="source/auxkernels/SpecificEnthalpyAux.html">SpecificEnthalpyAux</a>Computes specific enthalpy from pressure and temperature</li><li class="collection-item"><a href="source/auxkernels/StagnationPressureAux.html">StagnationPressureAux</a>Computes stagnation pressure from specific volume, specific internal energy, and velocity</li><li class="collection-item"><a href="source/auxkernels/StagnationTemperatureAux.html">StagnationTemperatureAux</a>Computes stagnation temperature from specific volume, specific internal energy, and velocity</li><li class="collection-item"><a href="source/auxkernels/TemperatureAux.html">TemperatureAux</a>Computes temperature given specific volume and specific internal energy</li></ul></section><section class="scrollspy" id="0c6c9d05-4742-48f5-bc05-2a6bc72ee49d" data-section-level="2" data-section-text="Constraints"><h2 id="constraints"><a href="syntax/Constraints/index.html">Constraints</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddConstraintAction.html">AddConstraintAction</a>Add a Constraint object to the simulation.</li><li class="collection-item"><a href="source/constraints/PenaltyEqualValueConstraint.html">ADPenaltyEqualValueConstraint</a>PenaltyEqualValueConstraint enforces solution continuity between secondary and primary sides of a mortar interface using a penalty approach (no Lagrange multipliers needed)</li><li class="collection-item"><a href="source/constraints/ADPenaltyPeriodicSegmentalConstraint.html">ADPenaltyPeriodicSegmentalConstraint</a>ADPenaltyPeriodicSegmentalConstraint enforces macro-micro periodic conditions between secondary and primary sides of a mortar interface using a penalty approach (no Lagrange multipliers needed). Must be used alongside PenaltyEqualValueConstraint.</li><li class="collection-item"><a href="source/constraints/ADPeriodicSegmentalConstraint.html">ADPeriodicSegmentalConstraint</a>ADPeriodicSegmentalConstraint enforces macro-micro periodic conditions between secondary and primary sides of a mortar interface using Lagrange multipliers.Must be used alongside EqualValueConstraint.</li><li class="collection-item"><a href="source/constraints/CoupledTiedValueConstraint.html">CoupledTiedValueConstraint</a>Requires the value of two variables to be the consistent on both sides of an interface.</li><li class="collection-item"><a href="source/constraints/EqualGradientConstraint.html">EqualGradientConstraint</a>EqualGradientConstraint enforces continuity of a gradient component between secondary and primary sides of a mortar interface using lagrange multipliers</li><li class="collection-item"><a href="source/constraints/EqualValueBoundaryConstraint.html">EqualValueBoundaryConstraint</a>Constraint for enforcing that variables on each side of a boundary are equivalent.</li><li class="collection-item"><a href="source/constraints/EqualValueConstraint.html">EqualValueConstraint</a>EqualValueConstraint enforces solution continuity between secondary and primary sides of a mortar interface using lagrange multipliers</li><li class="collection-item"><a href="source/constraints/EqualValueEmbeddedConstraint.html">EqualValueEmbeddedConstraint</a>This is a constraint enforcing overlapping portions of two blocks to have the same variable value</li><li class="collection-item"><a href="source/constraints/LinearNodalConstraint.html">LinearNodalConstraint</a>Constrains secondary node to move as a linear combination of primary nodes.</li><li class="collection-item"><a href="source/constraints/OldEqualValueConstraint.html">OldEqualValueConstraint</a>OldEqualValueConstraint enforces solution continuity between secondary and primary sides of a mortar interface using lagrange multipliers</li><li class="collection-item"><a href="source/constraints/PenaltyEqualValueConstraint.html">PenaltyEqualValueConstraint</a>PenaltyEqualValueConstraint enforces solution continuity between secondary and primary sides of a mortar interface using a penalty approach (no Lagrange multipliers needed)</li><li class="collection-item"><a href="source/constraints/PenaltyPeriodicSegmentalConstraint.html">PenaltyPeriodicSegmentalConstraint</a>PenaltyPeriodicSegmentalConstraint enforces macro-micro periodic conditions between secondary and primary sides of a mortar interface using a penalty approach (no Lagrange multipliers needed). Must be used alongside PenaltyEqualValueConstraint.</li><li class="collection-item"><a href="source/constraints/PeriodicSegmentalConstraint.html">PeriodicSegmentalConstraint</a>PeriodicSegmentalConstraint enforces macro-micro periodic conditions between secondary and primary sides of a mortar interface using Lagrange multipliers.Must be used alongside EqualValueConstraint.</li><li class="collection-item"><a href="source/constraints/TiedValueConstraint.html">TiedValueConstraint</a>Constraint that forces the value of a variable to be the same on both sides of an interface.</li><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/constraints/NodalFrictionalConstraint.html">NodalFrictionalConstraint</a>Frictional nodal constraint for contact</li><li class="collection-item"><a href="source/constraints/NodalStickConstraint.html">NodalStickConstraint</a>Sticky nodal constraint for contact</li><li class="collection-header">Heat Conduction App</li><li class="collection-item"><a href="source/constraints/ADInterfaceJouleHeatingConstraint.html">ADInterfaceJouleHeatingConstraint</a>Joule heating model, for the case of a closed gap interface, to calculate the heat flux contribution created when an electric potential difference occurs across that interface.</li><li class="collection-item"><a href="source/constraints/GapConductanceConstraint.html">GapConductanceConstraint</a>Computes the residual and Jacobian contributions for the &#x27;Lagrange Multiplier&#x27; implementation of the thermal contact problem. For more information, see the detailed description here: http://tinyurl.com/gmmhbe9</li><li class="collection-item"><a href="source/constraints/ModularGapConductanceConstraint.html">ModularGapConductanceConstraint</a>Computes the residual and Jacobian contributions for the &#x27;Lagrange Multiplier&#x27; implementation of the thermal contact problem. For more information, see the detailed description here: http://tinyurl.com/gmmhbe9</li></ul></section><section class="scrollspy" id="bdfe1ee8-26dc-4d7f-84bb-e309d57c50b4" data-section-level="2" data-section-text="Controls"><h2 id="controls"><a href="syntax/Controls/index.html">Controls</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddControlAction.html">AddControlAction</a>Add a Control object to the simulation.</li><li class="collection-item"><a href="source/controls/BoolFunctionControl.html">BoolFunctionControl</a>Sets the value of a &#x27;bool&#x27; input parameters to the value of a provided function.</li><li class="collection-item"><a href="source/controls/ConditionalFunctionEnableControl.html">ConditionalFunctionEnableControl</a>Control for enabling/disabling objects when a function value is true</li><li class="collection-item"><a href="source/controls/PIDTransientControl.html">PIDTransientControl</a>Sets the value of a &#x27;Real&#x27; input parameter (or postprocessor) based on a Proportional Integral Derivative control of a postprocessor to match a target a target value.</li><li class="collection-item"><a href="source/controls/RealFunctionControl.html">RealFunctionControl</a>Sets the value of a &#x27;Real&#x27; input parameters to the value of a provided function.</li><li class="collection-item"><a href="source/controls/TimePeriod.html">TimePeriod</a>Control the enabled/disabled state of objects with time.</li><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/controls/StepPeriod.html">StepPeriod</a>Control the enabled/disabled state of objects with user-provided simulation steps.</li></ul></section><section class="scrollspy" id="3ef72d18-6843-4797-8fdb-98d7d338401a" data-section-level="2" data-section-text="DGKernels"><h2 id="dgkernels"><a href="syntax/DGKernels/index.html">DGKernels</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddDGKernelAction.html">AddDGKernelAction</a>Add a DGKernel object to the simulation.</li><li class="collection-item"><a href="source/dgkernels/ADDGDiffusion.html">ADDGDiffusion</a>DG kernel for diffusion operator</li><li class="collection-item"><a href="source/dgkernels/ArrayDGDiffusion.html">ArrayDGDiffusion</a>Implements interior penalty method for array diffusion equations.</li><li class="collection-item"><a href="source/dgkernels/ArrayHFEMDiffusion.html">ArrayHFEMDiffusion</a>Imposes the constraints on internal sides with HFEM.</li><li class="collection-item"><a href="source/dgkernels/DGConvection.html">DGConvection</a>DG upwinding for the convection</li><li class="collection-item"><a href="source/dgkernels/DGDiffusion.html">DGDiffusion</a>Computes residual contribution for the diffusion operator using discontinous Galerkin method.</li><li class="collection-item"><a href="source/dgkernels/HFEMDiffusion.html">HFEMDiffusion</a>Imposes the constraints on internal sides with HFEM.</li><li class="collection-item"><a href="source/dgkernels/HFEMTestJump.html">HFEMTestJump</a>Imposes constraints for HFEM with side-discontinuous variables.</li><li class="collection-item"><a href="source/dgkernels/HFEMTrialJump.html">HFEMTrialJump</a>Imposes constraints for HFEM with side-discontinuous variables.</li><li class="collection-header">Rdg App</li><li class="collection-item"><a href="source/dgkernels/AEFVKernel.html">AEFVKernel</a>A dgkernel for the advection equation using a cell-centered finite volume method.</li></ul></section><section class="scrollspy" id="ff9cba35-2c76-4dbc-b2bc-869452aa6db2" data-section-level="2" data-section-text="Dampers"><h2 id="dampers"><a href="syntax/Dampers/index.html">Dampers</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddDamperAction.html">AddDamperAction</a>Add a Damper object to the simulation.</li><li class="collection-item"><a href="source/dampers/BoundingValueElementDamper.html">BoundingValueElementDamper</a>This class implements a damper that limits the value of a variable to be within user-specified bounds.</li><li class="collection-item"><a href="source/dampers/BoundingValueNodalDamper.html">BoundingValueNodalDamper</a>Limits the value of a variable to be within user-specified bounds.</li><li class="collection-item"><a href="source/dampers/ConstantDamper.html">ConstantDamper</a>Modifies the non-linear step by applying a constant damping factor.</li><li class="collection-item"><a href="source/dampers/MaxIncrement.html">MaxIncrement</a>Limits a variable&#x27;s update by some max fraction</li><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/dampers/ElementJacobianDamper.html">ElementJacobianDamper</a>Damper that limits the change in element Jacobians</li><li class="collection-item"><a href="source/dampers/ReferenceElementJacobianDamper.html">ReferenceElementJacobianDamper</a>Damper that limits the change in element Jacobians</li></ul></section><section class="scrollspy" id="6c3c96fd-f647-4a62-a06c-b12070ec71d1" data-section-level="2" data-section-text="Debug"><h2 id="debug"><a href="syntax/Debug/index.html">Debug</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/SetupDebugAction.html">SetupDebugAction</a>Adds various debugging type output to the simulation system.</li><li class="collection-item"><a href="source/actions/SetupResidualDebugAction.html">SetupResidualDebugAction</a>Adds the necessary objects for computing the residuals for individual variables.</li><li class="collection-item"><a href="syntax/Debug/MaterialDerivativeTest/index.html">MaterialDerivativeTest</a></li></ul><section id="61c22f8e-cb70-44d4-ba18-08aa863a3a4e" data-section-level="3" data-section-text="Debug/MaterialDerivativeTest"><h3 id="debug/materialderivativetest"><a href="syntax/Debug/MaterialDerivativeTest/index.html">Debug/MaterialDerivativeTest</a></h3><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/MaterialDerivativeTestAction.html">MaterialDerivativeTestAction</a>Action for setting up the necessary objects for debugging material property derivatives.</li></ul></section></section><section class="scrollspy" id="96e33361-f57d-40d9-8877-814cece5041e" data-section-level="2" data-section-text="DeprecatedBlock"><h2 id="deprecatedblock"><a href="syntax/DeprecatedBlock/index.html">DeprecatedBlock</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/DeprecatedBlockAction.html">DeprecatedBlockAction</a>Tool for marking input syntax as deprecated.</li></ul></section><section class="scrollspy" id="d3266639-eb3d-45b8-830f-aac30585a5b1" data-section-level="2" data-section-text="DiracKernels"><h2 id="dirackernels"><a href="syntax/DiracKernels/index.html">DiracKernels</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddDiracKernelAction.html">AddDiracKernelAction</a>Add a DiracKernel object to the simulation.</li><li class="collection-item"><a href="source/dirackernels/ConstantPointSource.html">ConstantPointSource</a>Residual contribution of a constant point source term.</li><li class="collection-item"><a href="source/dirackernels/FunctionDiracSource.html">FunctionDiracSource</a>Residual contribution from a point source defined by a function.</li><li class="collection-item"><a href="source/dirackernels/ReporterPointSource.html">ReporterPointSource</a>Apply a point load defined by Reporter.</li><li class="collection-item"><a href="source/dirackernels/VectorConstantPointSource.html">VectorConstantPointSource</a>Residual contribution of a constant point source term.</li><li class="collection-header">Heat Conduction App</li><li class="collection-item"><a href="source/dirackernels/GapHeatPointSourceMaster.html">GapHeatPointSourceMaster</a></li></ul></section><section class="scrollspy" id="39fab3bb-3583-4b98-a05e-30e977e89f28" data-section-level="2" data-section-text="Distributions"><h2 id="distributions"><a href="syntax/Distributions/index.html">Distributions</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddDistributionAction.html">AddDistributionAction</a>Add a Distribution object to the simulation.</li></ul></section><section class="scrollspy" id="8a89bd14-a122-4d22-8dee-000394adbc6c" data-section-level="2" data-section-text="DomainIntegral"><h2 id="domainintegral"><a href="syntax/DomainIntegral/index.html">DomainIntegral</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/actions/DomainIntegralAction.html">DomainIntegralAction</a>Creates the MOOSE objects needed to compute fraction domain integrals</li></ul></section><section class="scrollspy" id="dd549210-517c-47f3-af6c-f154312a4689" data-section-level="2" data-section-text="Executioner"><h2 id="executioner"><a href="syntax/Executioner/index.html">Executioner</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/CreateExecutionerAction.html">CreateExecutionerAction</a>Add an Executioner object to the simulation.</li><li class="collection-item"><a href="source/executioners/Eigenvalue.html">Eigenvalue</a>Eigenvalue solves a standard/generalized linear or nonlinear eigenvalue problem</li><li class="collection-item"><a href="source/executioners/InversePowerMethod.html">InversePowerMethod</a>Inverse power method for eigenvalue problems.</li><li class="collection-item"><a href="source/executioners/NonlinearEigen.html">NonlinearEigen</a>Executioner for eigenvalue problems.</li><li class="collection-item"><a href="source/executioners/Steady.html">Steady</a>Executioner for steady-state simulations.</li><li class="collection-item"><a href="source/executioners/Transient.html">Transient</a>Executioner for time varying simulations.</li><li class="collection-item"><a href="syntax/Executioner/Adaptivity/index.html">Adaptivity</a></li><li class="collection-item"><a href="syntax/Executioner/Predictor/index.html">Predictor</a></li><li class="collection-item"><a href="syntax/Executioner/Quadrature/index.html">Quadrature</a></li><li class="collection-item"><a href="syntax/Executioner/TimeIntegrator/index.html">TimeIntegrator</a></li><li class="collection-item"><a href="syntax/Executioner/TimeStepper/index.html">TimeStepper</a></li><li class="collection-item"><a href="syntax/Executioner/TimeSteppers/index.html">TimeSteppers</a></li></ul><section id="4619ce8c-dbfc-426d-b1fd-b6222873515c" data-section-level="3" data-section-text="Executioner/Adaptivity"><h3 id="executioner/adaptivity"><a href="syntax/Executioner/Adaptivity/index.html">Executioner/Adaptivity</a></h3><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AdaptivityAction.html">AdaptivityAction</a>Add libMesh based adaptation schemes via the Executioner/Adaptivity input syntax.</li></ul></section><section id="5fdaa75d-e4a3-43a2-a9a1-514a23bed319" data-section-level="3" data-section-text="Executioner/Predictor"><h3 id="executioner/predictor"><a href="syntax/Executioner/Predictor/index.html">Executioner/Predictor</a></h3><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/SetupPredictorAction.html">SetupPredictorAction</a>Add a Predictor object to the simulation.</li><li class="collection-item"><a href="source/predictors/AdamsPredictor.html">AdamsPredictor</a>Implements an explicit Adams predictor based on two old solution vectors.</li><li class="collection-item"><a href="source/predictors/SimplePredictor.html">SimplePredictor</a>Algorithm that will predict the next solution based on previous solutions.</li></ul></section><section id="e6b8af9c-cb24-4e6a-b35f-624fabc70e73" data-section-level="3" data-section-text="Executioner/Quadrature"><h3 id="executioner/quadrature"><a href="syntax/Executioner/Quadrature/index.html">Executioner/Quadrature</a></h3><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/SetupQuadratureAction.html">SetupQuadratureAction</a>Sets the quadrature type for the simulation.</li></ul></section><section id="c4d276f3-9909-43ba-9421-0a20d141091d" data-section-level="3" data-section-text="Executioner/TimeIntegrator"><h3 id="executioner/timeintegrator"><a href="syntax/Executioner/TimeIntegrator/index.html">Executioner/TimeIntegrator</a></h3><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/SetupTimeIntegratorAction.html">SetupTimeIntegratorAction</a>Add a TimeIntegrator object to the simulation.</li><li class="collection-item"><a href="source/timeintegrators/AStableDirk4.html">AStableDirk4</a>Fourth-order diagonally implicit Runge Kutta method (Dirk) with three stages plus an update.</li><li class="collection-item"><a href="source/timeintegrators/ActuallyExplicitEuler.html">ActuallyExplicitEuler</a>Implementation of Explicit/Forward Euler without invoking any of the nonlinear solver</li><li class="collection-item"><a href="source/timeintegrators/BDF2.html">BDF2</a>Second order backward differentiation formula time integration scheme.</li><li class="collection-item"><a href="source/timeintegrators/CentralDifference.html">CentralDifference</a>Implementation of explicit, Central Difference integration without invoking any of the nonlinear solver</li><li class="collection-item"><a href="source/timeintegrators/CrankNicolson.html">CrankNicolson</a>Crank-Nicolson time integrator.</li><li class="collection-item"><a href="source/timeintegrators/ExplicitEuler.html">ExplicitEuler</a>Time integration using the explicit Euler method.</li><li class="collection-item"><a href="source/timeintegrators/ExplicitMidpoint.html">ExplicitMidpoint</a>Time integration using the explicit midpoint method.</li><li class="collection-item"><a href="source/timeintegrators/ExplicitSSPRungeKutta.html">ExplicitSSPRungeKutta</a>Explicit strong stability preserving Runge-Kutta methods</li><li class="collection-item"><a href="source/timeintegrators/ExplicitTVDRK2.html">ExplicitTVDRK2</a>Explicit TVD (total-variation-diminishing) second-order Runge-Kutta time integration method.</li><li class="collection-item"><a href="source/timeintegrators/Heun.html">Heun</a>Heun&#x27;s (aka improved Euler) time integration method.</li><li class="collection-item"><a href="source/timeintegrators/ImplicitEuler.html">ImplicitEuler</a>Time integration using the implicit Euler method.</li><li class="collection-item"><a href="source/timeintegrators/ImplicitMidpoint.html">ImplicitMidpoint</a>Second-order Runge-Kutta (implicit midpoint) time integration.</li><li class="collection-item"><a href="source/timeintegrators/LStableDirk2.html">LStableDirk2</a>Second order diagonally implicit Runge Kutta method (Dirk) with two stages.</li><li class="collection-item"><a href="source/timeintegrators/LStableDirk3.html">LStableDirk3</a>Third order diagonally implicit Runge Kutta method (Dirk) with three stages.</li><li class="collection-item"><a href="source/timeintegrators/LStableDirk4.html">LStableDirk4</a>Fourth-order diagonally implicit Runge Kutta method (Dirk) with five stages.</li><li class="collection-item"><a href="source/timeintegrators/NewmarkBeta.html">NewmarkBeta</a>Computes the first and second time derivative of variable using Newmark-Beta method.</li><li class="collection-item"><a href="source/timeintegrators/Ralston.html">Ralston</a>Ralston&#x27;s time integration method.</li></ul></section><section id="024913c1-fcfe-4d24-a7d9-8b3ae4964206" data-section-level="3" data-section-text="Executioner/TimeStepper"><h3 id="executioner/timestepper"><a href="syntax/Executioner/TimeStepper/index.html">Executioner/TimeStepper</a></h3><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddTimeStepperAction.html">AddTimeStepperAction</a>Add a TimeStepper object to the simulation.</li><li class="collection-item"><a href="source/timesteppers/AB2PredictorCorrector.html">AB2PredictorCorrector</a>Implements second order Adams-Bashforth method for timestep calculation.</li><li class="collection-item"><a href="source/timesteppers/CSVTimeSequenceStepper.html">CSVTimeSequenceStepper</a>Solves the Transient problem at a sequence of given time points read in a file.</li><li class="collection-item"><a href="source/timesteppers/CompositionDT.html">CompositionDT</a>The time stepper take all the other time steppers as input and return the minimum time step size.</li><li class="collection-item"><a href="source/timesteppers/ConstantDT.html">ConstantDT</a>Timestepper that takes a constant time step size</li><li class="collection-item"><a href="source/timesteppers/ExodusTimeSequenceStepper.html">ExodusTimeSequenceStepper</a>Solves the Transient problem at a sequence of time points taken from a specified exodus file.</li><li class="collection-item"><a href="source/timesteppers/FunctionDT.html">FunctionDT</a>Timestepper whose steps vary over time according to a user-defined function</li><li class="collection-item"><a href="source/timesteppers/IterationAdaptiveDT.html">IterationAdaptiveDT</a>Adjust the timestep based on the number of iterations</li><li class="collection-item"><a href="source/timesteppers/LogConstantDT.html">LogConstantDT</a>TimeStepper which imposes a time step constant in the logarithmic space</li><li class="collection-item"><a href="source/timesteppers/PostprocessorDT.html">PostprocessorDT</a>Computes timestep based on a Postprocessor value.</li><li class="collection-item"><a href="source/timesteppers/SolutionTimeAdaptiveDT.html">SolutionTimeAdaptiveDT</a>Compute simulation timestep based on actual solution time.</li><li class="collection-item"><a href="source/timesteppers/TimeSequenceFromTimes.html">TimeSequenceFromTimes</a>Solves the Transient problem at a sequence of time points taken from a specified Times object.</li><li class="collection-item"><a href="source/timesteppers/TimeSequenceStepper.html">TimeSequenceStepper</a>Solves the Transient problem at a sequence of given time points.</li></ul></section><section id="996623a7-6443-4f23-9468-c9553977c1b1" data-section-level="3" data-section-text="Executioner/TimeSteppers"><h3 id="executioner/timesteppers"><a href="syntax/Executioner/TimeSteppers/index.html">Executioner/TimeSteppers</a></h3><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/ComposeTimeStepperAction.html">ComposeTimeStepperAction</a>Add the composition time stepper if multiple time steppers have been created.</li><li class="collection-item"><a href="source/actions/AddTimeStepperAction.html">AddTimeStepperAction</a>Add a TimeStepper object to the simulation.</li><li class="collection-item"><a href="source/timesteppers/AB2PredictorCorrector.html">AB2PredictorCorrector</a>Implements second order Adams-Bashforth method for timestep calculation.</li><li class="collection-item"><a href="source/timesteppers/CSVTimeSequenceStepper.html">CSVTimeSequenceStepper</a>Solves the Transient problem at a sequence of given time points read in a file.</li><li class="collection-item"><a href="source/timesteppers/CompositionDT.html">CompositionDT</a>The time stepper take all the other time steppers as input and return the minimum time step size.</li><li class="collection-item"><a href="source/timesteppers/ConstantDT.html">ConstantDT</a>Timestepper that takes a constant time step size</li><li class="collection-item"><a href="source/timesteppers/ExodusTimeSequenceStepper.html">ExodusTimeSequenceStepper</a>Solves the Transient problem at a sequence of time points taken from a specified exodus file.</li><li class="collection-item"><a href="source/timesteppers/FunctionDT.html">FunctionDT</a>Timestepper whose steps vary over time according to a user-defined function</li><li class="collection-item"><a href="source/timesteppers/IterationAdaptiveDT.html">IterationAdaptiveDT</a>Adjust the timestep based on the number of iterations</li><li class="collection-item"><a href="source/timesteppers/LogConstantDT.html">LogConstantDT</a>TimeStepper which imposes a time step constant in the logarithmic space</li><li class="collection-item"><a href="source/timesteppers/PostprocessorDT.html">PostprocessorDT</a>Computes timestep based on a Postprocessor value.</li><li class="collection-item"><a href="source/timesteppers/SolutionTimeAdaptiveDT.html">SolutionTimeAdaptiveDT</a>Compute simulation timestep based on actual solution time.</li><li class="collection-item"><a href="source/timesteppers/TimeSequenceFromTimes.html">TimeSequenceFromTimes</a>Solves the Transient problem at a sequence of time points taken from a specified Times object.</li><li class="collection-item"><a href="source/timesteppers/TimeSequenceStepper.html">TimeSequenceStepper</a>Solves the Transient problem at a sequence of given time points.</li></ul></section></section><section class="scrollspy" id="09dcb902-5a30-44ff-ae60-368cd5e65cac" data-section-level="2" data-section-text="Executors"><h2 id="executors"><a href="syntax/Executors/index.html">Executors</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/ReadExecutorParamsAction.html">ReadExecutorParamsAction</a>Add an Executor object to the simulation.</li><li class="collection-item"><a href="source/executors/NullExecutor.html">NullExecutor</a>Dummy executor that does nothing. Useful for testing among other things.</li></ul></section><section class="scrollspy" id="0ac97f4f-e430-4f06-93c4-3f7e1a9a157c" data-section-level="2" data-section-text="FVBCs"><h2 id="fvbcs"><a href="syntax/FVBCs/index.html">FVBCs</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/CheckFVBCAction.html">CheckFVBCAction</a>Check that boundary conditions are defined correctly for finite volume problems.</li><li class="collection-item"><a href="source/actions/AddFVBCAction.html">AddFVBCAction</a>Add a FVBoundaryCondition object to the simulation.</li><li class="collection-item"><a href="source/fvbcs/FVFunctorDirichletBC.html">FVADFunctorDirichletBC</a>Uses the value of a functor to set a Dirichlet boundary value.</li><li class="collection-item"><a href="source/fvbcs/FVBoundaryIntegralValueConstraint.html">FVBoundaryIntegralValueConstraint</a>This class is used to enforce integral of phi = boundary area * phi_0 with a Lagrange multiplier approach.</li><li class="collection-item"><a href="source/fvbcs/FVConstantScalarOutflowBC.html">FVConstantScalarOutflowBC</a>Constant velocity scalar advection boundary conditions for finite volume method.</li><li class="collection-item"><a href="source/fvbcs/FVDirichletBC.html">FVDirichletBC</a>Defines a Dirichlet boundary condition for finite volume method.</li><li class="collection-item"><a href="source/fvbcs/FVFunctionDirichletBC.html">FVFunctionDirichletBC</a>Imposes the essential boundary condition <span class="moose-katex-inline-equation" id="moose-equation-d5630255-46a0-4093-b27e-06bd782991a7"><script>var element = document.getElementById("moose-equation-d5630255-46a0-4093-b27e-06bd782991a7");katex.render("u=g(t,\\vec{x})", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-5d12839c-8ea4-47fd-bd09-d5372a87cb2d"><script>var element = document.getElementById("moose-equation-5d12839c-8ea4-47fd-bd09-d5372a87cb2d");katex.render("g", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is a (possibly) time and space-dependent MOOSE Function.</li><li class="collection-item"><a href="source/fvbcs/FVFunctionNeumannBC.html">FVFunctionNeumannBC</a>Neumann boundary condition for finite volume method.</li><li class="collection-item"><a href="source/fvbcs/FVFunctorDirichletBC.html">FVFunctorDirichletBC</a>Uses the value of a functor to set a Dirichlet boundary value.</li><li class="collection-item"><a href="source/fvbcs/FVFunctorNeumannBC.html">FVFunctorNeumannBC</a>Neumann boundary condition for the finite volume method.</li><li class="collection-item"><a href="source/fvbcs/FVNeumannBC.html">FVNeumannBC</a>Neumann boundary condition for finite volume method.</li><li class="collection-item"><a href="source/fvbcs/FVOrthogonalBoundaryDiffusion.html">FVOrthogonalBoundaryDiffusion</a>Imposes an orthogonal diffusion boundary term with specified boundary function.</li><li class="collection-item"><a href="source/fvbcs/FVPostprocessorDirichletBC.html">FVPostprocessorDirichletBC</a>Defines a Dirichlet boundary condition for finite volume method.</li><li class="collection-header">Navier Stokes App</li><li class="collection-item"><a href="source/fvbcs/CNSFVHLLCFluidEnergyImplicitBC.html">CNSFVHLLCFluidEnergyImplicitBC</a>Implements an implicit advective boundary flux for the fluid energy equation for an HLLC discretization</li><li class="collection-item"><a href="source/fvbcs/CNSFVHLLCFluidEnergyStagnationInletBC.html">CNSFVHLLCFluidEnergyStagnationInletBC</a>Adds the boundary fluid energy flux for HLLC when provided stagnation temperature and pressure</li><li class="collection-item"><a href="source/fvbcs/CNSFVHLLCMassImplicitBC.html">CNSFVHLLCMassImplicitBC</a>Implements an implicit advective boundary flux for the mass equation for an HLLC discretization</li><li class="collection-item"><a href="source/fvbcs/CNSFVHLLCMassStagnationInletBC.html">CNSFVHLLCMassStagnationInletBC</a>Adds the boundary mass flux for HLLC when provided stagnation temperature and pressure</li><li class="collection-item"><a href="source/fvbcs/CNSFVHLLCMomentumImplicitBC.html">CNSFVHLLCMomentumImplicitBC</a>Implements an implicit advective boundary flux for the momentum equation for an HLLC discretization</li><li class="collection-item"><a href="source/fvbcs/CNSFVHLLCMomentumSpecifiedPressureBC.html">CNSFVHLLCMomentumSpecifiedPressureBC</a>Implements an HLLC boundary condition for the momentum conservation equation in which the pressure is specified.</li><li class="collection-item"><a href="source/fvbcs/CNSFVHLLCMomentumStagnationInletBC.html">CNSFVHLLCMomentumStagnationInletBC</a>Adds the boundary momentum flux for HLLC when provided stagnation temperature and pressure</li><li class="collection-item"><a href="source/fvbcs/CNSFVHLLCFluidEnergyBC.html">CNSFVHLLCSpecifiedMassFluxAndTemperatureFluidEnergyBC</a>Implements the fluid energy boundary flux portion of the free-flow HLLC discretization given specified mass fluxes and fluid temperature</li><li class="collection-item"><a href="source/fvbcs/CNSFVHLLCMassBC.html">CNSFVHLLCSpecifiedMassFluxAndTemperatureMassBC</a>Implements the mass boundary flux portion of the free-flow HLLC discretization given specified mass fluxes and fluid temperature</li><li class="collection-item"><a href="source/fvbcs/CNSFVHLLCMomentumBC.html">CNSFVHLLCSpecifiedMassFluxAndTemperatureMomentumBC</a>Implements the momentum boundary flux portion of the free-flow HLLC discretization given specified mass fluxes and fluid temperature</li><li class="collection-item"><a href="source/fvbcs/CNSFVHLLCFluidEnergyBC.html">CNSFVHLLCSpecifiedPressureFluidEnergyBC</a>Implements the fluid energy boundary flux portion of the free-flow HLLC discretization given specified pressure</li><li class="collection-item"><a href="source/fvbcs/CNSFVHLLCMassBC.html">CNSFVHLLCSpecifiedPressureMassBC</a>Implements the mass boundary flux portion of the free-flow HLLC discretization given specified pressure</li><li class="collection-item"><a href="source/fvbcs/CNSFVHLLCMomentumBC.html">CNSFVHLLCSpecifiedPressureMomentumBC</a>Implements the momentum boundary flux portion of the free-flow HLLC discretization given specified pressure</li><li class="collection-item"><a href="source/fvbcs/CNSFVMomImplicitPressureBC.html">CNSFVMomImplicitPressureBC</a>Adds an implicit pressure flux contribution on the boundary using interior cell information</li><li class="collection-item"><a href="source/fvbcs/INSFVAveragePressureValueBC.html">INSFVAveragePressureValueBC</a>This class is used to enforce integral of phi = boundary area * phi_0 with a Lagrange multiplier approach.</li><li class="collection-item"><a href="source/fvbcs/INSFVInletVelocityBC.html">INSFVInletVelocityBC</a>Imposes the essential boundary condition <span class="moose-katex-inline-equation" id="moose-equation-bc2b4388-7140-45be-a1d3-51cab9fcba94"><script>var element = document.getElementById("moose-equation-bc2b4388-7140-45be-a1d3-51cab9fcba94");katex.render("u=g(t,\\vec{x})", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-f4bc256d-69cf-477b-867c-211ca347169a"><script>var element = document.getElementById("moose-equation-f4bc256d-69cf-477b-867c-211ca347169a");katex.render("g", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is a (possibly) time and space-dependent MOOSE Function.</li><li class="collection-item"><a href="source/fvbcs/INSFVMassAdvectionOutflowBC.html">INSFVMassAdvectionOutflowBC</a>Outflow boundary condition for advecting mass.</li><li class="collection-item"><a href="source/fvbcs/INSFVMomentumAdvectionOutflowBC.html">INSFVMomentumAdvectionOutflowBC</a>Fully developed outflow boundary condition for advecting momentum. This will impose a zero normal gradient on the boundary velocity.</li><li class="collection-item"><a href="source/fvbcs/INSFVNaturalFreeSlipBC.html">INSFVNaturalFreeSlipBC</a>Implements a free slip boundary condition naturally.</li><li class="collection-item"><a href="source/fvbcs/INSFVNoSlipWallBC.html">INSFVNoSlipWallBC</a>Implements a no slip boundary condition.</li><li class="collection-item"><a href="source/fvbcs/INSFVOutletPressureBC.html">INSFVOutletPressureBC</a>Defines a Dirichlet boundary condition for finite volume method.</li><li class="collection-item"><a href="source/fvbcs/INSFVSymmetryPressureBC.html">INSFVSymmetryPressureBC</a>Though not applied to velocity, this object ensures that the flux (velocity times the advected quantity) into a symmetry boundary is zero. When applied to pressure for the mass equation, this makes the normal velocity zero since density is constant</li><li class="collection-item"><a href="source/fvbcs/INSFVSymmetryPressureBC.html">INSFVSymmetryScalarBC</a>Though not applied to velocity, this object ensures that the flux (velocity times the advected quantity) into a symmetry boundary is zero. When applied to pressure for the mass equation, this makes the normal velocity zero since density is constant</li><li class="collection-item"><a href="source/fvbcs/INSFVSymmetryVelocityBC.html">INSFVSymmetryVelocityBC</a>Implements a symmetry boundary condition for the velocity.</li><li class="collection-item"><a href="source/fvbcs/INSFVWallFunctionBC.html">INSFVWallFunctionBC</a>Implements a wall shear BC for the momentum equation based on algebraic standard velocity wall functions.</li><li class="collection-item"><a href="source/fvbcs/NSFVFunctorHeatFluxBC.html">NSFVFunctorHeatFluxBC</a>Constant heat flux boundary condition with phase splitting for fluid and solid energy equations</li><li class="collection-item"><a href="source/fvbcs/NSFVHeatFluxBC.html">NSFVHeatFluxBC</a>Constant heat flux boundary condition with phase splitting for fluid and solid energy equations</li><li class="collection-item"><a href="source/fvbcs/NSFVOutflowTemperatureBC.html">NSFVOutflowTemperatureBC</a>Outflow velocity temperature advection boundary conditions for finite volume method allowing for thermal backflow.</li><li class="collection-item"><a href="source/fvbcs/PCNSFVHLLCFluidEnergyBC.html">PCNSFVHLLCSpecifiedMassFluxAndTemperatureFluidEnergyBC</a>Implements the fluid energy boundary flux portion of the porous HLLC discretization given specified mass fluxes and fluid temperature</li><li class="collection-item"><a href="source/fvbcs/PCNSFVHLLCMassBC.html">PCNSFVHLLCSpecifiedMassFluxAndTemperatureMassBC</a>Implements the mass boundary flux portion of the porous HLLC discretization given specified mass fluxes and fluid temperature</li><li class="collection-item"><a href="source/fvbcs/PCNSFVHLLCMomentumBC.html">PCNSFVHLLCSpecifiedMassFluxAndTemperatureMomentumBC</a>Implements the momentum boundary flux portion of the porous HLLC discretization given specified mass fluxes and fluid temperature</li><li class="collection-item"><a href="source/fvbcs/PCNSFVHLLCFluidEnergyBC.html">PCNSFVHLLCSpecifiedPressureFluidEnergyBC</a>Implements the fluid energy boundary flux portion of the porous HLLC discretization given specified pressure</li><li class="collection-item"><a href="source/fvbcs/PCNSFVHLLCMassBC.html">PCNSFVHLLCSpecifiedPressureMassBC</a>Implements the mass boundary flux portion of the porous HLLC discretization given specified pressure</li><li class="collection-item"><a href="source/fvbcs/PCNSFVHLLCMomentumBC.html">PCNSFVHLLCSpecifiedPressureMomentumBC</a>Implements the momentum boundary flux portion of the porous HLLC discretization given specified pressure</li><li class="collection-item"><a href="source/fvbcs/PCNSFVImplicitMomentumPressureBC.html">PCNSFVImplicitMomentumPressureBC</a>Specifies an implicit pressure at a boundary for the momentum equations.</li><li class="collection-item"><a href="source/fvbcs/PCNSFVStrongBC.html">PCNSFVStrongBC</a>Computes the residual of advective term using finite volume method.</li><li class="collection-item"><a href="source/fvbcs/PINSFVMomentumAdvectionOutflowBC.html">PINSFVMomentumAdvectionOutflowBC</a>Outflow boundary condition for advecting momentum in the porous media momentum equation. This will impose a zero normal gradient on the boundary velocity.</li><li class="collection-item"><a href="source/fvbcs/PINSFVSymmetryVelocityBC.html">PINSFVSymmetryVelocityBC</a>Implements a symmetry boundary condition for the velocity.</li><li class="collection-item"><a href="source/fvbcs/PWCNSFVMomentumFluxBC.html">PWCNSFVMomentumFluxBC</a>Flux boundary conditions for porous momentum advection.</li><li class="collection-item"><a href="source/fvbcs/WCNSFVEnergyFluxBC.html">WCNSFVEnergyFluxBC</a>Flux boundary conditions for energy advection.</li><li class="collection-item"><a href="source/fvbcs/WCNSFVInletTemperatureBC.html">WCNSFVInletTemperatureBC</a>Defines a Dirichlet boundary condition for finite volume method.</li><li class="collection-item"><a href="source/fvbcs/WCNSFVInletVelocityBC.html">WCNSFVInletVelocityBC</a>Defines a Dirichlet boundary condition for finite volume method.</li><li class="collection-item"><a href="source/fvbcs/WCNSFVMassFluxBC.html">WCNSFVMassFluxBC</a>Flux boundary conditions for mass advection.</li><li class="collection-item"><a href="source/fvbcs/WCNSFVMomentumFluxBC.html">WCNSFVMomentumFluxBC</a>Flux boundary conditions for momentum advection.</li><li class="collection-item"><a href="source/fvbcs/WCNSFVScalarFluxBC.html">WCNSFVScalarFluxBC</a>Flux boundary conditions for scalar quantity advection.</li><li class="collection-header">Heat Conduction App</li><li class="collection-item"><a href="source/fvbcs/FVFunctorConvectiveHeatFluxBC.html">FVFunctorConvectiveHeatFluxBC</a>Convective heat transfer boundary condition with temperature and heat transfer coefficient given by functors.</li><li class="collection-item"><a href="source/fvbcs/FVInfiniteCylinderRadiativeBC.html">FVInfiniteCylinderRadiativeBC</a>Boundary condition for radiative heat exchange with a cylinder where the boundary is approximated as a cylinder as well.</li><li class="collection-item"><a href="source/fvbcs/FVThermalResistanceBC.html">FVThermalResistanceBC</a>Thermal resistance Heat flux boundary condition for the fluid and solid energy equations</li><li class="collection-item"><a href="source/fvbcs/FunctorThermalResistanceBC.html">FunctorThermalResistanceBC</a>Thermal resistance heat flux boundary condition for the fluid and solid energy equations</li></ul></section><section class="scrollspy" id="03e9f153-924e-4937-882d-0d78cf7d27c7" data-section-level="2" data-section-text="FVInterfaceKernels"><h2 id="fvinterfacekernels"><a href="syntax/FVInterfaceKernels/index.html">FVInterfaceKernels</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddFVInterfaceKernelAction.html">AddFVInterfaceKernelAction</a>Add a FVInterfaceKernel object to the simulation.</li><li class="collection-item"><a href="source/fviks/FVDiffusionInterface.html">FVDiffusionInterface</a>Computes the residual for diffusion operator across an interface for the finite volume method.</li><li class="collection-item"><a href="source/fviks/FVOneVarDiffusionInterface.html">FVOneVarDiffusionInterface</a>Computes residual for diffusion operator across an interface for finite volume method.</li><li class="collection-item"><a href="source/fviks/FVTwoVarContinuityConstraint.html">FVTwoVarContinuityConstraint</a>Forces two variables to be equal on an interface for the finite volume method.</li><li class="collection-header">Navier Stokes App</li><li class="collection-item"><a href="source/fviks/FVConvectionCorrelationInterface.html">FVConvectionCorrelationInterface</a>Computes the residual for a convective heat transfer across an interface for the finite volume method, using a correlation for the heat transfer coefficient.</li></ul></section><section class="scrollspy" id="a4a75dbb-3a1b-4d8d-9e0b-4a0b80452d82" data-section-level="2" data-section-text="FVKernels"><h2 id="fvkernels"><a href="syntax/FVKernels/index.html">FVKernels</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddFVKernelAction.html">AddFVKernelAction</a>Add a FVKernel object to the simulation.</li><li class="collection-item"><a href="source/fvkernels/FVAdvection.html">FVAdvection</a>Residual contribution from advection operator for finite volume method.</li><li class="collection-item"><a href="source/fvkernels/FVAnisotropicDiffusion.html">FVAnisotropicDiffusion</a>Computes residual for anisotropic diffusion operator for finite volume method.</li><li class="collection-item"><a href="source/fvkernels/FVBodyForce.html">FVBodyForce</a>Demonstrates the multiple ways that scalar values can be introduced into finite volume kernels, e.g. (controllable) constants, functions, and postprocessors.</li><li class="collection-item"><a href="source/fvkernels/FVBoundedValueConstraint.html">FVBoundedValueConstraint</a>This class is used to enforce a min or max value for a finite volume variable</li><li class="collection-item"><a href="source/fvkernels/FVCoupledForce.html">FVCoupledForce</a>Implements a source term proportional to the value of a coupled variable.</li><li class="collection-item"><a href="source/fvkernels/FVDiffusion.html">FVDiffusion</a>Computes residual for diffusion operator for finite volume method.</li><li class="collection-item"><a href="source/fvkernels/FVFunctorTimeKernel.html">FVFunctorTimeKernel</a>Residual contribution from time derivative of an AD functor (default is the variable this kernel is acting upon if the &#x27;functor&#x27; parameter is not supplied)  for the finite volume method.</li><li class="collection-item"><a href="source/fvkernels/FVIntegralValueConstraint.html">FVIntegralValueConstraint</a>This class is used to enforce integral of phi = volume * phi_0 with a Lagrange multiplier approach.</li><li class="collection-item"><a href="source/fvkernels/FVMatAdvection.html">FVMatAdvection</a>Computes the residual of advective term using finite volume method.</li><li class="collection-item"><a href="source/fvkernels/FVOrthogonalDiffusion.html">FVOrthogonalDiffusion</a>Imposes an orthogonal diffusion term.</li><li class="collection-item"><a href="source/fvkernels/FVPointValueConstraint.html">FVPointValueConstraint</a>This class is used to enforce integral of phi = volume * phi_0 with a Lagrange multiplier approach.</li><li class="collection-item"><a href="source/fvkernels/FVReaction.html">FVReaction</a>Simple consuming reaction term</li><li class="collection-item"><a href="source/fvkernels/FVIntegralValueConstraint.html">FVScalarLagrangeMultiplier</a>This class is used to enforce integral of phi = volume * phi_0 with a Lagrange multiplier approach.</li><li class="collection-item"><a href="source/fvkernels/FVTimeKernel.html">FVTimeKernel</a>Residual contribution from time derivative of a variable for the finite volume method.</li><li class="collection-header">Navier Stokes App</li><li class="collection-item"><a href="source/fvkernels/CNSFVFluidEnergyHLLC.html">CNSFVFluidEnergyHLLC</a>Implements the fluid energy flux portion of the free-flow HLLC discretization.</li><li class="collection-item"><a href="source/fvkernels/CNSFVMassHLLC.html">CNSFVMassHLLC</a>Implements the mass flux portion of the free-flow HLLC discretization.</li><li class="collection-item"><a href="source/fvkernels/CNSFVMomentumHLLC.html">CNSFVMomentumHLLC</a>Implements the momentum flux portion of the free-flow HLLC discretization.</li><li class="collection-item"><a href="source/fvkernels/FVMatPropTimeKernel.html">FVMatPropTimeKernel</a>Returns a material property which should correspond to a time derivative.</li><li class="collection-item"><a href="source/fvkernels/FVPorosityTimeDerivative.html">FVPorosityTimeDerivative</a>A time derivative multiplied by a porosity material property</li><li class="collection-item"><a href="source/fvkernels/INSFVBodyForce.html">INSFVBodyForce</a>Body force that contributes to the Rhie-Chow interpolation</li><li class="collection-item"><a href="source/fvkernels/INSFVEnergyAdvection.html">INSFVEnergyAdvection</a>Advects energy, e.g. rho*cp*T. A user may still override what quantity is advected, but the default is rho*cp*T</li><li class="collection-item"><a href="source/fvkernels/INSFVEnergyTimeDerivative.html">INSFVEnergyTimeDerivative</a>Adds the time derivative term to the incompressible Navier-Stokes energy equation.</li><li class="collection-item"><a href="source/fvkernels/INSFVMassAdvection.html">INSFVMassAdvection</a>Object for advecting mass, e.g. rho</li><li class="collection-item"><a href="source/fvkernels/INSFVMixingLengthReynoldsStress.html">INSFVMixingLengthReynoldsStress</a>Computes the force due to the Reynolds stress term in the incompressible Reynolds-averaged Navier-Stokes equations.</li><li class="collection-item"><a href="source/fvkernels/INSFVMixingLengthScalarDiffusion.html">INSFVMixingLengthScalarDiffusion</a>Computes the turbulent diffusive flux that appears in Reynolds-averaged fluid conservation equations.</li><li class="collection-item"><a href="source/fvkernels/INSFVMomentumAdvection.html">INSFVMomentumAdvection</a>Object for advecting momentum, e.g. rho*u</li><li class="collection-item"><a href="source/fvkernels/INSFVMomentumBoussinesq.html">INSFVMomentumBoussinesq</a>Computes a body force for natural convection buoyancy.</li><li class="collection-item"><a href="source/fvkernels/INSFVMomentumDiffusion.html">INSFVMomentumDiffusion</a>Implements the Laplace form of the viscous stress in the Navier-Stokes equation.</li><li class="collection-item"><a href="source/fvkernels/INSFVMomentumFriction.html">INSFVMomentumFriction</a>Implements a basic linear or quadratic friction model as a volumetric force, for example for the X-momentum equation: <span class="moose-katex-inline-equation" id="moose-equation-a5673b8b-2164-4141-81e8-a7d5485a187c"><script>var element = document.getElementById("moose-equation-a5673b8b-2164-4141-81e8-a7d5485a187c");katex.render("F_x = - C_l * v_x", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-79827124-e46c-4185-9417-1bcb8969e7b0"><script>var element = document.getElementById("moose-equation-79827124-e46c-4185-9417-1bcb8969e7b0");katex.render("F_x = - C_q * v_x * |v_x|", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> for the linear and quadratic models respectively. A linear dependence is expected for laminar flow, while a quadratic dependence is more common for turbulent flow.</li><li class="collection-item"><a href="source/fvkernels/INSFVMomentumGravity.html">INSFVMomentumGravity</a>Computes a body force due to gravity in Rhie-Chow based simulations.</li><li class="collection-item"><a href="source/fvkernels/INSFVMomentumPressure.html">INSFVMomentumPressure</a>Introduces the coupled pressure term into the Navier-Stokes momentum equation.</li><li class="collection-item"><a href="source/fvkernels/INSFVMomentumTimeDerivative.html">INSFVMomentumTimeDerivative</a>Adds the time derivative term to the incompressible Navier-Stokes momentum equation.</li><li class="collection-item"><a href="source/fvkernels/INSFVScalarFieldAdvection.html">INSFVScalarFieldAdvection</a>Advects an arbitrary quantity, the associated nonlinear &#x27;variable&#x27;.</li><li class="collection-item"><a href="source/fvkernels/NSFVEnergyAmbientConvection.html">NSFVEnergyAmbientConvection</a>Implements a solid-fluid ambient convection volumetric term proportional to the difference between the fluid and ambient temperatures : <span class="moose-katex-inline-equation" id="moose-equation-be6b4f6d-a6ba-4aef-8fe9-58670a6f01d3"><script>var element = document.getElementById("moose-equation-be6b4f6d-a6ba-4aef-8fe9-58670a6f01d3");katex.render("q''' = \\alpha (T_{fluid} - T_{ambient})", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/fvkernels/NSFVPhaseChangeSource.html">NSFVPhaseChangeSource</a>Computes the energy source due to solidification/melting.</li><li class="collection-item"><a href="source/fvkernels/PCNSFVDensityTimeDerivative.html">PCNSFVDensityTimeDerivative</a>A time derivative kernel for which the form is eps * ddt(rho*var).</li><li class="collection-item"><a href="source/fvkernels/PCNSFVFluidEnergyHLLC.html">PCNSFVFluidEnergyHLLC</a>Implements the fluid energy flux portion of the porous HLLC discretization.</li><li class="collection-item"><a href="source/fvkernels/PCNSFVKT.html">PCNSFVKT</a>Computes the residual of advective term using finite volume method.</li><li class="collection-item"><a href="source/fvkernels/PCNSFVKTDC.html">PCNSFVKTDC</a>Computes the residual of advective term using finite volume method using a deferred correction approach.</li><li class="collection-item"><a href="source/fvkernels/PCNSFVMassHLLC.html">PCNSFVMassHLLC</a>Implements the mass flux portion of the porous HLLC discretization.</li><li class="collection-item"><a href="source/fvkernels/PCNSFVMomentumFriction.html">PCNSFVMomentumFriction</a>Computes a friction force term on fluid in porous media in the Navier Stokes i-th momentum equation.</li><li class="collection-item"><a href="source/fvkernels/PCNSFVMomentumHLLC.html">PCNSFVMomentumHLLC</a>Implements the momentum flux portion of the porous HLLC discretization.</li><li class="collection-item"><a href="source/fvkernels/PINSFVEnergyAdvection.html">PINSFVEnergyAdvection</a>Advects energy, e.g. rho*cp*T. A user may still override what quantity is advected, but the default is rho*cp*T</li><li class="collection-item"><a href="source/fvkernels/PINSFVEnergyAmbientConvection.html">PINSFVEnergyAmbientConvection</a>Implements the solid-fluid ambient convection term in the porous media Navier Stokes energy equation.</li><li class="collection-item"><a href="source/fvkernels/PINSFVEnergyAnisotropicDiffusion.html">PINSFVEnergyAnisotropicDiffusion</a>Anisotropic diffusion term in the porous media incompressible Navier-Stokes equations : -div(kappa grad(T))</li><li class="collection-item"><a href="source/fvkernels/PINSFVEnergyDiffusion.html">PINSFVEnergyDiffusion</a>Diffusion term in the porous media incompressible Navier-Stokes fluid energy equations :  <span class="moose-katex-inline-equation" id="moose-equation-eba6d8c9-ead3-4626-bde2-bf6951e7643f"><script>var element = document.getElementById("moose-equation-eba6d8c9-ead3-4626-bde2-bf6951e7643f");katex.render("-div(eps * k * grad(T))", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span></li><li class="collection-item"><a href="source/fvkernels/PINSFVEnergyTimeDerivative.html">PINSFVEnergyTimeDerivative</a>Adds the time derivative term to the Navier-Stokes energy equation: for fluids: d(eps * rho * cp * T)/dt, for solids: (1 - eps) * d(rho * cp * T)/dtMaterial property derivatives are ignored if not provided.</li><li class="collection-item"><a href="source/fvkernels/PINSFVMassAdvection.html">PINSFVMassAdvection</a>Object for advecting mass in porous media mass equation</li><li class="collection-item"><a href="source/fvkernels/PINSFVMomentumAdvection.html">PINSFVMomentumAdvection</a>Object for advecting superficial momentum, e.g. rho*u_d, in the porous media momentum equation</li><li class="collection-item"><a href="source/fvkernels/PINSFVMomentumBoussinesq.html">PINSFVMomentumBoussinesq</a>Computes a body force for natural convection buoyancy in porous media: eps alpha (T-T_0)</li><li class="collection-item"><a href="source/fvkernels/PINSFVMomentumDiffusion.html">PINSFVMomentumDiffusion</a>Viscous diffusion term, div(mu eps grad(u_d / eps)), in the porous media incompressible Navier-Stokes momentum equation.</li><li class="collection-item"><a href="source/fvkernels/PINSFVMomentumFriction.html">PINSFVMomentumFriction</a>Computes a friction force term on fluid in porous media in the Navier Stokes i-th momentum equation in Rhie-Chow (incompressible) contexts.</li><li class="collection-item"><a href="source/fvkernels/PINSFVMomentumFrictionCorrection.html">PINSFVMomentumFrictionCorrection</a>Computes a correction term to avoid oscillations from average pressure interpolation in regions of high changes in friction coefficients.</li><li class="collection-item"><a href="source/fvkernels/PINSFVMomentumGravity.html">PINSFVMomentumGravity</a>Computes a body force, <span class="moose-katex-inline-equation" id="moose-equation-8b96ce39-91e6-4151-bae1-c61df70e0d1c"><script>var element = document.getElementById("moose-equation-8b96ce39-91e6-4151-bae1-c61df70e0d1c");katex.render("eps * \rho * g", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> due to gravity on fluid in porous media in Rhie-Chow (incompressible) contexts.</li><li class="collection-item"><a href="source/fvkernels/PINSFVMomentumPressure.html">PINSFVMomentumPressure</a>Introduces the coupled pressure term <span class="moose-katex-inline-equation" id="moose-equation-9585ae99-c780-4555-96b5-eca72858ae8e"><script>var element = document.getElementById("moose-equation-9585ae99-c780-4555-96b5-eca72858ae8e");katex.render("eps  abla P", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> into the Navier-Stokes porous media momentum equation.</li><li class="collection-item"><a href="source/fvkernels/PINSFVMomentumPressureFlux.html">PINSFVMomentumPressureFlux</a>Momentum pressure term eps grad_P, as a flux kernel using the divergence theoreom, in the porous media incompressible Navier-Stokes momentum equation. This kernel is also executed on boundaries.</li><li class="collection-item"><a href="source/fvkernels/PINSFVMomentumPressurePorosityGradient.html">PINSFVMomentumPressurePorosityGradient</a>Introduces the coupled pressure times porosity gradient term into the Navier-Stokes porous media momentum equation.</li><li class="collection-item"><a href="source/fvkernels/PINSFVMomentumTimeDerivative.html">PINSFVMomentumTimeDerivative</a>Adds the time derivative term: d(rho u_d) / dt to the porous media incompressible Navier-Stokes momentum equation.</li><li class="collection-item"><a href="source/fvkernels/PNSFVMomentumPressureFluxRZ.html">PNSFVMomentumPressureFluxRZ</a>Adds the porous <span class="moose-katex-inline-equation" id="moose-equation-1616a637-0387-4928-82aa-95f7a5d36709"><script>var element = document.getElementById("moose-equation-1616a637-0387-4928-82aa-95f7a5d36709");katex.render("-p/r", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> term into the radial component of the Navier-Stokes momentum equation for the problems in the RZ coordinate system when integrating by parts.</li><li class="collection-item"><a href="source/fvkernels/PNSFVMomentumPressureFluxRZ.html">PNSFVMomentumPressureRZ</a>Adds the porous <span class="moose-katex-inline-equation" id="moose-equation-3895a8be-9882-427d-8f70-142cf0660b03"><script>var element = document.getElementById("moose-equation-3895a8be-9882-427d-8f70-142cf0660b03");katex.render("-p/r", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> term into the radial component of the Navier-Stokes momentum equation for the problems in the RZ coordinate system when integrating by parts.</li><li class="collection-item"><a href="source/fvkernels/PNSFVPGradEpsilon.html">PNSFVPGradEpsilon</a>Introduces a -p * grad_eps term.</li><li class="collection-item"><a href="source/fvkernels/PWCNSFVMassTimeDerivative.html">PWCNSFVMassTimeDerivative</a>Adds the time derivative term to the porous weakly-compressible Navier-Stokes continuity equation.</li><li class="collection-item"><a href="source/fvkernels/WCNSFVEnergyTimeDerivative.html">WCNSFVEnergyTimeDerivative</a>Adds the time derivative term to the incompressible Navier-Stokes momentum equation.</li><li class="collection-item"><a href="source/fvkernels/WCNSFVMassTimeDerivative.html">WCNSFVMassTimeDerivative</a>Adds the time derivative term to the weakly-compressible Navier-Stokes continuity equation.</li><li class="collection-item"><a href="source/fvkernels/WCNSFVMixingLengthEnergyDiffusion.html">WCNSFVMixingLengthEnergyDiffusion</a>Computes the turbulent diffusive flux that appears in Reynolds-averaged fluid energy conservation equations.</li><li class="collection-item"><a href="source/fvkernels/WCNSFVMomentumTimeDerivative.html">WCNSFVMomentumTimeDerivative</a>Adds the time derivative term to the incompressible Navier-Stokes momentum equation.</li><li class="collection-header">Heat Conduction App</li><li class="collection-item"><a href="source/fvkernels/FVHeatConductionTimeDerivative.html">FVHeatConductionTimeDerivative</a>AD Time derivative term <span class="moose-katex-inline-equation" id="moose-equation-663a03fb-c22f-4b96-8a3a-0f977e9818e6"><script>var element = document.getElementById("moose-equation-663a03fb-c22f-4b96-8a3a-0f977e9818e6");katex.render("\\rho c_p \\frac{\\partial T}{\\partial t}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> of the heat equation for quasi-constant specific heat <span class="moose-katex-inline-equation" id="moose-equation-0242939f-bf37-4865-9ad8-a4827aa4644f"><script>var element = document.getElementById("moose-equation-0242939f-bf37-4865-9ad8-a4827aa4644f");katex.render("c_p", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> and the density <span class="moose-katex-inline-equation" id="moose-equation-522b7f53-09b5-4410-a77e-7290ba152e9f"><script>var element = document.getElementById("moose-equation-522b7f53-09b5-4410-a77e-7290ba152e9f");katex.render("\\rho", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li></ul></section><section class="scrollspy" id="9bb74a53-6dd7-4286-a420-0ccda4186e66" data-section-level="2" data-section-text="FluidProperties"><h2 id="fluidproperties"><a href="syntax/FluidProperties/index.html">FluidProperties</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Fluid Properties App</li><li class="collection-item"><a href="source/actions/AddFluidPropertiesAction.html">AddFluidPropertiesAction</a>Add a UserObject object to the simulation.</li><li class="collection-item"><a href="source/fluidproperties/BrineFluidProperties.html">BrineFluidProperties</a>Fluid properties for brine</li><li class="collection-item"><a href="source/fluidproperties/CO2FluidProperties.html">CO2FluidProperties</a>Fluid properties for carbon dioxide (CO2) using the Span &amp; Wagner EOS</li><li class="collection-item"><a href="source/fluidproperties/CaloricallyImperfectGas.html">CaloricallyImperfectGas</a>Fluid properties for an ideal gas with imperfect caloric behavior.</li><li class="collection-item"><a href="source/fluidproperties/FlibeFluidProperties.html">FlibeFluidProperties</a>Fluid properties for flibe</li><li class="collection-item"><a href="source/fluidproperties/FlinakFluidProperties.html">FlinakFluidProperties</a>Fluid properties for flinak</li><li class="collection-item"><a href="source/fluidproperties/HeliumFluidProperties.html">HeliumFluidProperties</a>Fluid properties for helium</li><li class="collection-item"><a href="source/fluidproperties/HydrogenFluidProperties.html">HydrogenFluidProperties</a>Fluid properties for Hydrogen (H2)</li><li class="collection-item"><a href="source/fluidproperties/IdealGasFluidProperties.html">IdealGasFluidProperties</a>Fluid properties for an ideal gas</li><li class="collection-item"><a href="source/fluidproperties/IdealRealGasMixtureFluidProperties.html">IdealRealGasMixtureFluidProperties</a>Class for fluid properties of an arbitrary vapor mixture</li><li class="collection-item"><a href="source/fluidproperties/LeadBismuthFluidProperties.html">LeadBismuthFluidProperties</a>Fluid properties for Lead Bismuth eutectic 2LiF-BeF2</li><li class="collection-item"><a href="source/fluidproperties/LeadFluidProperties.html">LeadFluidProperties</a>Fluid properties for Lead</li><li class="collection-item"><a href="source/fluidproperties/MethaneFluidProperties.html">MethaneFluidProperties</a>Fluid properties for methane (CH4)</li><li class="collection-item"><a href="source/fluidproperties/NaClFluidProperties.html">NaClFluidProperties</a>Fluid properties for NaCl</li><li class="collection-item"><a href="source/fluidproperties/NaKFluidProperties.html">NaKFluidProperties</a>Fluid properties for NaK</li><li class="collection-item"><a href="source/fluidproperties/NitrogenFluidProperties.html">NitrogenFluidProperties</a>Fluid properties for Nitrogen (N2)</li><li class="collection-item"><a href="source/fluidproperties/SimpleFluidProperties.html">SimpleFluidProperties</a>Fluid properties for a simple fluid with a constant bulk density</li><li class="collection-item"><a href="source/fluidproperties/SodiumProperties.html">SodiumProperties</a>Fluid properties for sodium</li><li class="collection-item"><a href="source/fluidproperties/SodiumSaturationFluidProperties.html">SodiumSaturationFluidProperties</a>Fluid properties for liquid sodium at saturation conditions</li><li class="collection-item"><a href="source/fluidproperties/StiffenedGasFluidProperties.html">StiffenedGasFluidProperties</a>Fluid properties for a stiffened gas</li><li class="collection-item"><a href="source/fluidproperties/StiffenedGasTwoPhaseFluidProperties.html">StiffenedGasTwoPhaseFluidProperties</a>Two-phase stiffened gas fluid properties</li><li class="collection-item"><a href="source/fluidproperties/TabulatedBicubicFluidProperties.html">TabulatedBicubicFluidProperties</a>Fluid properties using bicubic interpolation on tabulated values provided</li><li class="collection-item"><a href="source/fluidproperties/TabulatedBicubicFluidProperties.html">TabulatedFluidProperties</a>Fluid properties using bicubic interpolation on tabulated values provided</li><li class="collection-item"><a href="source/fluidproperties/TemperaturePressureFunctionFluidProperties.html">TemperaturePressureFunctionFluidProperties</a>Single-phase fluid properties that allows to provide thermal conductivity, density, and viscosity as functions of temperature and pressure.</li><li class="collection-item"><a href="source/fluidproperties/TwoPhaseFluidPropertiesIndependent.html">TwoPhaseFluidPropertiesIndependent</a>2-phase fluid properties for 2 independent single-phase fluid properties</li><li class="collection-item"><a href="source/fluidproperties/Water97FluidProperties.html">Water97FluidProperties</a>Fluid properties for water and steam (H2O) using IAPWS-IF97</li></ul></section><section class="scrollspy" id="9d148718-bfc0-4d1e-90ca-dc679f65b386" data-section-level="2" data-section-text="FluidPropertiesInterrogator"><h2 id="fluidpropertiesinterrogator"><a href="syntax/FluidPropertiesInterrogator/index.html">FluidPropertiesInterrogator</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Fluid Properties App</li><li class="collection-item"><a href="source/actions/AddFluidPropertiesInterrogatorAction.html">AddFluidPropertiesInterrogatorAction</a>Action that sets up the fluid properties interrogator</li></ul></section><section class="scrollspy" id="731af09e-bce0-4060-a555-b86d8cf38f1c" data-section-level="2" data-section-text="Functions"><h2 id="functions"><a href="syntax/Functions/index.html">Functions</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddFunctionAction.html">AddFunctionAction</a>Add a Function object to the simulation.</li><li class="collection-item"><a href="source/functions/MooseParsedFunction.html">ADParsedFunction</a>Function created by parsing a string</li><li class="collection-item"><a href="source/functions/PiecewiseLinear.html">ADPiecewiseLinear</a>Linearly interpolates between pairs of x-y data</li><li class="collection-item"><a href="source/functions/Axisymmetric2D3DSolutionFunction.html">Axisymmetric2D3DSolutionFunction</a>Function for reading a 2D axisymmetric solution from file and mapping it to a 3D Cartesian model</li><li class="collection-item"><a href="source/functions/BicubicSplineFunction.html">BicubicSplineFunction</a>Define a bicubic spline function from interpolated data defined by input parameters.</li><li class="collection-item"><a href="source/functions/CoarsenedPiecewiseLinear.html">CoarsenedPiecewiseLinear</a>Perform a point reduction of the tabulated data upon initialization, then evaluate using a linear interpolation.</li><li class="collection-item"><a href="source/functions/CompositeFunction.html">CompositeFunction</a>Multiplies an arbitrary set of functions together</li><li class="collection-item"><a href="source/functions/ConstantFunction.html">ConstantFunction</a>A function that returns a constant value as defined by an input parameter.</li><li class="collection-item"><a href="source/functions/ImageFunction.html">ImageFunction</a>Function with values sampled from an image or image stack.</li><li class="collection-item"><a href="source/functions/LinearCombinationFunction.html">LinearCombinationFunction</a>Returns the linear combination of the functions</li><li class="collection-item"><a href="source/functions/MooseParsedFunction.html">ParsedFunction</a>Function created by parsing a string</li><li class="collection-item"><a href="source/functions/MooseParsedGradFunction.html">ParsedGradFunction</a>Defines a function and its gradient using input file parameters.</li><li class="collection-item"><a href="source/functions/MooseParsedVectorFunction.html">ParsedVectorFunction</a>Return a vector component values based on string functions for each component.</li><li class="collection-item"><a href="source/functions/PeriodicFunction.html">PeriodicFunction</a>Provides a periodic function by repeating a user-supplied base function in time and/or any of the three Cartesian coordinate directions</li><li class="collection-item"><a href="source/functions/PiecewiseBilinear.html">PiecewiseBilinear</a>Interpolates values from a csv file</li><li class="collection-item"><a href="source/functions/PiecewiseConstant.html">PiecewiseConstant</a>Defines data using a set of x-y data pairs</li><li class="collection-item"><a href="source/functions/PiecewiseConstantFromCSV.html">PiecewiseConstantFromCSV</a>Uses data read from CSV to assign values</li><li class="collection-item"><a href="source/functions/PiecewiseLinear.html">PiecewiseLinear</a>Linearly interpolates between pairs of x-y data</li><li class="collection-item"><a href="source/functions/PiecewiseLinearFromVectorPostprocessor.html">PiecewiseLinearFromVectorPostprocessor</a>Provides piecewise linear interpolation of from two columns of a VectorPostprocessor</li><li class="collection-item"><a href="source/functions/PiecewiseMulticonstant.html">PiecewiseMulticonstant</a>PiecewiseMulticonstant performs constant interpolation on 1D, 2D, 3D or 4D data.  The data_file specifies the axes directions and the function values.  If a point lies outside the data range, the appropriate end value is used.</li><li class="collection-item"><a href="source/functions/PiecewiseMultilinear.html">PiecewiseMultilinear</a>PiecewiseMultilinear performs linear interpolation on 1D, 2D, 3D or 4D data.  The data_file specifies the axes directions and the function values.  If a point lies outside the data range, the appropriate end value is used.</li><li class="collection-item"><a href="source/functions/SolutionFunction.html">SolutionFunction</a>Function for reading a solution from file.</li><li class="collection-item"><a href="source/functions/SplineFunction.html">SplineFunction</a>Define a spline function from interpolated data defined by input parameters.</li><li class="collection-item"><a href="source/functions/PiecewiseLinearFromVectorPostprocessor.html">VectorPostprocessorFunction</a>Provides piecewise linear interpolation of from two columns of a VectorPostprocessor</li><li class="collection-header">Fluid Properties App</li><li class="collection-item"><a href="source/functions/SaturationDensityFunction.html">SaturationDensityFunction</a>Computes saturation density from temperature function</li><li class="collection-item"><a href="source/functions/SaturationPressureFunction.html">SaturationPressureFunction</a>Computes saturation pressure from temperature function and 2-phase fluid properties object</li><li class="collection-item"><a href="source/functions/SaturationTemperatureFunction.html">SaturationTemperatureFunction</a>Computes saturation temperature from pressure function and 2-phase fluid properties object</li></ul></section><section class="scrollspy" id="c069ba01-18e3-427e-9a08-b41755b0813c" data-section-level="2" data-section-text="FunctorMaterials"><h2 id="functormaterials"><a href="syntax/FunctorMaterials/index.html">FunctorMaterials</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddFunctorMaterialAction.html">AddFunctorMaterialAction</a>Add a Functor Material object to the simulation.</li><li class="collection-item"><a href="source/materials/CoupledValueFunctionMaterial.html">ADCoupledValueFunctionMaterial</a>Compute a function value from coupled variables</li><li class="collection-item"><a href="source/materials/DerivativeParsedMaterial.html">ADDerivativeParsedMaterial</a>Parsed Function Material with automatic derivatives.</li><li class="collection-item"><a href="source/materials/DerivativeSumMaterial.html">ADDerivativeSumMaterial</a>Meta-material to sum up multiple derivative materials</li><li class="collection-item"><a href="source/functormaterials/GenericFunctorMaterial.html">ADGenericConstantFunctorMaterial</a>FunctorMaterial object for declaring properties that are populated by evaluation of a Functor (a constant, variable, function or functor material property) objects.</li><li class="collection-item"><a href="source/materials/GenericConstantMaterial.html">ADGenericConstantMaterial</a>Declares material properties based on names and values prescribed by input parameters.</li><li class="collection-item"><a href="source/materials/GenericConstantRankTwoTensor.html">ADGenericConstantRankTwoTensor</a>Object for declaring a constant rank two tensor as a material property.</li><li class="collection-item"><a href="source/functormaterials/GenericVectorFunctorMaterial.html">ADGenericConstantVectorFunctorMaterial</a>FunctorMaterial object for declaring vector properties that are populated by evaluation of functor (constants, functions, variables, matprops) object.</li><li class="collection-item"><a href="source/materials/GenericConstantVectorMaterial.html">ADGenericConstantVectorMaterial</a>Declares material properties based on names and vector values prescribed by input parameters.</li><li class="collection-item"><a href="source/functormaterials/GenericFunctorMaterial.html">ADGenericFunctionFunctorMaterial</a>FunctorMaterial object for declaring properties that are populated by evaluation of a Functor (a constant, variable, function or functor material property) objects.</li><li class="collection-item"><a href="source/materials/GenericFunctionMaterial.html">ADGenericFunctionMaterial</a>Material object for declaring properties that are populated by evaluation of Function object.</li><li class="collection-item"><a href="source/materials/GenericFunctionRankTwoTensor.html">ADGenericFunctionRankTwoTensor</a>Material object for defining rank two tensor properties using functions.</li><li class="collection-item"><a href="source/materials/GenericFunctionVectorMaterial.html">ADGenericFunctionVectorMaterial</a>Material object for declaring vector properties that are populated by evaluation of Function objects.</li><li class="collection-item"><a href="source/functormaterials/GenericFunctorGradientMaterial.html">ADGenericFunctorGradientMaterial</a>FunctorMaterial object for declaring properties that are populated by evaluation of gradients of Functors (a constant, variable, function or functor material property) objects.</li><li class="collection-item"><a href="source/functormaterials/GenericFunctorMaterial.html">ADGenericFunctorMaterial</a>FunctorMaterial object for declaring properties that are populated by evaluation of a Functor (a constant, variable, function or functor material property) objects.</li><li class="collection-item"><a href="source/functormaterials/GenericVectorFunctorMaterial.html">ADGenericVectorFunctorMaterial</a>FunctorMaterial object for declaring vector properties that are populated by evaluation of functor (constants, functions, variables, matprops) object.</li><li class="collection-item"><a href="source/materials/ParsedMaterial.html">ADParsedMaterial</a>Parsed expression Material.</li><li class="collection-item"><a href="source/functormaterials/PiecewiseByBlockFunctorMaterial.html">ADPiecewiseByBlockFunctorMaterial</a>Computes a property value on a per-subdomain basis</li><li class="collection-item"><a href="source/functormaterials/PiecewiseByBlockFunctorMaterial.html">ADPiecewiseByBlockVectorFunctorMaterial</a>Computes a property value on a per-subdomain basis</li><li class="collection-item"><a href="source/materials/PiecewiseConstantByBlockMaterial.html">ADPiecewiseConstantByBlockMaterial</a>Computes a property value on a per-subdomain basis</li><li class="collection-item"><a href="source/materials/ADPiecewiseLinearInterpolationMaterial.html">ADPiecewiseLinearInterpolationMaterial</a>Compute a property using a piecewise linear interpolation to define its dependence on a variable</li><li class="collection-item"><a href="source/functormaterials/VectorMagnitudeFunctorMaterial.html">ADVectorMagnitudeFunctorMaterial</a>This class takes up to three scalar-valued functors corresponding to vector components <em>or</em> a single vector functor and computes the Euclidean norm.</li><li class="collection-item"><a href="source/materials/CoupledValueFunctionMaterial.html">CoupledValueFunctionMaterial</a>Compute a function value from coupled variables</li><li class="collection-item"><a href="source/materials/DerivativeParsedMaterial.html">DerivativeParsedMaterial</a>Parsed Function Material with automatic derivatives.</li><li class="collection-item"><a href="source/materials/DerivativeSumMaterial.html">DerivativeSumMaterial</a>Meta-material to sum up multiple derivative materials</li><li class="collection-item"><a href="source/functormaterials/PiecewiseByBlockFunctorMaterial.html">FVADPropValPerSubdomainMaterial</a>Computes a property value on a per-subdomain basis</li><li class="collection-item"><a href="source/functormaterials/PiecewiseByBlockFunctorMaterial.html">FVPropValPerSubdomainMaterial</a>Computes a property value on a per-subdomain basis</li><li class="collection-item"><a href="source/functormaterials/FunctorADConverter.html">FunctorADConverter</a>Converts regular functors to AD functors and AD functors to regular functors</li><li class="collection-item"><a href="source/materials/GenericConstant2DArray.html">GenericConstant2DArray</a>A material evaluating one material property in type of RealEigenMatrix</li><li class="collection-item"><a href="source/materials/GenericConstantArray.html">GenericConstantArray</a>A material evaluating one material property in type of RealEigenVector</li><li class="collection-item"><a href="source/functormaterials/GenericFunctorMaterial.html">GenericConstantFunctorMaterial</a>FunctorMaterial object for declaring properties that are populated by evaluation of a Functor (a constant, variable, function or functor material property) objects.</li><li class="collection-item"><a href="source/materials/GenericConstantMaterial.html">GenericConstantMaterial</a>Declares material properties based on names and values prescribed by input parameters.</li><li class="collection-item"><a href="source/materials/GenericConstantRankTwoTensor.html">GenericConstantRankTwoTensor</a>Object for declaring a constant rank two tensor as a material property.</li><li class="collection-item"><a href="source/functormaterials/GenericVectorFunctorMaterial.html">GenericConstantVectorFunctorMaterial</a>FunctorMaterial object for declaring vector properties that are populated by evaluation of functor (constants, functions, variables, matprops) object.</li><li class="collection-item"><a href="source/materials/GenericConstantVectorMaterial.html">GenericConstantVectorMaterial</a>Declares material properties based on names and vector values prescribed by input parameters.</li><li class="collection-item"><a href="source/functormaterials/GenericFunctorMaterial.html">GenericFunctionFunctorMaterial</a>FunctorMaterial object for declaring properties that are populated by evaluation of a Functor (a constant, variable, function or functor material property) objects.</li><li class="collection-item"><a href="source/materials/GenericFunctionMaterial.html">GenericFunctionMaterial</a>Material object for declaring properties that are populated by evaluation of Function object.</li><li class="collection-item"><a href="source/materials/GenericFunctionRankTwoTensor.html">GenericFunctionRankTwoTensor</a>Material object for defining rank two tensor properties using functions.</li><li class="collection-item"><a href="source/materials/GenericFunctionVectorMaterial.html">GenericFunctionVectorMaterial</a>Material object for declaring vector properties that are populated by evaluation of Function objects.</li><li class="collection-item"><a href="source/functormaterials/GenericFunctorGradientMaterial.html">GenericFunctorGradientMaterial</a>FunctorMaterial object for declaring properties that are populated by evaluation of gradients of Functors (a constant, variable, function or functor material property) objects.</li><li class="collection-item"><a href="source/functormaterials/GenericFunctorMaterial.html">GenericFunctorMaterial</a>FunctorMaterial object for declaring properties that are populated by evaluation of a Functor (a constant, variable, function or functor material property) objects.</li><li class="collection-item"><a href="source/functormaterials/GenericVectorFunctorMaterial.html">GenericVectorFunctorMaterial</a>FunctorMaterial object for declaring vector properties that are populated by evaluation of functor (constants, functions, variables, matprops) object.</li><li class="collection-item"><a href="source/materials/MaterialADConverter.html">MaterialADConverter</a>Converts regular material properties to AD properties and vice versa</li><li class="collection-item"><a href="source/materials/MaterialADConverter.html">MaterialConverter</a>Converts regular material properties to AD properties and vice versa</li><li class="collection-item"><a href="source/materials/MaterialFunctorConverter.html">MaterialFunctorConverter</a>Converts functor to non-AD and AD regular material properties</li><li class="collection-item"><a href="source/materials/ParsedMaterial.html">ParsedMaterial</a>Parsed expression Material.</li><li class="collection-item"><a href="source/functormaterials/PiecewiseByBlockFunctorMaterial.html">PiecewiseByBlockFunctorMaterial</a>Computes a property value on a per-subdomain basis</li><li class="collection-item"><a href="source/functormaterials/PiecewiseByBlockFunctorMaterial.html">PiecewiseByBlockVectorFunctorMaterial</a>Computes a property value on a per-subdomain basis</li><li class="collection-item"><a href="source/materials/PiecewiseConstantByBlockMaterial.html">PiecewiseConstantByBlockMaterial</a>Computes a property value on a per-subdomain basis</li><li class="collection-item"><a href="source/materials/PiecewiseLinearInterpolationMaterial.html">PiecewiseLinearInterpolationMaterial</a>Compute a property using a piecewise linear interpolation to define its dependence on a variable</li><li class="collection-item"><a href="source/materials/MaterialADConverter.html">RankFourTensorMaterialADConverter</a>Converts regular material properties to AD properties and vice versa</li><li class="collection-item"><a href="source/materials/MaterialADConverter.html">RankFourTensorMaterialConverter</a>Converts regular material properties to AD properties and vice versa</li><li class="collection-item"><a href="source/materials/MaterialADConverter.html">RankTwoTensorMaterialADConverter</a>Converts regular material properties to AD properties and vice versa</li><li class="collection-item"><a href="source/materials/MaterialADConverter.html">RankTwoTensorMaterialConverter</a>Converts regular material properties to AD properties and vice versa</li><li class="collection-item"><a href="source/functormaterials/FunctorADConverter.html">VectorFunctorADConverter</a>Converts regular functors to AD functors and AD functors to regular functors</li><li class="collection-item"><a href="source/functormaterials/VectorMagnitudeFunctorMaterial.html">VectorMagnitudeFunctorMaterial</a>This class takes up to three scalar-valued functors corresponding to vector components <em>or</em> a single vector functor and computes the Euclidean norm.</li><li class="collection-item"><a href="source/materials/MaterialFunctorConverter.html">VectorMaterialFunctorConverter</a>Converts functor to non-AD and AD regular material properties</li><li class="collection-header">Navier Stokes App</li><li class="collection-item"><a href="source/materials/Air.html">Air</a>Air.</li><li class="collection-item"><a href="source/materials/ConservedVarValuesMaterial.html">ConservedVarValuesMaterial</a>Provides access to variables for a conserved variable set of density, total fluid energy, and momentum</li><li class="collection-item"><a href="source/functormaterials/ExponentialFrictionMaterial.html">ExponentialFrictionMaterial</a>Computes a Reynolds number-exponential friction factor.</li><li class="collection-item"><a href="source/materials/GeneralFluidProps.html">GeneralFluidProps</a>Computes fluid properties using a (P, T) formulation</li><li class="collection-item"><a href="source/functormaterials/GeneralFunctorFluidProps.html">GeneralFunctorFluidProps</a>Creates functor fluid properties using a (P, T) formulation</li><li class="collection-item"><a href="source/materials/PINSFEMaterial.html">GenericPorousMediumMaterial</a>Computes generic material properties related to simulation of fluid flow in a porous medium</li><li class="collection-item"><a href="source/materials/INSAD3Eqn.html">INSAD3Eqn</a>This material computes properties needed for stabilized formulations of the mass, momentum, and energy equations.</li><li class="collection-item"><a href="source/materials/INSADMaterial.html">INSADMaterial</a>This is the material class used to compute some of the strong residuals for the INS equations.</li><li class="collection-item"><a href="source/materials/INSADStabilized3Eqn.html">INSADStabilized3Eqn</a>This is the material class used to compute the stabilization parameter tau for momentum and tau_energy for the energy equation.</li><li class="collection-item"><a href="source/materials/INSADTauMaterial.html">INSADTauMaterial</a>This is the material class used to compute the stabilization parameter tau.</li><li class="collection-item"><a href="source/materials/INSFEMaterial.html">INSFEMaterial</a>Computes generic material properties related to simulation of fluid flow</li><li class="collection-item"><a href="source/materials/INSFVEnthalpyMaterial.html">INSFVEnthalpyMaterial</a>This is the material class used to compute enthalpy for the incompressible/weakly-compressible finite-volume implementation of the Navier-Stokes equations.</li><li class="collection-item"><a href="source/materials/INSFVMushyPorousFrictionMaterial.html">INSFVMushyPorousFrictionMaterial</a>Computes the mushy zone porous resistance for solidification/melting problems.</li><li class="collection-item"><a href="source/functormaterials/LinearFrictionFactorFunctorMaterial.html">LinearFrictionFactorFunctorMaterial</a>Material class used to compute a friction factor of the form A * f(r, t) + B * g(r, t) * |v_I| with A, B vector constants, f(r, t) and g(r, t) functors of space and time, and |v_I| the interstitial speed</li><li class="collection-item"><a href="source/materials/INSFEMaterial.html">MDFluidMaterial</a>Computes generic material properties related to simulation of fluid flow</li><li class="collection-item"><a href="source/materials/MixingLengthTurbulentViscosityMaterial.html">MixingLengthTurbulentViscosityMaterial</a>Computes the material property corresponding to the total viscositycomprising the mixing length model turbulent total_viscosityand the molecular viscosity.</li><li class="collection-item"><a href="source/materials/NSFVFrictionFlowDiodeMaterial.html">NSFVFrictionFlowDiodeMaterial</a>Increases the anistropic friction coefficients, linear or quadratic, by K_i * |direction_i| when the diode is turned on with a boolean</li><li class="collection-item"><a href="source/materials/NSFVMixtureMaterial.html">NSFVMixtureMaterial</a>Compute the arithmetic mean of material properties using a phase fraction.</li><li class="collection-item"><a href="source/materials/PINSFEMaterial.html">PINSFEMaterial</a>Computes generic material properties related to simulation of fluid flow in a porous medium</li><li class="collection-item"><a href="source/functormaterials/PINSFVSpeedFunctorMaterial.html">PINSFVSpeedFunctorMaterial</a>This is the material class used to compute the interstitial velocity norm for the incompressible and weakly compressible primitive superficial finite-volume implementation of porous media equations.</li><li class="collection-item"><a href="source/materials/PorousConservedVarMaterial.html">PorousConservedVarMaterial</a>Provides access to variables for a conserved variable set of density, total fluid energy, and momentum</li><li class="collection-item"><a href="source/materials/PorousMixedVarMaterial.html">PorousMixedVarMaterial</a>Provides access to variables for a primitive variable set of pressure, temperature, and superficial velocity</li><li class="collection-item"><a href="source/materials/PorousPrimitiveVarMaterial.html">PorousPrimitiveVarMaterial</a>Provides access to variables for a primitive variable set of pressure, temperature, and superficial velocity</li><li class="collection-item"><a href="source/functormaterials/ReynoldsNumberFunctorMaterial.html">ReynoldsNumberFunctorMaterial</a>Computes a Reynolds number.</li><li class="collection-item"><a href="source/functormaterials/RhoFromPTFunctorMaterial.html">RhoFromPTFunctorMaterial</a>Computes the density from coupled pressure and temperature functors (variables, functions, functor material properties</li><li class="collection-item"><a href="source/materials/SoundspeedMat.html">SoundspeedMat</a>Computes the speed of sound</li><li class="collection-item"><a href="source/functormaterials/ThermalDiffusivityFunctorMaterial.html">ThermalDiffusivityFunctorMaterial</a>Computes the thermal diffusivity given the thermal conductivity, specific heat capacity, and fluid density.</li><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/materials/ADAbruptSoftening.html">ADAbruptSoftening</a>Softening model with an abrupt stress release upon cracking. This class relies on automatic differentiation and is intended to be used with ADComputeSmearedCrackingStress.</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/CZMComputeDisplacementJumpSmallStrain.html">ADCZMComputeDisplacementJumpSmallStrain</a>Compute the total displacement jump across a czm interface in local coordinates for the Small Strain kinematic formulation</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/CZMComputeDisplacementJumpTotalLagrangian.html">ADCZMComputeDisplacementJumpTotalLagrangian</a>Compute the displacement jump increment across a czm interface in local coordinates for the Total Lagrangian kinematic formulation</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/ADCZMComputeGlobalTractionSmallStrain.html">ADCZMComputeGlobalTractionSmallStrain</a>Computes the czm traction in global coordinates for a small strain kinematic formulation</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/ADCZMComputeGlobalTractionTotalLagrangian.html">ADCZMComputeGlobalTractionTotalLagrangian</a>Compute the equilibrium traction (PK1) and its derivatives for the Total Lagrangian formulation.</li><li class="collection-item"><a href="source/materials/CombinedScalarDamage.html">ADCombinedScalarDamage</a>Scalar damage model which is computed as a function of multiple scalar damage models</li><li class="collection-item"><a href="source/materials/ADComputeAxisymmetricRZFiniteStrain.html">ADComputeAxisymmetricRZFiniteStrain</a>Compute a strain increment for finite strains under axisymmetric assumptions.</li><li class="collection-item"><a href="source/materials/ADComputeAxisymmetricRZIncrementalStrain.html">ADComputeAxisymmetricRZIncrementalStrain</a>Compute a strain increment and rotation increment for finite strains under axisymmetric assumptions.</li><li class="collection-item"><a href="source/materials/ADComputeAxisymmetricRZSmallStrain.html">ADComputeAxisymmetricRZSmallStrain</a>Compute a small strain in an Axisymmetric geometry</li><li class="collection-item"><a href="source/materials/ComputeDamageStress.html">ADComputeDamageStress</a>Compute stress for damaged elastic materials in conjunction with a damage model.</li><li class="collection-item"><a href="source/materials/ComputeDilatationThermalExpansionFunctionEigenstrain.html">ADComputeDilatationThermalExpansionFunctionEigenstrain</a>Computes eigenstrain due to thermal expansion using a function that describes the total dilatation as a function of temperature</li><li class="collection-item"><a href="source/materials/ComputeEigenstrain.html">ADComputeEigenstrain</a>Computes a constant Eigenstrain</li><li class="collection-item"><a href="source/materials/ComputeElasticityTensor.html">ADComputeElasticityTensor</a>Compute an elasticity tensor.</li><li class="collection-item"><a href="source/materials/ADComputeFiniteShellStrain.html">ADComputeFiniteShellStrain</a>Compute a large strain increment for the shell.</li><li class="collection-item"><a href="source/materials/ADComputeFiniteStrain.html">ADComputeFiniteStrain</a>Compute a strain increment and rotation increment for finite strains.</li><li class="collection-item"><a href="source/materials/ADComputeFiniteStrainElasticStress.html">ADComputeFiniteStrainElasticStress</a>Compute stress using elasticity for finite strains</li><li class="collection-item"><a href="source/materials/ADComputeGreenLagrangeStrain.html">ADComputeGreenLagrangeStrain</a>Compute a Green-Lagrange strain.</li><li class="collection-item"><a href="source/materials/ADComputeIncrementalShellStrain.html">ADComputeIncrementalShellStrain</a>Compute a small strain increment for the shell.</li><li class="collection-item"><a href="source/materials/ADComputeIncrementalSmallStrain.html">ADComputeIncrementalSmallStrain</a>Compute a strain increment and rotation increment for small strains.</li><li class="collection-item"><a href="source/materials/ComputeInstantaneousThermalExpansionFunctionEigenstrain.html">ADComputeInstantaneousThermalExpansionFunctionEigenstrain</a>Computes eigenstrain due to thermal expansion using a function that describes the instantaneous thermal expansion as a function of temperature</li><li class="collection-item"><a href="source/materials/ComputeIsotropicElasticityTensor.html">ADComputeIsotropicElasticityTensor</a>Compute a constant isotropic elasticity tensor.</li><li class="collection-item"><a href="source/materials/ADComputeIsotropicElasticityTensorShell.html">ADComputeIsotropicElasticityTensorShell</a>Compute a plane stress isotropic elasticity tensor.</li><li class="collection-item"><a href="source/materials/ADComputeLinearElasticStress.html">ADComputeLinearElasticStress</a>Compute stress using elasticity for small strains</li><li class="collection-item"><a href="source/materials/ComputeMeanThermalExpansionFunctionEigenstrain.html">ADComputeMeanThermalExpansionFunctionEigenstrain</a>Computes eigenstrain due to thermal expansion using a function that describes the mean thermal expansion as a function of temperature</li><li class="collection-item"><a href="source/materials/ADComputeMultipleInelasticStress.html">ADComputeMultipleInelasticStress</a>Compute state (stress and internal parameters such as plastic strains and internal parameters) using an iterative process.  Combinations of creep models and plastic models may be used.</li><li class="collection-item"><a href="source/materials/ADComputeMultiplePorousInelasticStress.html">ADComputeMultiplePorousInelasticStress</a>Compute state (stress and internal parameters such as plastic strains and internal parameters) using an iterative process. A porosity material property is defined and is calculated from the trace of inelastic strain increment.</li><li class="collection-item"><a href="source/materials/ADComputePlaneFiniteStrain.html">ADComputePlaneFiniteStrain</a>Compute strain increment and rotation increment for finite strain under 2D planar assumptions.</li><li class="collection-item"><a href="source/materials/ADComputePlaneIncrementalStrain.html">ADComputePlaneIncrementalStrain</a>Compute strain increment for small strain under 2D planar assumptions.</li><li class="collection-item"><a href="source/materials/ADComputePlaneSmallStrain.html">ADComputePlaneSmallStrain</a>Compute a small strain under generalized plane strain assumptions where the out of plane strain is generally nonzero.</li><li class="collection-item"><a href="source/materials/ADComputeRSphericalFiniteStrain.html">ADComputeRSphericalFiniteStrain</a>Compute a strain increment and rotation increment for finite strains in 1D spherical symmetry problems.</li><li class="collection-item"><a href="source/materials/ADComputeRSphericalIncrementalStrain.html">ADComputeRSphericalIncrementalStrain</a>Compute a strain increment for incremental strains in 1D spherical symmetry problems.</li><li class="collection-item"><a href="source/materials/ADComputeRSphericalSmallStrain.html">ADComputeRSphericalSmallStrain</a>Compute a small strain 1D spherical symmetry case.</li><li class="collection-item"><a href="source/materials/ADComputeShellStress.html">ADComputeShellStress</a>Compute in-plane stress using elasticity for shell</li><li class="collection-item"><a href="source/materials/ADComputeSmallStrain.html">ADComputeSmallStrain</a>Compute a small strain.</li><li class="collection-item"><a href="source/materials/ADComputeSmearedCrackingStress.html">ADComputeSmearedCrackingStress</a>Compute stress using a fixed smeared cracking model. Uses automatic differentiation</li><li class="collection-item"><a href="source/materials/ADComputeStrainIncrementBasedStress.html">ADComputeStrainIncrementBasedStress</a>Compute stress after subtracting inelastic strain increments</li><li class="collection-item"><a href="source/materials/ComputeThermalExpansionEigenstrain.html">ADComputeThermalExpansionEigenstrain</a>Computes eigenstrain due to thermal expansion with a constant coefficient</li><li class="collection-item"><a href="source/materials/ADComputeVariableIsotropicElasticityTensor.html">ADComputeVariableIsotropicElasticityTensor</a>Compute an isotropic elasticity tensor for elastic constants that change as a function of material properties</li><li class="collection-item"><a href="source/materials/EshelbyTensor.html">ADEshelbyTensor</a>Computes the Eshelby tensor as a function of strain energy density and the first Piola-Kirchhoff stress</li><li class="collection-item"><a href="source/materials/ADExponentialSoftening.html">ADExponentialSoftening</a>Softening model with an exponential softening response upon cracking. This class is intended to be used with ADComputeSmearedCrackingStress and relies on automatic differentiation.</li><li class="collection-item"><a href="source/materials/HillConstants.html">ADHillConstants</a>Build and rotate the Hill Tensor. It can be used with other Hill plasticity and creep materials.</li><li class="collection-item"><a href="source/materials/HillCreepStressUpdate.html">ADHillCreepStressUpdate</a>This class uses the stress update material in a generalized radial return anisotropic power law creep model.  This class can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/HillElastoPlasticityStressUpdate.html">ADHillElastoPlasticityStressUpdate</a>This class uses the generalized radial return for anisotropic elasto-plasticity model.This class can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/HillPlasticityStressUpdate.html">ADHillPlasticityStressUpdate</a>This class uses the generalized radial return for anisotropic plasticity model.This class can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/IsotropicPlasticityStressUpdate.html">ADIsotropicPlasticityStressUpdate</a>This class uses the discrete material in a radial return isotropic plasticity model.  This class is one of the basic radial return constitutive models, yet it can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/IsotropicPowerLawHardeningStressUpdate.html">ADIsotropicPowerLawHardeningStressUpdate</a>This class uses the discrete material in a radial return isotropic plasticity power law hardening model, solving for the yield stress as the intersection of the power law relation curve and Hooke&#x27;s law.  This class can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/LAROMANCEPartitionStressUpdateBase.html">ADLAROMANCEPartitionStressUpdate</a>LAROMANCE base class for partitioned reduced order models</li><li class="collection-item"><a href="source/materials/LAROMANCEStressUpdateBase.html">ADLAROMANCEStressUpdate</a>Base class to calculate the effective creep strain based on the rates predicted by a material  specific Los Alamos Reduced Order Model derived from a Visco-Plastic Self Consistent calculations.</li><li class="collection-item"><a href="source/materials/ADMultiplePowerLawCreepStressUpdate.html">ADMultiplePowerLawCreepStressUpdate</a>This class uses the stress update material in a radial return isotropic power law creep model. This class can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/NonlocalDamage.html">ADNonlocalDamage</a>Nonlocal damage model. Given an RadialAverage UO this creates a new damage index that can be used as for ComputeDamageStress without havign to change existing local damage models.</li><li class="collection-item"><a href="source/materials/PorosityFromStrain.html">ADPorosityFromStrain</a>Porosity calculation from the inelastic strain.</li><li class="collection-item"><a href="source/materials/PowerLawCreepStressUpdate.html">ADPowerLawCreepStressUpdate</a>This class uses the stress update material in a radial return isotropic power law creep model. This class can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/ADPowerLawSoftening.html">ADPowerLawSoftening</a>Softening model with an abrupt stress release upon cracking. This class is intended to be used with ADComputeSmearedCrackingStress and relies on automatic differentiation.</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/ADPureElasticTractionSeparation.html">ADPureElasticTractionSeparation</a>Pure elastic traction separation law.</li><li class="collection-item"><a href="source/materials/RankTwoCartesianComponent.html">ADRankTwoCartesianComponent</a>Access a component of a RankTwoTensor</li><li class="collection-item"><a href="source/materials/RankTwoCylindricalComponent.html">ADRankTwoCylindricalComponent</a>Compute components of a rank-2 tensor in a cylindrical coordinate system</li><li class="collection-item"><a href="source/materials/RankTwoDirectionalComponent.html">ADRankTwoDirectionalComponent</a>Compute a Direction scalar property of a RankTwoTensor</li><li class="collection-item"><a href="source/materials/RankTwoInvariant.html">ADRankTwoInvariant</a>Compute a invariant property of a RankTwoTensor</li><li class="collection-item"><a href="source/materials/RankTwoSphericalComponent.html">ADRankTwoSphericalComponent</a>Compute components of a rank-2 tensor in a spherical coordinate system</li><li class="collection-item"><a href="source/materials/ScalarMaterialDamage.html">ADScalarMaterialDamage</a>Scalar damage model for which the damage is prescribed by another material</li><li class="collection-item"><a href="source/materials/StrainEnergyDensity.html">ADStrainEnergyDensity</a>Computes the strain energy density using a combination of the elastic and inelastic components of the strain increment, which is a valid assumption for monotonic behavior.</li><li class="collection-item"><a href="source/materials/StrainEnergyRateDensity.html">ADStrainEnergyRateDensity</a>Computes the strain energy density rate using a combination of the elastic and inelastic components of the strain increment, which is a valid assumption for monotonic behavior.</li><li class="collection-item"><a href="source/materials/ADComputeFiniteStrain.html">ADSymmetricFiniteStrain</a>Compute a strain increment and rotation increment for finite strains.</li><li class="collection-item"><a href="source/materials/ADComputeFiniteStrainElasticStress.html">ADSymmetricFiniteStrainElasticStress</a>Compute stress using elasticity for finite strains</li><li class="collection-item"><a href="source/materials/ADComputeIncrementalSmallStrain.html">ADSymmetricIncrementalSmallStrain</a>Compute a strain increment and rotation increment for small strains.</li><li class="collection-item"><a href="source/materials/ComputeIsotropicElasticityTensor.html">ADSymmetricIsotropicElasticityTensor</a>Compute a constant isotropic elasticity tensor.</li><li class="collection-item"><a href="source/materials/ADComputeLinearElasticStress.html">ADSymmetricLinearElasticStress</a>Compute stress using elasticity for small strains</li><li class="collection-item"><a href="source/materials/ADComputeSmallStrain.html">ADSymmetricSmallStrain</a>Compute a small strain.</li><li class="collection-item"><a href="source/materials/TemperatureDependentHardeningStressUpdate.html">ADTemperatureDependentHardeningStressUpdate</a>Computes the stress as a function of temperature and plastic strain from user-supplied hardening functions. This class can be used in conjunction with other creep and plasticity materials for more complex simulations</li><li class="collection-item"><a href="source/materials/ADViscoplasticityStressUpdate.html">ADViscoplasticityStressUpdate</a>This material computes the non-linear homogenized gauge stress in order to compute the viscoplastic responce due to creep in porous materials. This material must be used in conjunction with ADComputeMultiplePorousInelasticStress</li><li class="collection-item"><a href="source/materials/abaqus/AbaqusUMATStress.html">AbaqusUMATStress</a>Coupling material to use Abaqus UMAT models in MOOSE</li><li class="collection-item"><a href="source/materials/AbruptSoftening.html">AbruptSoftening</a>Softening model with an abrupt stress release upon cracking. This class is intended to be used with ComputeSmearedCrackingStress.</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/BiLinearMixedModeTraction.html">BiLinearMixedModeTraction</a>Mixed mode bilinear traction separation law.</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/CZMComputeDisplacementJumpSmallStrain.html">CZMComputeDisplacementJumpSmallStrain</a>Compute the total displacement jump across a czm interface in local coordinates for the Small Strain kinematic formulation</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/CZMComputeDisplacementJumpTotalLagrangian.html">CZMComputeDisplacementJumpTotalLagrangian</a>Compute the displacement jump increment across a czm interface in local coordinates for the Total Lagrangian kinematic formulation</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/CZMComputeGlobalTractionSmallStrain.html">CZMComputeGlobalTractionSmallStrain</a>Computes the czm traction in global coordinates for a small strain kinematic formulation</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/CZMComputeGlobalTractionTotalLagrangian.html">CZMComputeGlobalTractionTotalLagrangian</a>Compute the equilibrium traction (PK1) and its derivatives for the Total Lagrangian formulation.</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/CZMRealVectorCartesianComponent.html">CZMRealVectorCartesianComponent</a>Access a component of a RealVectorValue defined on a cohesive zone</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/CZMRealVectorScalar.html">CZMRealVectorScalar</a>Compute the normal or tangent component of a vector quantity defined on a cohesive interface.</li><li class="collection-item"><a href="source/materials/CappedDruckerPragerCosseratStressUpdate.html">CappedDruckerPragerCosseratStressUpdate</a>Capped Drucker-Prager plasticity stress calculator for the Cosserat situation where the host medium (ie, the limit where all Cosserat effects are zero) is isotropic.  Note that the return-map flow rule uses an isotropic elasticity tensor built with the &#x27;host&#x27; properties defined by the user.</li><li class="collection-item"><a href="source/materials/CappedDruckerPragerStressUpdate.html">CappedDruckerPragerStressUpdate</a>Capped Drucker-Prager plasticity stress calculator</li><li class="collection-item"><a href="source/materials/CappedMohrCoulombCosseratStressUpdate.html">CappedMohrCoulombCosseratStressUpdate</a>Capped Mohr-Coulomb plasticity stress calculator for the Cosserat situation where the host medium (ie, the limit where all Cosserat effects are zero) is isotropic.  Note that the return-map flow rule uses an isotropic elasticity tensor built with the &#x27;host&#x27; properties defined by the user.</li><li class="collection-item"><a href="source/materials/CappedMohrCoulombStressUpdate.html">CappedMohrCoulombStressUpdate</a>Nonassociative, smoothed, Mohr-Coulomb plasticity capped with tensile (Rankine) and compressive caps, with hardening/softening</li><li class="collection-item"><a href="source/materials/CappedWeakInclinedPlaneStressUpdate.html">CappedWeakInclinedPlaneStressUpdate</a>Capped weak inclined plane plasticity stress calculator</li><li class="collection-item"><a href="source/materials/CappedWeakPlaneCosseratStressUpdate.html">CappedWeakPlaneCosseratStressUpdate</a>Capped weak-plane plasticity Cosserat stress calculator</li><li class="collection-item"><a href="source/materials/CappedWeakPlaneStressUpdate.html">CappedWeakPlaneStressUpdate</a>Capped weak-plane plasticity stress calculator</li><li class="collection-item"><a href="source/materials/CombinedScalarDamage.html">CombinedScalarDamage</a>Scalar damage model which is computed as a function of multiple scalar damage models</li><li class="collection-item"><a href="source/materials/CompositeEigenstrain.html">CompositeEigenstrain</a>Assemble an Eigenstrain tensor from multiple tensor contributions weighted by material properties</li><li class="collection-item"><a href="source/materials/CompositeElasticityTensor.html">CompositeElasticityTensor</a>Assemble an elasticity tensor from multiple tensor contributions weighted by material properties</li><li class="collection-item"><a href="source/materials/ComputeAxisymmetric1DFiniteStrain.html">ComputeAxisymmetric1DFiniteStrain</a>Compute a strain increment and rotation increment for finite strains in an axisymmetric 1D problem</li><li class="collection-item"><a href="source/materials/ComputeAxisymmetric1DIncrementalStrain.html">ComputeAxisymmetric1DIncrementalStrain</a>Compute strain increment for small strains in an axisymmetric 1D problem</li><li class="collection-item"><a href="source/materials/ComputeAxisymmetric1DSmallStrain.html">ComputeAxisymmetric1DSmallStrain</a>Compute a small strain in an Axisymmetric 1D problem</li><li class="collection-item"><a href="source/materials/ComputeAxisymmetricRZFiniteStrain.html">ComputeAxisymmetricRZFiniteStrain</a>Compute a strain increment for finite strains under axisymmetric assumptions.</li><li class="collection-item"><a href="source/materials/ComputeAxisymmetricRZIncrementalStrain.html">ComputeAxisymmetricRZIncrementalStrain</a>Compute a strain increment and rotation increment for small strains under axisymmetric assumptions.</li><li class="collection-item"><a href="source/materials/ComputeAxisymmetricRZSmallStrain.html">ComputeAxisymmetricRZSmallStrain</a>Compute a small strain in an Axisymmetric geometry</li><li class="collection-item"><a href="source/materials/ComputeBeamResultants.html">ComputeBeamResultants</a>Compute forces and moments using elasticity</li><li class="collection-item"><a href="source/materials/ComputeConcentrationDependentElasticityTensor.html">ComputeConcentrationDependentElasticityTensor</a>Compute concentration dependent elasticity tensor.</li><li class="collection-item"><a href="source/materials/ComputeCosseratElasticityTensor.html">ComputeCosseratElasticityTensor</a>Compute Cosserat elasticity and flexural bending rigidity tensors</li><li class="collection-item"><a href="source/materials/ComputeCosseratIncrementalSmallStrain.html">ComputeCosseratIncrementalSmallStrain</a>Compute incremental small Cosserat strains</li><li class="collection-item"><a href="source/materials/ComputeCosseratLinearElasticStress.html">ComputeCosseratLinearElasticStress</a>Compute Cosserat stress and couple-stress elasticity for small strains</li><li class="collection-item"><a href="source/materials/ComputeCosseratSmallStrain.html">ComputeCosseratSmallStrain</a>Compute small Cosserat strains</li><li class="collection-item"><a href="source/materials/ComputeCrackedStress.html">ComputeCrackedStress</a>Computes energy and modifies the stress for phase field fracture</li><li class="collection-item"><a href="source/materials/crystal_plasticity/ComputeCrystalPlasticityThermalEigenstrain.html">ComputeCrystalPlasticityThermalEigenstrain</a></li><li class="collection-item"><a href="source/materials/ComputeDamageStress.html">ComputeDamageStress</a>Compute stress for damaged elastic materials in conjunction with a damage model.</li><li class="collection-item"><a href="source/materials/ComputeDeformGradBasedStress.html">ComputeDeformGradBasedStress</a>Computes stress based on Lagrangian strain</li><li class="collection-item"><a href="source/materials/ComputeDilatationThermalExpansionFunctionEigenstrain.html">ComputeDilatationThermalExpansionFunctionEigenstrain</a>Computes eigenstrain due to thermal expansion using a function that describes the total dilatation as a function of temperature</li><li class="collection-item"><a href="source/materials/ComputeEigenstrain.html">ComputeEigenstrain</a>Computes a constant Eigenstrain</li><li class="collection-item"><a href="source/materials/ComputeEigenstrainBeamFromVariable.html">ComputeEigenstrainBeamFromVariable</a>Computes an eigenstrain from a set of variables</li><li class="collection-item"><a href="source/materials/ComputeEigenstrainFromInitialStress.html">ComputeEigenstrainFromInitialStress</a>Computes an eigenstrain from an initial stress</li><li class="collection-item"><a href="source/materials/ComputeElasticityBeam.html">ComputeElasticityBeam</a>Computes the equivalent of the elasticity tensor for the beam element, which are vectors of material translational and flexural stiffness.</li><li class="collection-item"><a href="source/materials/ComputeElasticityTensor.html">ComputeElasticityTensor</a>Compute an elasticity tensor.</li><li class="collection-item"><a href="source/materials/crystal_plasticity/ComputeElasticityTensorCP.html">ComputeElasticityTensorCP</a>Compute an elasticity tensor for crystal plasticity.</li><li class="collection-item"><a href="source/materials/crystal_plasticity/ComputeElasticityTensorConstantRotationCP.html">ComputeElasticityTensorConstantRotationCP</a>Deprecated Class: please use ComputeElasticityTensorCP instead. Compute an elasticity tensor for crystal plasticity, formulated in the reference frame, with constant Euler angles.</li><li class="collection-item"><a href="source/materials/ComputeExtraStressConstant.html">ComputeExtraStressConstant</a>Computes a constant extra stress that is added to the stress calculated by the constitutive model</li><li class="collection-item"><a href="source/materials/ComputeExtraStressVDWGas.html">ComputeExtraStressVDWGas</a>Computes a hydrostatic stress corresponding to the pressure of a van der Waals gas that is added as an extra_stress to the stress computed by the constitutive model</li><li class="collection-item"><a href="source/materials/ComputeFiniteBeamStrain.html">ComputeFiniteBeamStrain</a>Compute a rotation increment for finite rotations of the beam and computes the small/large strain increments in the current rotated configuration of the beam.</li><li class="collection-item"><a href="source/materials/ComputeFiniteStrain.html">ComputeFiniteStrain</a>Compute a strain increment and rotation increment for finite strains.</li><li class="collection-item"><a href="source/materials/ComputeFiniteStrainElasticStress.html">ComputeFiniteStrainElasticStress</a>Compute stress using elasticity for finite strains</li><li class="collection-item"><a href="source/materials/ComputeGlobalStrain.html">ComputeGlobalStrain</a>Material for storing the global strain values from the scalar variable</li><li class="collection-item"><a href="source/materials/lagrangian/ComputeHomogenizedLagrangianStrain.html">ComputeHomogenizedLagrangianStrain</a></li><li class="collection-item"><a href="source/materials/lagrangian/ComputeHypoelasticStVenantKirchhoffStress.html">ComputeHypoelasticStVenantKirchhoffStress</a>Calculate a small strain elastic stress that is equivalent to the hyperelastic St. Venant-Kirchhoff model if integrated using the Truesdell rate.</li><li class="collection-item"><a href="source/materials/ComputeIncrementalBeamStrain.html">ComputeIncrementalBeamStrain</a>Compute a infinitesimal/large strain increment for the beam.</li><li class="collection-item"><a href="source/materials/ComputeIncrementalSmallStrain.html">ComputeIncrementalSmallStrain</a>Compute a strain increment and rotation increment for small strains.</li><li class="collection-item"><a href="source/materials/ComputeInstantaneousThermalExpansionFunctionEigenstrain.html">ComputeInstantaneousThermalExpansionFunctionEigenstrain</a>Computes eigenstrain due to thermal expansion using a function that describes the instantaneous thermal expansion as a function of temperature</li><li class="collection-item"><a href="source/materials/ComputeInterfaceStress.html">ComputeInterfaceStress</a>Stress in the plane of an interface defined by the gradient of an order parameter</li><li class="collection-item"><a href="source/materials/ComputeIsotropicElasticityTensor.html">ComputeIsotropicElasticityTensor</a>Compute a constant isotropic elasticity tensor.</li><li class="collection-item"><a href="source/materials/lagrangian/ComputeLagrangianLinearElasticStress.html">ComputeLagrangianLinearElasticStress</a>Stress update based on the small (engineering) stress</li><li class="collection-item"><a href="source/materials/lagrangian/ComputeLagrangianStrain.html">ComputeLagrangianStrain</a>Compute strain in Cartesian coordinates.</li><li class="collection-item"><a href="source/materials/lagrangian/ComputeLagrangianStrainAxisymmetricCylindrical.html">ComputeLagrangianStrainAxisymmetricCylindrical</a>Compute strain in 2D axisymmetric RZ coordinates.</li><li class="collection-item"><a href="source/materials/lagrangian/ComputeLagrangianStrainCentrosymmetricSpherical.html">ComputeLagrangianStrainCentrosymmetricSpherical</a>Compute strain in centrosymmetric spherical coordinates.</li><li class="collection-item"><a href="source/materials/lagrangian/ComputeLagrangianWPSStrain.html">ComputeLagrangianWPSStrain</a>Compute strain in Cartesian coordinates.</li><li class="collection-item"><a href="source/materials/lagrangian/ComputeLagrangianWrappedStress.html">ComputeLagrangianWrappedStress</a>Stress update based on the small (engineering) stress</li><li class="collection-item"><a href="source/materials/ComputeLayeredCosseratElasticityTensor.html">ComputeLayeredCosseratElasticityTensor</a>Computes Cosserat elasticity and flexural bending rigidity tensors relevant for simulations with layered materials.  The layering direction is assumed to be perpendicular to the &#x27;z&#x27; direction.</li><li class="collection-item"><a href="source/materials/ComputeLinearElasticPFFractureStress.html">ComputeLinearElasticPFFractureStress</a>Computes the stress and free energy derivatives for the phase field fracture model, with small strain</li><li class="collection-item"><a href="source/materials/ComputeLinearElasticStress.html">ComputeLinearElasticStress</a>Compute stress using elasticity for small strains</li><li class="collection-item"><a href="source/materials/ComputeLinearViscoelasticStress.html">ComputeLinearViscoelasticStress</a>Divides total strain into elastic + creep + eigenstrains</li><li class="collection-item"><a href="source/materials/ComputeMeanThermalExpansionFunctionEigenstrain.html">ComputeMeanThermalExpansionFunctionEigenstrain</a>Computes eigenstrain due to thermal expansion using a function that describes the mean thermal expansion as a function of temperature</li><li class="collection-item"><a href="source/materials/ComputeMultiPlasticityStress.html">ComputeMultiPlasticityStress</a>Material for multi-surface finite-strain plasticity</li><li class="collection-item"><a href="source/materials/crystal_plasticity/ComputeMultipleCrystalPlasticityStress.html">ComputeMultipleCrystalPlasticityStress</a>Crystal Plasticity base class: handles the Newton iteration over the stress residual and calculates the Jacobian based on constitutive laws from multiple material classes that are inherited from CrystalPlasticityStressUpdateBase</li><li class="collection-item"><a href="source/materials/ComputeMultipleInelasticCosseratStress.html">ComputeMultipleInelasticCosseratStress</a>Compute state (stress and other quantities such as plastic strains and internal parameters) using an iterative process, as well as Cosserat versions of these quantities.  Only elasticity is currently implemented for the Cosserat versions.Combinations of creep models and plastic models may be used</li><li class="collection-item"><a href="source/materials/ComputeMultipleInelasticStress.html">ComputeMultipleInelasticStress</a>Compute state (stress and internal parameters such as plastic strains and internal parameters) using an iterative process.  Combinations of creep models and plastic models may be used.</li><li class="collection-item"><a href="source/materials/lagrangian/ComputeNeoHookeanStress.html">ComputeNeoHookeanStress</a>Stress update based on the first Piola-Kirchhoff stress</li><li class="collection-item"><a href="source/materials/ComputePlaneFiniteStrain.html">ComputePlaneFiniteStrain</a>Compute strain increment and rotation increment for finite strain under 2D planar assumptions.</li><li class="collection-item"><a href="source/materials/ComputePlaneIncrementalStrain.html">ComputePlaneIncrementalStrain</a>Compute strain increment for small strain under 2D planar assumptions.</li><li class="collection-item"><a href="source/materials/ComputePlaneSmallStrain.html">ComputePlaneSmallStrain</a>Compute a small strain under generalized plane strain assumptions where the out of plane strain is generally nonzero.</li><li class="collection-item"><a href="source/materials/ComputePlasticHeatEnergy.html">ComputePlasticHeatEnergy</a>Plastic heat energy density = stress * plastic_strain_rate</li><li class="collection-item"><a href="source/materials/ComputeRSphericalFiniteStrain.html">ComputeRSphericalFiniteStrain</a>Compute a strain increment and rotation increment for finite strains in 1D spherical symmetry problems.</li><li class="collection-item"><a href="source/materials/ComputeRSphericalIncrementalStrain.html">ComputeRSphericalIncrementalStrain</a>Compute a strain increment for incremental strains in 1D spherical symmetry problems.</li><li class="collection-item"><a href="source/materials/ComputeRSphericalSmallStrain.html">ComputeRSphericalSmallStrain</a>Compute a small strain 1D spherical symmetry case.</li><li class="collection-item"><a href="source/materials/ComputeReducedOrderEigenstrain.html">ComputeReducedOrderEigenstrain</a>accepts eigenstrains and computes a reduced order eigenstrain for consistency in the order of strain and eigenstrains.</li><li class="collection-item"><a href="source/materials/lagrangian/ComputeSimoHughesJ2PlasticityStress.html">ComputeSimoHughesJ2PlasticityStress</a>The Simo-Hughes style J2 plasticity.</li><li class="collection-item"><a href="source/materials/ComputeSmallStrain.html">ComputeSmallStrain</a>Compute a small strain.</li><li class="collection-item"><a href="source/materials/ComputeSmearedCrackingStress.html">ComputeSmearedCrackingStress</a>Compute stress using a fixed smeared cracking model</li><li class="collection-item"><a href="source/materials/lagrangian/ComputeStVenantKirchhoffStress.html">ComputeStVenantKirchhoffStress</a>Stress update based on the first Piola-Kirchhoff stress</li><li class="collection-item"><a href="source/materials/ComputeStrainIncrementBasedStress.html">ComputeStrainIncrementBasedStress</a>Compute stress after subtracting inelastic strain increments</li><li class="collection-item"><a href="source/materials/ComputeSurfaceTensionKKS.html">ComputeSurfaceTensionKKS</a>Surface tension of an interface defined by the gradient of an order parameter</li><li class="collection-item"><a href="source/materials/ComputeThermalExpansionEigenstrain.html">ComputeThermalExpansionEigenstrain</a>Computes eigenstrain due to thermal expansion with a constant coefficient</li><li class="collection-item"><a href="source/materials/ComputeThermalExpansionEigenstrainBeam.html">ComputeThermalExpansionEigenstrainBeam</a>Computes eigenstrain due to thermal expansion with a constant coefficient</li><li class="collection-item"><a href="source/materials/crystal_plasticity/ComputeUpdatedEulerAngle.html">ComputeUpdatedEulerAngle</a>This class computes the updated Euler angle for crystal plasticity simulations. This needs to be used together with the  ComputeMultipleCrystalPlasticityStress class, where the updated rotation material property is computed. </li><li class="collection-item"><a href="source/materials/ComputeVariableBaseEigenStrain.html">ComputeVariableBaseEigenStrain</a>Computes Eigenstrain based on material property tensor base</li><li class="collection-item"><a href="source/materials/ComputeVariableEigenstrain.html">ComputeVariableEigenstrain</a>Computes an Eigenstrain and its derivatives that is a function of multiple variables, where the prefactor is defined in a derivative material</li><li class="collection-item"><a href="source/materials/ComputeVariableIsotropicElasticityTensor.html">ComputeVariableIsotropicElasticityTensor</a>Compute an isotropic elasticity tensor for elastic constants that change as a function of material properties</li><li class="collection-item"><a href="source/materials/ComputeVolumetricDeformGrad.html">ComputeVolumetricDeformGrad</a>Computes volumetric deformation gradient and adjusts the total deformation gradient</li><li class="collection-item"><a href="source/materials/ComputeVolumetricEigenstrain.html">ComputeVolumetricEigenstrain</a>Computes an eigenstrain that is defined by a set of scalar material properties that summed together define the volumetric change.  This also computes the derivatives of that eigenstrain with respect to a supplied set of variable dependencies.</li><li class="collection-item"><a href="source/materials/crystal_plasticity/CrystalPlasticityHCPDislocationSlipBeyerleinUpdate.html">CrystalPlasticityHCPDislocationSlipBeyerleinUpdate</a>Two-term dislocation slip model for hexagonal close packed crystals from Beyerline and Tome</li><li class="collection-item"><a href="source/materials/crystal_plasticity/CrystalPlasticityKalidindiUpdate.html">CrystalPlasticityKalidindiUpdate</a>Kalidindi version of homogeneous crystal plasticity.</li><li class="collection-item"><a href="source/materials/crystal_plasticity/CrystalPlasticityTwinningKalidindiUpdate.html">CrystalPlasticityTwinningKalidindiUpdate</a>Twinning propagation model based on Kalidindi&#x27;s treatment of twinning in a FCC material</li><li class="collection-item"><a href="source/materials/DensityScaling.html">DensityScaling</a></li><li class="collection-item"><a href="source/materials/EshelbyTensor.html">EshelbyTensor</a>Computes the Eshelby tensor as a function of strain energy density and the first Piola-Kirchhoff stress</li><li class="collection-item"><a href="source/materials/ExponentialSoftening.html">ExponentialSoftening</a>Softening model with an exponential softening response upon cracking. This class is intended to be used with ComputeSmearedCrackingStress.</li><li class="collection-item"><a href="source/materials/crystal_plasticity/FiniteStrainCPSlipRateRes.html">FiniteStrainCPSlipRateRes</a>Crystal Plasticity base class: FCC system with power law flow rule implemented</li><li class="collection-item"><a href="source/materials/crystal_plasticity/FiniteStrainCrystalPlasticity.html">FiniteStrainCrystalPlasticity</a>Crystal Plasticity base class: FCC system with power law flow rule implemented</li><li class="collection-item"><a href="source/materials/FiniteStrainHyperElasticViscoPlastic.html">FiniteStrainHyperElasticViscoPlastic</a>Material class for hyper-elastic viscoplatic flow: Can handle multiple flow models defined by flowratemodel type user objects</li><li class="collection-item"><a href="source/materials/FiniteStrainPlasticMaterial.html">FiniteStrainPlasticMaterial</a>Associative J2 plasticity with isotropic hardening.</li><li class="collection-item"><a href="source/materials/crystal_plasticity/FiniteStrainUObasedCP.html">FiniteStrainUObasedCP</a>UserObject based Crystal Plasticity system.</li><li class="collection-item"><a href="source/materials/FluxBasedStrainIncrement.html">FluxBasedStrainIncrement</a>Compute strain increment based on flux</li><li class="collection-item"><a href="source/materials/GBRelaxationStrainIncrement.html">GBRelaxationStrainIncrement</a>Compute strain increment based on lattice relaxation at GB</li><li class="collection-item"><a href="source/materials/GeneralizedKelvinVoigtModel.html">GeneralizedKelvinVoigtModel</a>Generalized Kelvin-Voigt model composed of a serial assembly of unit Kelvin-Voigt modules</li><li class="collection-item"><a href="source/materials/GeneralizedMaxwellModel.html">GeneralizedMaxwellModel</a>Generalized Maxwell model composed of a parallel assembly of unit Maxwell modules</li><li class="collection-item"><a href="source/materials/HillConstants.html">HillConstants</a>Build and rotate the Hill Tensor. It can be used with other Hill plasticity and creep materials.</li><li class="collection-item"><a href="source/materials/HillCreepStressUpdate.html">HillCreepStressUpdate</a>This class uses the stress update material in a generalized radial return anisotropic power law creep model.  This class can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/HillElastoPlasticityStressUpdate.html">HillElastoPlasticityStressUpdate</a>This class uses the generalized radial return for anisotropic elasto-plasticity model.This class can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/HillPlasticityStressUpdate.html">HillPlasticityStressUpdate</a>This class uses the generalized radial return for anisotropic plasticity model.This class can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/HyperElasticPhaseFieldIsoDamage.html">HyperElasticPhaseFieldIsoDamage</a>Computes damaged stress and energy in the intermediate configuration assuming isotropy</li><li class="collection-item"><a href="source/materials/HyperbolicViscoplasticityStressUpdate.html">HyperbolicViscoplasticityStressUpdate</a>This class uses the discrete material for a hyperbolic sine viscoplasticity model in which the effective plastic strain is solved for using a creep approach.</li><li class="collection-item"><a href="source/materials/InclusionProperties.html">InclusionProperties</a></li><li class="collection-item"><a href="source/materials/IsotropicPlasticityStressUpdate.html">IsotropicPlasticityStressUpdate</a>This class uses the discrete material in a radial return isotropic plasticity model.  This class is one of the basic radial return constitutive models, yet it can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/IsotropicPowerLawHardeningStressUpdate.html">IsotropicPowerLawHardeningStressUpdate</a>This class uses the discrete material in a radial return isotropic plasticity power law hardening model, solving for the yield stress as the intersection of the power law relation curve and Hooke&#x27;s law.  This class can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/LAROMANCEPartitionStressUpdateBase.html">LAROMANCEPartitionStressUpdate</a>LAROMANCE base class for partitioned reduced order models</li><li class="collection-item"><a href="source/materials/LAROMANCEStressUpdateBase.html">LAROMANCEStressUpdate</a>Base class to calculate the effective creep strain based on the rates predicted by a material  specific Los Alamos Reduced Order Model derived from a Visco-Plastic Self Consistent calculations.</li><li class="collection-item"><a href="source/materials/LinearElasticTruss.html">LinearElasticTruss</a>Computes the linear elastic strain for a truss element</li><li class="collection-item"><a href="source/materials/LinearViscoelasticStressUpdate.html">LinearViscoelasticStressUpdate</a>Calculates an admissible state (stress that lies on or within the yield surface, plastic strains, internal parameters, etc).  This class is intended to be a parent class for classes with specific constitutive models.</li><li class="collection-item"><a href="source/materials/MultiPhaseStressMaterial.html">MultiPhaseStressMaterial</a>Compute a global stress form multiple phase stresses</li><li class="collection-item"><a href="source/materials/NonlocalDamage.html">NonlocalDamage</a>Nonlocal damage model. Given an RadialAverage UO this creates a new damage index that can be used as for ComputeDamageStress without havign to change existing local damage models.</li><li class="collection-item"><a href="source/materials/PlasticTruss.html">PlasticTruss</a>Computes the stress and strain for a truss element with plastic behavior defined by either linear hardening or a user-defined hardening function.</li><li class="collection-item"><a href="source/materials/PorosityFromStrain.html">PorosityFromStrain</a>Porosity calculation from the inelastic strain.</li><li class="collection-item"><a href="source/materials/PowerLawCreepStressUpdate.html">PowerLawCreepStressUpdate</a>This class uses the stress update material in a radial return isotropic power law creep model. This class can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/PowerLawSoftening.html">PowerLawSoftening</a>Softening model with an abrupt stress release upon cracking. This class is intended to be used with ComputeSmearedCrackingStress.</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/PureElasticTractionSeparation.html">PureElasticTractionSeparation</a>Pure elastic traction separation law.</li><li class="collection-item"><a href="source/materials/RankTwoCartesianComponent.html">RankTwoCartesianComponent</a>Access a component of a RankTwoTensor</li><li class="collection-item"><a href="source/materials/RankTwoCylindricalComponent.html">RankTwoCylindricalComponent</a>Compute components of a rank-2 tensor in a cylindrical coordinate system</li><li class="collection-item"><a href="source/materials/RankTwoDirectionalComponent.html">RankTwoDirectionalComponent</a>Compute a Direction scalar property of a RankTwoTensor</li><li class="collection-item"><a href="source/materials/RankTwoInvariant.html">RankTwoInvariant</a>Compute a invariant property of a RankTwoTensor</li><li class="collection-item"><a href="source/materials/RankTwoSphericalComponent.html">RankTwoSphericalComponent</a>Compute components of a rank-2 tensor in a spherical coordinate system</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/SalehaniIrani3DCTraction.html">SalehaniIrani3DCTraction</a>3D Coupled (3DC) cohesive law of Salehani and Irani with no damage</li><li class="collection-item"><a href="source/materials/ScalarMaterialDamage.html">ScalarMaterialDamage</a>Scalar damage model for which the damage is prescribed by another material</li><li class="collection-item"><a href="source/materials/StrainEnergyDensity.html">StrainEnergyDensity</a>Computes the strain energy density using a combination of the elastic and inelastic components of the strain increment, which is a valid assumption for monotonic behavior.</li><li class="collection-item"><a href="source/materials/StrainEnergyRateDensity.html">StrainEnergyRateDensity</a>Computes the strain energy density rate using a combination of the elastic and inelastic components of the strain increment, which is a valid assumption for monotonic behavior.</li><li class="collection-item"><a href="source/materials/StressBasedChemicalPotential.html">StressBasedChemicalPotential</a>Chemical potential from stress</li><li class="collection-item"><a href="source/materials/SumTensorIncrements.html">SumTensorIncrements</a>Compute tensor property by summing tensor increments</li><li class="collection-item"><a href="source/materials/ComputeIsotropicElasticityTensor.html">SymmetricIsotropicElasticityTensor</a>Compute a constant isotropic elasticity tensor.</li><li class="collection-item"><a href="source/materials/TemperatureDependentHardeningStressUpdate.html">TemperatureDependentHardeningStressUpdate</a>Computes the stress as a function of temperature and plastic strain from user-supplied hardening functions. This class can be used in conjunction with other creep and plasticity materials for more complex simulations</li><li class="collection-item"><a href="source/materials/TensileStressUpdate.html">TensileStressUpdate</a>Associative, smoothed, tensile (Rankine) plasticity with hardening/softening</li><li class="collection-item"><a href="source/materials/ThermalFractureIntegral.html">ThermalFractureIntegral</a>Calculates summation of the derivative of the eigenstrains with respect to temperature.</li><li class="collection-item"><a href="source/materials/TwoPhaseStressMaterial.html">TwoPhaseStressMaterial</a>Compute a global stress in a two phase model</li><li class="collection-item"><a href="source/materials/VolumeDeformGradCorrectedStress.html">VolumeDeformGradCorrectedStress</a>Transforms stress with volumetric term from previous configuration to this configuration</li><li class="collection-header">Rdg App</li><li class="collection-item"><a href="source/materials/AEFVMaterial.html">AEFVMaterial</a>A material kernel for the advection equation using a cell-centered finite volume method.</li><li class="collection-header">Heat Conduction App</li><li class="collection-item"><a href="source/materials/AnisoHeatConductionMaterial.html">ADAnisoHeatConductionMaterial</a>General-purpose material model for anisotropic heat conduction</li><li class="collection-item"><a href="source/materials/ElectricalConductivity.html">ADElectricalConductivity</a>Calculates resistivity and electrical conductivity as a function of temperature, using copper for parameter defaults.</li><li class="collection-item"><a href="source/materials/HeatConductionMaterial.html">ADHeatConductionMaterial</a>General-purpose material model for heat conduction</li><li class="collection-item"><a href="source/materials/AnisoHeatConductionMaterial.html">AnisoHeatConductionMaterial</a>General-purpose material model for anisotropic heat conduction</li><li class="collection-item"><a href="source/materials/ElectricalConductivity.html">ElectricalConductivity</a>Calculates resistivity and electrical conductivity as a function of temperature, using copper for parameter defaults.</li><li class="collection-item"><a href="source/materials/FunctionPathEllipsoidHeatSource.html">FunctionPathEllipsoidHeatSource</a>Double ellipsoid volumetric source heat with function path.</li><li class="collection-item"><a href="source/materials/GapConductance.html">GapConductance</a></li><li class="collection-item"><a href="source/materials/GapConductanceConstant.html">GapConductanceConstant</a>Material to compute a constant, prescribed gap conductance</li><li class="collection-item"><a href="source/materials/HeatConductionMaterial.html">HeatConductionMaterial</a>General-purpose material model for heat conduction</li><li class="collection-item"><a href="source/materials/SemiconductorLinearConductivity.html">SemiconductorLinearConductivity</a>Calculates electrical conductivity of a semiconductor from temperature</li><li class="collection-item"><a href="source/materials/SideSetHeatTransferMaterial.html">SideSetHeatTransferMaterial</a>This material constructs the necessary coefficients and properties for SideSetHeatTransferKernel.</li><li class="collection-header">Fluid Properties App</li><li class="collection-item"><a href="source/materials/SaturationPressureMaterial.html">ADSaturationPressureMaterial</a>Computes saturation pressure at some temperature.</li><li class="collection-item"><a href="source/materials/ADSaturationTemperatureMaterial.html">ADSaturationTemperatureMaterial</a>Computes saturation temperature at some pressure</li><li class="collection-item"><a href="source/materials/ADSurfaceTensionMaterial.html">ADSurfaceTensionMaterial</a>Computes surface tension at some temperature</li><li class="collection-item"><a href="source/materials/FluidPropertiesMaterialVE.html">FluidPropertiesMaterial</a>Computes fluid properties using (specific internal energy, specific volume) formulation</li><li class="collection-item"><a href="source/materials/FluidPropertiesMaterialPT.html">FluidPropertiesMaterialPT</a>Fluid properties using the (pressure, temperature) formulation</li><li class="collection-item"><a href="source/materials/FluidPropertiesMaterialVE.html">FluidPropertiesMaterialVE</a>Computes fluid properties using (specific internal energy, specific volume) formulation</li><li class="collection-item"><a href="source/materials/SaturationPressureMaterial.html">SaturationPressureMaterial</a>Computes saturation pressure at some temperature.</li><li class="collection-item"><a href="source/materials/SodiumPropertiesMaterial.html">SodiumPropertiesMaterial</a>Material properties for liquid sodium sampled from SodiumProperties.</li><li class="collection-header">Eel App</li><li class="collection-item"><a href="source/materials/electrodynamics/BulkChargeTransport.html">BulkChargeTransport</a>This class computes the electrical energy density and its corresponding thermodynamic forces. We assume the electrical energy density depends on at least the deformation gradient and the gradient of electrical potential This class defines the electrical potential for charge transfer in the bulk</li><li class="collection-item"><a href="source/materials/forces/CauchyStress.html">CauchyStress</a>This class computes the Cauchy stress given the PK1 stress</li><li class="collection-item"><a href="source/materials/electrodynamics/ChargeTransferReaction.html">ChargeTransferReaction</a>The Butler-Volmer condition for current density across the electrode/electrolyte interface.</li><li class="collection-item"><a href="source/materials/chemistry/ChemicalPotential.html">ChemicalPotential</a>This class defines the mass flux.</li><li class="collection-item"><a href="source/materials/forces/CurrentDensity.html">CurrentDensity</a>This class computes the current density associated with given energy densities.</li><li class="collection-item"><a href="source/materials/kinematics/DeformationGradient.html">DeformationGradient</a>This class computes the deformation gradient. The F-bar approach can optionally be used to correct volumetric locking.</li><li class="collection-item"><a href="source/materials/chemistry/EntropicChemicalEnergyDensity.html">EntropicChemicalEnergyDensity</a>This class computes the chemical energy density and its corresponding thermodynamic forces. We assume the chemical energy density depends on the chemical concentration.</li><li class="collection-item"><a href="source/materials/forces/FirstPiolaKirchhoffStress.html">FirstPiolaKirchhoffStress</a>This class computes the first Piola-Kirchhoff stress associated with given energy densities.</li><li class="collection-item"><a href="source/materials/thermology/FourierPotential.html">FourierPotential</a>This class computes the thermal energy density and its corresponding thermodynamic forces. We assume the thermal energy density depends on the gradient of log temperature. This class defines the Fourier potential for heat conduction.</li><li class="collection-item"><a href="source/materials/forces/HeatFlux.html">HeatFlux</a>This class computes the heat flux associated with given energy densities for a given species.</li><li class="collection-item"><a href="source/materials/mechanics/InterfaceTractionWithCreepDegradation.html">InterfaceTractionWithCreepDegradation</a>Base class for implementing cohesive zone constituive material models that can be formulated using the total displacement jump</li><li class="collection-item"><a href="source/materials/electrodynamics/JouleHeating.html">JouleHeating</a>This class computes volumetric heat source due to Joule heating from electric displacement.</li><li class="collection-item"><a href="source/materials/chemistry/MassDiffusion.html">MassDiffusion</a>This class computes the dual chemical energy density and its corresponding thermodynamic forces. We assume the dual chemical energy density depends on the gradient of chemical potential.</li><li class="collection-item"><a href="source/materials/forces/MassFlux.html">MassFlux</a>This class computes the mass flux associated with given energy densities for a given species.</li><li class="collection-item"><a href="source/materials/forces/MassSource.html">MassSource</a>This class computes the mass source associated with given energy densities for a given species.</li><li class="collection-item"><a href="source/materials/kinematics/MechanicalDeformationGradient.html">MechanicalDeformationGradient</a>This class computes the deformation gradient. The F-bar approach can optionally be used to correct volumetric locking. Eigen deformation gradients are extracted from the total deformation gradient.</li><li class="collection-item"><a href="source/materials/kinematics/MechanicalStrain.html">MechanicalStrain</a>Compute mechanical strain by subtracting eigenstrains from the total strain</li><li class="collection-item"><a href="source/materials/electrochemistry/Migration.html">Migration</a>This class computes the electrochemical energy density and its corresponding thermodynamic forces. We assume the electrochemical energy density depends on the gradients of electrical potential and chemical potential This class defines the electrochemical potential for the migration mechanism</li><li class="collection-item"><a href="source/materials/mechanics/NeoHookeanSolid.html">NeoHookeanSolid</a>This class computes the elastic energy density and its corresponding thermodynamic forces. We assume the mechanical energy density depends on the mechanical deformation gradient. This class defines the Neo-Hookean elastic energy density.</li><li class="collection-item"><a href="source/materials/mechanics/SDElasticEnergyDensity.html">SDElasticEnergyDensity</a>This class defines the small deformation elastic energy density.</li><li class="collection-item"><a href="source/materials/forces/SDStress.html">SDStress</a>This class computes the small deformation Cauchy stress associated with given energy densities.</li><li class="collection-item"><a href="source/materials/chemistry/SEIGrowth.html">SEIGrowth</a>This object models the growth of solid electrolyte interphase (SEI).</li><li class="collection-item"><a href="source/materials/kinematics/Strain.html">Strain</a>This class computes the total strain. The F-bar approach can optionally be used to correct volumetric locking.</li><li class="collection-item"><a href="source/materials/kinematics/SwellingDeformationGradient.html">SwellingDeformationGradient</a>This class computes the eigen deformation gradient due to swelling.</li><li class="collection-item"><a href="source/materials/kinematics/SwellingStrain.html">SwellingStrain</a>This class computes the eigenstrain due to swelling.</li><li class="collection-item"><a href="source/materials/kinematics/ThermalDeformationGradient.html">ThermalDeformationGradient</a>This class computes the thermal deformation gradient.</li><li class="collection-item"><a href="source/materials/forces/VariationalHeatSource.html">VariationalHeatSource</a>This class computes the heat source associated with given energy densities for a given species.</li><li class="collection-item"><a href="source/materials/mechanics/WeldedInterfaceTraction.html">WeldedInterfaceTraction</a>Base class for implementing cohesive zone constituive material models that can be formulated using the total displacement jump</li></ul></section><section class="scrollspy" id="0b3b7d96-845f-44d1-bd6b-6ee83abde6e2" data-section-level="2" data-section-text="GlobalParams"><h2 id="globalparams"><a href="syntax/GlobalParams/index.html">GlobalParams</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/GlobalParamsAction.html">GlobalParamsAction</a>Action used to aid in the application of parameters defined in the GlobalParams input block.</li></ul></section><section class="scrollspy" id="85e381b8-b57c-41ff-9616-caddef737c26" data-section-level="2" data-section-text="GrayDiffuseRadiation"><h2 id="graydiffuseradiation"><a href="syntax/GrayDiffuseRadiation/index.html">GrayDiffuseRadiation</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Heat Conduction App</li><li class="collection-item"><a href="source/actions/RadiationTransferAction.html">RadiationTransferAction</a>This action sets up the net radiation calculation between specified sidesets.</li></ul></section><section class="scrollspy" id="496be166-bc01-4198-a23d-4d8a7f09b5c4" data-section-level="2" data-section-text="ICs"><h2 id="ics"><a href="syntax/ICs/index.html">ICs</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddInitialConditionAction.html">AddInitialConditionAction</a>Add an InitialCondition object to the simulation.</li><li class="collection-item"><a href="source/ics/ArrayConstantIC.html">ArrayConstantIC</a>Sets constant component values for an array field variable.</li><li class="collection-item"><a href="source/ics/ArrayFunctionIC.html">ArrayFunctionIC</a>An initial condition that uses a normal function of x, y, z to produce values (and optionally gradients) for a field variable.</li><li class="collection-item"><a href="source/ics/BoundingBoxIC.html">BoundingBoxIC</a>BoundingBoxIC allows setting the initial condition of a value inside and outside of a specified box. The box is aligned with the x, y, z axes</li><li class="collection-item"><a href="source/ics/ConstantIC.html">ConstantIC</a>Sets a constant field value.</li><li class="collection-item"><a href="source/ics/FunctionIC.html">FunctionIC</a>An initial condition that uses a normal function of x, y, z to produce values (and optionally gradients) for a field variable.</li><li class="collection-item"><a href="source/ics/FunctionScalarIC.html">FunctionScalarIC</a>Initializes a scalar variable using a function.</li><li class="collection-item"><a href="source/ics/IntegralPreservingFunctionIC.html">IntegralPreservingFunctionIC</a>Function initial condition that preserves an integral</li><li class="collection-item"><a href="source/ics/RandomIC.html">RandomIC</a>Initialize a variable with randomly generated numbers following either a uniform distribution or a user-defined distribution</li><li class="collection-item"><a href="source/ics/ScalarComponentIC.html">ScalarComponentIC</a>Initial condition to set different values on each component of scalar variable.</li><li class="collection-item"><a href="source/ics/ScalarConstantIC.html">ScalarConstantIC</a>Initalize a scalar variable with a constant value prescribed by an input parameter.</li><li class="collection-item"><a href="source/ics/ScalarSolutionIC.html">ScalarSolutionIC</a>Sets the initial condition from a scalar variable stored in an Exodus file, retrieved by a SolutionUserObject</li><li class="collection-item"><a href="source/ics/ScalarSolutionIC.html">ScalarSolutionInitialCondition</a>Sets the initial condition from a scalar variable stored in an Exodus file, retrieved by a SolutionUserObject</li><li class="collection-item"><a href="source/ics/SolutionIC.html">SolutionIC</a>Sets the initial condition from a field variable stored in an Exodus file, retrieved by a SolutionUserObject</li><li class="collection-item"><a href="source/ics/SolutionIC.html">SolutionInitialCondition</a>Sets the initial condition from a field variable stored in an Exodus file, retrieved by a SolutionUserObject</li><li class="collection-item"><a href="source/ics/VectorConstantIC.html">VectorConstantIC</a>Sets constant component values for a vector field variable.</li><li class="collection-item"><a href="source/ics/VectorFunctionIC.html">VectorFunctionIC</a>Sets component values for a vector field variable based on a vector function.</li><li class="collection-header">Navier Stokes App</li><li class="collection-item"><a href="source/ics/NSFunctionInitialCondition.html">NSFunctionInitialCondition</a>Sets intial values for all variables.</li><li class="collection-item"><a href="source/ics/NSInitialCondition.html">NSInitialCondition</a>NSInitialCondition sets intial constant values for all variables.</li><li class="collection-item"><a href="source/ics/PNSInitialCondition.html">PNSInitialCondition</a>PNSInitialCondition sets intial constant values for any porous flow variable.</li><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/ics/VolumeWeightedWeibull.html">VolumeWeightedWeibull</a>Initialize a variable with randomly generated numbers following a volume-weighted Weibull distribution</li><li class="collection-header">Fluid Properties App</li><li class="collection-item"><a href="source/ics/RhoFromPressureTemperatureIC.html">RhoFromPressureTemperatureIC</a>Computes the density from pressure and temperature.</li><li class="collection-item"><a href="source/ics/RhoVaporMixtureFromPressureTemperatureIC.html">RhoVaporMixtureFromPressureTemperatureIC</a>Computes the density of a vapor mixture from pressure and temperature.</li><li class="collection-item"><a href="source/ics/SpecificEnthalpyFromPressureTemperatureIC.html">SpecificEnthalpyFromPressureTemperatureIC</a>Computes the specific enthalpy from pressure and temperature.</li></ul></section><section class="scrollspy" id="bec349ba-c25a-434e-a0d8-eb2a0c7168fe" data-section-level="2" data-section-text="InterfaceKernels"><h2 id="interfacekernels"><a href="syntax/InterfaceKernels/index.html">InterfaceKernels</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddInterfaceKernelAction.html">AddInterfaceKernelAction</a>Add an InterfaceKernel object to the simulation.</li><li class="collection-item"><a href="source/interfacekernels/PenaltyInterfaceDiffusion.html">ADPenaltyInterfaceDiffusion</a>A penalty-based interface condition that forcesthe continuity of variables and the flux equivalence across an interface.</li><li class="collection-item"><a href="source/interfacekernels/PenaltyInterfaceDiffusion.html">ADVectorPenaltyInterfaceDiffusion</a>A penalty-based interface condition that forcesthe continuity of variables and the flux equivalence across an interface.</li><li class="collection-item"><a href="source/interfacekernels/InterfaceDiffusion.html">InterfaceDiffusion</a>The kernel is utilized to establish flux equivalence on an interface for variables.</li><li class="collection-item"><a href="source/interfacekernels/InterfaceReaction.html">InterfaceReaction</a>Implements a reaction to establish ReactionRate=k_f*u-k_b*v at interface.</li><li class="collection-item"><a href="source/interfacekernels/PenaltyInterfaceDiffusion.html">PenaltyInterfaceDiffusion</a>A penalty-based interface condition that forcesthe continuity of variables and the flux equivalence across an interface.</li><li class="collection-item"><a href="source/interfacekernels/PenaltyInterfaceDiffusion.html">VectorPenaltyInterfaceDiffusion</a>A penalty-based interface condition that forcesthe continuity of variables and the flux equivalence across an interface.</li><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/interfacekernels/ADCZMInterfaceKernelSmallStrain.html">ADCZMInterfaceKernelSmallStrain</a>CZM Interface kernel to use when using the small strain kinematic formulation.</li><li class="collection-item"><a href="source/interfacekernels/ADCZMInterfaceKernelTotalLagrangian.html">ADCZMInterfaceKernelTotalLagrangian</a>CZM Interface kernel to use when using the total Lagrangian formulation.</li><li class="collection-item"><a href="source/interfacekernels/CZMInterfaceKernelSmallStrain.html">CZMInterfaceKernelSmallStrain</a>CZM Interface kernel to use when using the Small Strain kinematic formulation.</li><li class="collection-item"><a href="source/interfacekernels/CZMInterfaceKernelTotalLagrangian.html">CZMInterfaceKernelTotalLagrangian</a></li><li class="collection-header">Eel App</li><li class="collection-item"><a href="source/interfacekernels/InterfaceContinuity.html">InterfaceContinuity</a>Enforcing continuity across an interface</li><li class="collection-item"><a href="source/interfacekernels/InterfaceCoupledVarContinuity.html">InterfaceCoupledVarContinuity</a>Enforcing continuity of a coupled var across an interface</li><li class="collection-item"><a href="source/interfacekernels/MaterialInterfaceNeumannBC.html">MaterialInterfaceNeumannBC</a>Applies a Neumann BC on both sides of the interface. The value of the Neumann BC is specified by a material property.</li><li class="collection-header">Heat Conduction App</li><li class="collection-item"><a href="source/interfacekernels/ConjugateHeatTransfer.html">ConjugateHeatTransfer</a>This InterfaceKernel models conjugate heat transfer. Fluid side must be primary side and solid side must be secondary side. T_fluid is provided in case that variable (<u></u> fluid energy variable) is not temperature but e.g. internal energy.</li><li class="collection-item"><a href="source/interfacekernels/SideSetHeatTransferKernel.html">SideSetHeatTransferKernel</a>Modeling conduction, convection, and radiation across internal side set.</li><li class="collection-item"><a href="source/interfacekernels/ThinLayerHeatTransfer.html">ThinLayerHeatTransfer</a>Model heat transfer across a thin domain with an interface.</li></ul></section><section class="scrollspy" id="59bbe651-eb03-4894-aff1-a622dadb9ea0" data-section-level="2" data-section-text="Kernels"><h2 id="kernels"><a href="syntax/Kernels/index.html">Kernels</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddKernelAction.html">AddKernelAction</a>Add a Kernel object to the simulation.</li><li class="collection-item"><a href="source/kernels/BodyForce.html">ADBodyForce</a>Demonstrates the multiple ways that scalar values can be introduced into kernels, e.g. (controllable) constants, functions, and postprocessors. Implements the weak form <span class="moose-katex-inline-equation" id="moose-equation-72ecabae-bf90-4cbd-8075-c6b60754be92"><script>var element = document.getElementById("moose-equation-72ecabae-bf90-4cbd-8075-c6b60754be92");katex.render("(\\psi_i, -f)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/CoefReaction.html">ADCoefReaction</a>Implements the residual term (p*u, test)</li><li class="collection-item"><a href="source/kernels/CoupledForce.html">ADCoupledForce</a>Implements a source term proportional to the value of a coupled variable. Weak form: <span class="moose-katex-inline-equation" id="moose-equation-444c34a4-6b9f-46e3-986e-4106a47faae0"><script>var element = document.getElementById("moose-equation-444c34a4-6b9f-46e3-986e-4106a47faae0");katex.render("(\\psi_i, -\\sigma v)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/ADCoupledTimeDerivative.html">ADCoupledTimeDerivative</a>Time derivative Kernel that acts on a coupled variable. Weak form: <span class="moose-katex-inline-equation" id="moose-equation-3f7d3dbb-4c0b-439c-a420-c922561cd52f"><script>var element = document.getElementById("moose-equation-3f7d3dbb-4c0b-439c-a420-c922561cd52f");katex.render("(\\psi_i, \\frac{\\partial v_h}{\\partial t})", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/ADDiffusion.html">ADDiffusion</a>Same as <code>Diffusion</code> in terms of physics/residual, but the Jacobian is computed using forward automatic differentiation</li><li class="collection-item"><a href="source/kernels/ADMatCoupledForce.html">ADMatCoupledForce</a>Kernel representing the contribution of the PDE term <span class="moose-katex-inline-equation" id="moose-equation-f8a42403-d0bf-4904-9bda-e8c167773788"><script>var element = document.getElementById("moose-equation-f8a42403-d0bf-4904-9bda-e8c167773788");katex.render("mv", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-82f56fd5-3eb4-46d0-9fb7-24522859dd8c"><script>var element = document.getElementById("moose-equation-82f56fd5-3eb4-46d0-9fb7-24522859dd8c");katex.render("m", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is a material property coefficient, <span class="moose-katex-inline-equation" id="moose-equation-d98d6f5f-3a99-4300-b720-367e7bc71c4d"><script>var element = document.getElementById("moose-equation-d98d6f5f-3a99-4300-b720-367e7bc71c4d");katex.render("v", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is a coupled scalar field variable, and Jacobian derivatives are calculated using automatic differentiation.</li><li class="collection-item"><a href="source/kernels/ADMatDiffusion.html">ADMatDiffusion</a>Diffusion equation kernel that takes an isotropic diffusivity from a material property</li><li class="collection-item"><a href="source/kernels/ADMatReaction.html">ADMatReaction</a>Kernel representing the contribution of the PDE term <span class="moose-katex-inline-equation" id="moose-equation-3b24a1fb-deec-4810-8c31-9d2754142a4f"><script>var element = document.getElementById("moose-equation-3b24a1fb-deec-4810-8c31-9d2754142a4f");katex.render("-L*v", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-e1ae09cf-601a-4069-b0f9-77d5145a6278"><script>var element = document.getElementById("moose-equation-e1ae09cf-601a-4069-b0f9-77d5145a6278");katex.render("L", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is a reaction rate material property, <span class="moose-katex-inline-equation" id="moose-equation-d06045a9-d4f0-4149-911c-bf5f45bd6098"><script>var element = document.getElementById("moose-equation-d06045a9-d4f0-4149-911c-bf5f45bd6098");katex.render("v", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is a scalar variable (nonlinear or coupled), and whose Jacobian contribution is calculated using automatic differentiation.</li><li class="collection-item"><a href="source/kernels/MaterialPropertyValue.html">ADMaterialPropertyValue</a>Residual term (u - prop) to set variable u equal to a given material property prop</li><li class="collection-item"><a href="source/kernels/Reaction.html">ADReaction</a>Implements a simple consuming reaction term with weak form <span class="moose-katex-inline-equation" id="moose-equation-de14308a-3355-406e-b913-664fbac691ee"><script>var element = document.getElementById("moose-equation-de14308a-3355-406e-b913-664fbac691ee");katex.render("(\\psi_i, \\lambda u_h)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/ScalarLMKernel.html">ADScalarLMKernel</a>This class is used to enforce integral of phi = V_0 with a Lagrange multiplier approach.</li><li class="collection-item"><a href="source/kernels/ADTimeDerivative.html">ADTimeDerivative</a>The time derivative operator with the weak form of <span class="moose-katex-inline-equation" id="moose-equation-f79b133a-e9e7-4da4-b1ff-3d68b47d2ff2"><script>var element = document.getElementById("moose-equation-f79b133a-e9e7-4da4-b1ff-3d68b47d2ff2");katex.render("(\\psi_i, \\frac{\\partial u_h}{\\partial t})", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/ADVectorDiffusion.html">ADVectorDiffusion</a>The Laplacian operator (<span class="moose-katex-inline-equation" id="moose-equation-9cae1988-45f9-4ca4-a6c5-97a8a5af63d2"><script>var element = document.getElementById("moose-equation-9cae1988-45f9-4ca4-a6c5-97a8a5af63d2");katex.render("-\\nabla \\cdot \\nabla \\vec{u}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>), with the weak form of <span class="moose-katex-inline-equation" id="moose-equation-f9dd8955-7e42-48d6-bd96-ae7100030b08"><script>var element = document.getElementById("moose-equation-f9dd8955-7e42-48d6-bd96-ae7100030b08");katex.render("(\\nabla \\vec{\\phi_i}, \\nabla \\vec{u_h})", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>. The Jacobian is computed using automatic differentiation</li><li class="collection-item"><a href="source/kernels/ADVectorTimeDerivative.html">ADVectorTimeDerivative</a>The time derivative operator with the weak form of <span class="moose-katex-inline-equation" id="moose-equation-1173b225-c00b-4e2b-89a6-02542e84d977"><script>var element = document.getElementById("moose-equation-1173b225-c00b-4e2b-89a6-02542e84d977");katex.render("(\\psi_i, \\frac{\\partial u_h}{\\partial t})", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/AnisotropicDiffusion.html">AnisotropicDiffusion</a>Anisotropic diffusion kernel <span class="moose-katex-inline-equation" id="moose-equation-768f3a4e-ca48-4b4b-97a0-8ce9050e1543"><script>var element = document.getElementById("moose-equation-768f3a4e-ca48-4b4b-97a0-8ce9050e1543");katex.render("\\nabla \\cdot -\\widetilde{k} \\nabla u", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> with weak form given by <span class="moose-katex-inline-equation" id="moose-equation-4a8a1839-603e-4836-a193-acafd2552a51"><script>var element = document.getElementById("moose-equation-4a8a1839-603e-4836-a193-acafd2552a51");katex.render("(\\nabla \\psi_i, \\widetilde{k} \\nabla u)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/ArrayBodyForce.html">ArrayBodyForce</a>Applies body forces specified with functions to an array variable.</li><li class="collection-item"><a href="source/kernels/ArrayDiffusion.html">ArrayDiffusion</a>The array Laplacian operator (<span class="moose-katex-inline-equation" id="moose-equation-a3b34a8a-fda3-4cb2-8c5c-b1d939a08b5a"><script>var element = document.getElementById("moose-equation-a3b34a8a-fda3-4cb2-8c5c-b1d939a08b5a");katex.render("-\\nabla \\cdot \\nabla u", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>), with the weak form of <span class="moose-katex-inline-equation" id="moose-equation-7a492201-d571-4733-9ebc-e7d90f08902c"><script>var element = document.getElementById("moose-equation-7a492201-d571-4733-9ebc-e7d90f08902c");katex.render("(\\nabla \\phi_i, \\nabla u_h)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/ArrayReaction.html">ArrayReaction</a>The array reaction operator with the weak form of <span class="moose-katex-inline-equation" id="moose-equation-aa6f2817-2e99-4106-9a67-96cbe5a67d2d"><script>var element = document.getElementById("moose-equation-aa6f2817-2e99-4106-9a67-96cbe5a67d2d");katex.render("(\\psi_i, u_h)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/ArrayTimeDerivative.html">ArrayTimeDerivative</a>Array time derivative operator with the weak form of <span class="moose-katex-inline-equation" id="moose-equation-ff38bca0-f57a-41b3-a364-23140f1646d5"><script>var element = document.getElementById("moose-equation-ff38bca0-f57a-41b3-a364-23140f1646d5");katex.render("(\\psi_i, \\frac{\\partial u_h}{\\partial t})", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/BodyForce.html">BodyForce</a>Demonstrates the multiple ways that scalar values can be introduced into kernels, e.g. (controllable) constants, functions, and postprocessors. Implements the weak form <span class="moose-katex-inline-equation" id="moose-equation-2f44e589-8674-427e-ae80-27e4aead31a5"><script>var element = document.getElementById("moose-equation-2f44e589-8674-427e-ae80-27e4aead31a5");katex.render("(\\psi_i, -f)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/CoefReaction.html">CoefReaction</a>Implements the residual term (p*u, test)</li><li class="collection-item"><a href="source/kernels/CoefTimeDerivative.html">CoefTimeDerivative</a>The time derivative operator with the weak form of <span class="moose-katex-inline-equation" id="moose-equation-1983de49-dc1d-486b-917f-99ffe6ab4082"><script>var element = document.getElementById("moose-equation-1983de49-dc1d-486b-917f-99ffe6ab4082");katex.render("(\\psi_i, \\frac{\\partial u_h}{\\partial t})", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/ConservativeAdvection.html">ConservativeAdvection</a>Conservative form of <span class="moose-katex-inline-equation" id="moose-equation-fcc888d4-ceb0-4450-9854-416fd813df88"><script>var element = document.getElementById("moose-equation-fcc888d4-ceb0-4450-9854-416fd813df88");katex.render("\\nabla \\cdot \\vec{v} u", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> which in its weak form is given by: <span class="moose-katex-inline-equation" id="moose-equation-637dabc0-524d-46d3-b6e7-c224d6946794"><script>var element = document.getElementById("moose-equation-637dabc0-524d-46d3-b6e7-c224d6946794");katex.render("(-\\nabla \\psi_i, \\vec{v} u)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/CoupledForce.html">CoupledForce</a>Implements a source term proportional to the value of a coupled variable. Weak form: <span class="moose-katex-inline-equation" id="moose-equation-2d82402f-78ba-4b27-9063-2d5a8acdcb17"><script>var element = document.getElementById("moose-equation-2d82402f-78ba-4b27-9063-2d5a8acdcb17");katex.render("(\\psi_i, -\\sigma v)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/CoupledTimeDerivative.html">CoupledTimeDerivative</a>Time derivative Kernel that acts on a coupled variable. Weak form: <span class="moose-katex-inline-equation" id="moose-equation-c4942723-b969-4daa-b210-055ac1065519"><script>var element = document.getElementById("moose-equation-c4942723-b969-4daa-b210-055ac1065519");katex.render("(\\psi_i, \\frac{\\partial v_h}{\\partial t})", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/Diffusion.html">Diffusion</a>The Laplacian operator (<span class="moose-katex-inline-equation" id="moose-equation-2d9f505b-144e-4618-83ae-4ac5700820ec"><script>var element = document.getElementById("moose-equation-2d9f505b-144e-4618-83ae-4ac5700820ec");katex.render("-\\nabla \\cdot \\nabla u", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>), with the weak form of <span class="moose-katex-inline-equation" id="moose-equation-e150a3c0-b349-461a-8acb-236445479f3c"><script>var element = document.getElementById("moose-equation-e150a3c0-b349-461a-8acb-236445479f3c");katex.render("(\\nabla \\phi_i, \\nabla u_h)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/FunctionDiffusion.html">FunctionDiffusion</a>The Laplacian operator with a function coefficient.</li><li class="collection-item"><a href="source/kernels/MassEigenKernel.html">MassEigenKernel</a>An eigenkernel with weak form <span class="moose-katex-inline-equation" id="moose-equation-129f2d75-ffe5-4293-8308-b2c0700884a1"><script>var element = document.getElementById("moose-equation-129f2d75-ffe5-4293-8308-b2c0700884a1");katex.render("\\lambda(\\psi_i, -u_h)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> where <span class="moose-katex-inline-equation" id="moose-equation-d08f9775-eb35-4579-9a42-1b1c33c57e53"><script>var element = document.getElementById("moose-equation-d08f9775-eb35-4579-9a42-1b1c33c57e53");katex.render("\\lambda", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is the eigenvalue.</li><li class="collection-item"><a href="source/kernels/MassLumpedTimeDerivative.html">MassLumpedTimeDerivative</a>Lumped formulation of the time derivative <span class="moose-katex-inline-equation" id="moose-equation-49581232-130d-4a47-9d4a-2ebb5c3e0251"><script>var element = document.getElementById("moose-equation-49581232-130d-4a47-9d4a-2ebb5c3e0251");katex.render("\\frac{\\partial u}{\\partial t}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>. Its corresponding weak form is <span class="moose-katex-inline-equation" id="moose-equation-5a94e78c-e008-4b79-8387-9df7d2144245"><script>var element = document.getElementById("moose-equation-5a94e78c-e008-4b79-8387-9df7d2144245");katex.render("\\dot{u_i}(\\psi_i, 1)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> where <span class="moose-katex-inline-equation" id="moose-equation-f1cf42df-ecf9-4a69-9e99-562a1c0d23e5"><script>var element = document.getElementById("moose-equation-f1cf42df-ecf9-4a69-9e99-562a1c0d23e5");katex.render("\\dot{u_i}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> denotes the time derivative of the solution coefficient associated with node <span class="moose-katex-inline-equation" id="moose-equation-f6aec75d-fc44-4765-850e-10fdf834b2f1"><script>var element = document.getElementById("moose-equation-f6aec75d-fc44-4765-850e-10fdf834b2f1");katex.render("i", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/MatCoupledForce.html">MatCoupledForce</a>Implements a forcing term RHS of the form PDE = RHS, where RHS = Sum_j c_j * m_j * v_j. c_j, m_j, and v_j are provided as real coefficients, material properties, and coupled variables, respectively.</li><li class="collection-item"><a href="source/kernels/MatDiffusion.html">MatDiffusion</a>Diffusion equation Kernel that takes an isotropic Diffusivity from a material property</li><li class="collection-item"><a href="source/kernels/MatReaction.html">MatReaction</a>Kernel to add -L*v, where L=reaction rate, v=variable</li><li class="collection-item"><a href="source/kernels/MaterialDerivativeRankFourTestKernel.html">MaterialDerivativeRankFourTestKernel</a>Class used for testing derivatives of a rank four tensor material property.</li><li class="collection-item"><a href="source/kernels/MaterialDerivativeRankTwoTestKernel.html">MaterialDerivativeRankTwoTestKernel</a>Class used for testing derivatives of a rank two tensor material property.</li><li class="collection-item"><a href="source/kernels/MaterialDerivativeTestKernel.html">MaterialDerivativeTestKernel</a>Class used for testing derivatives of a scalar material property.</li><li class="collection-item"><a href="source/kernels/MaterialPropertyValue.html">MaterialPropertyValue</a>Residual term (u - prop) to set variable u equal to a given material property prop</li><li class="collection-item"><a href="source/kernels/NullKernel.html">NullKernel</a>Kernel that sets a zero residual.</li><li class="collection-item"><a href="source/kernels/Reaction.html">Reaction</a>Implements a simple consuming reaction term with weak form <span class="moose-katex-inline-equation" id="moose-equation-02feca51-322f-48bc-9ca9-428102554999"><script>var element = document.getElementById("moose-equation-02feca51-322f-48bc-9ca9-428102554999");katex.render("(\\psi_i, \\lambda u_h)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/ScalarLMKernel.html">ScalarLMKernel</a>This class is used to enforce integral of phi = V_0 with a Lagrange multiplier approach.</li><li class="collection-item"><a href="source/kernels/ScalarLagrangeMultiplier.html">ScalarLagrangeMultiplier</a>This class is used to enforce integral of phi = V_0 with a Lagrange multiplier approach.</li><li class="collection-item"><a href="source/kernels/TimeDerivative.html">TimeDerivative</a>The time derivative operator with the weak form of <span class="moose-katex-inline-equation" id="moose-equation-5b87f0ff-f133-446f-8f8d-5b7ebadc49eb"><script>var element = document.getElementById("moose-equation-5b87f0ff-f133-446f-8f8d-5b7ebadc49eb");katex.render("(\\psi_i, \\frac{\\partial u_h}{\\partial t})", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/UserForcingFunction.html">UserForcingFunction</a>Demonstrates the multiple ways that scalar values can be introduced into kernels, e.g. (controllable) constants, functions, and postprocessors. Implements the weak form <span class="moose-katex-inline-equation" id="moose-equation-62ae3a56-c08f-4fdb-974c-5d466f899b75"><script>var element = document.getElementById("moose-equation-62ae3a56-c08f-4fdb-974c-5d466f899b75");katex.render("(\\psi_i, -f)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/VectorBodyForce.html">VectorBodyForce</a>Demonstrates the multiple ways that scalar values can be introduced into kernels, e.g. (controllable) constants, functions, and postprocessors. Implements the weak form <span class="moose-katex-inline-equation" id="moose-equation-c0021b56-99b8-4a3f-a25e-5ee6aa2b3089"><script>var element = document.getElementById("moose-equation-c0021b56-99b8-4a3f-a25e-5ee6aa2b3089");katex.render("(\\vec{\\psi_i}, -\\vec{f})", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/VectorCoupledTimeDerivative.html">VectorCoupledTimeDerivative</a>Time derivative Kernel that acts on a coupled vector variable. Weak form: <span class="moose-katex-inline-equation" id="moose-equation-0fbe9102-c0c9-4d4e-a604-d647eed0bd3c"><script>var element = document.getElementById("moose-equation-0fbe9102-c0c9-4d4e-a604-d647eed0bd3c");katex.render("(\\vec{\\psi}_i, \\frac{\\partial \\vec{v_h}}{\\partial t})", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/VectorDiffusion.html">VectorDiffusion</a>The Laplacian operator (<span class="moose-katex-inline-equation" id="moose-equation-dee8eb60-9934-4734-91b3-e8256284ef9d"><script>var element = document.getElementById("moose-equation-dee8eb60-9934-4734-91b3-e8256284ef9d");katex.render("-\\nabla \\cdot \\nabla \\vec{u}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>), with the weak form of <span class="moose-katex-inline-equation" id="moose-equation-692d3e2d-dc3d-4d15-8bad-a5ea031da893"><script>var element = document.getElementById("moose-equation-692d3e2d-dc3d-4d15-8bad-a5ea031da893");katex.render("(\\nabla \\vec{\\phi_i}, \\nabla \\vec{u_h})", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/VectorTimeDerivative.html">VectorTimeDerivative</a>The time derivative operator with the weak form of <span class="moose-katex-inline-equation" id="moose-equation-53491707-f50f-4697-be8f-305db794c775"><script>var element = document.getElementById("moose-equation-53491707-f50f-4697-be8f-305db794c775");katex.render("(\\vec{\\psi_i}, \\frac{\\partial \\vec{u_h}}{\\partial t})", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-header">Navier Stokes App</li><li class="collection-item"><a href="source/kernels/DistributedForce.html">DistributedForce</a>Implements a force term in the Navier Stokes momentum equation.</li><li class="collection-item"><a href="source/kernels/DistributedPower.html">DistributedPower</a>Implements the power term of a specified force in the Navier Stokes energy equation.</li><li class="collection-item"><a href="source/kernels/INSADBoussinesqBodyForce.html">INSADBoussinesqBodyForce</a>Computes a body force for natural convection buoyancy.</li><li class="collection-item"><a href="source/kernels/INSADEnergyAdvection.html">INSADEnergyAdvection</a>This class computes the residual and Jacobian contributions for temperature advection for a divergence free velocity field.</li><li class="collection-item"><a href="source/kernels/INSADEnergyAmbientConvection.html">INSADEnergyAmbientConvection</a>Computes a heat source/sink due to convection from ambient surroundings.</li><li class="collection-item"><a href="source/kernels/INSADEnergySUPG.html">INSADEnergySUPG</a>Adds the supg stabilization to the INS temperature/energy equation</li><li class="collection-item"><a href="source/kernels/INSADEnergySource.html">INSADEnergySource</a>Computes an arbitrary volumetric heat source (or sink).</li><li class="collection-item"><a href="source/kernels/INSADGravityForce.html">INSADGravityForce</a>Computes a body force due to gravity.</li><li class="collection-item"><a href="source/kernels/INSADHeatConductionTimeDerivative.html">INSADHeatConductionTimeDerivative</a>AD Time derivative term <span class="moose-katex-inline-equation" id="moose-equation-66a38b14-35fa-438d-9b75-8b0042a00b35"><script>var element = document.getElementById("moose-equation-66a38b14-35fa-438d-9b75-8b0042a00b35");katex.render("\\rho c_p \\frac{\\partial T}{\\partial t}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> of the heat equation for quasi-constant specific heat <span class="moose-katex-inline-equation" id="moose-equation-d770d2cf-8b12-4c44-aa1c-0385b58e59e4"><script>var element = document.getElementById("moose-equation-d770d2cf-8b12-4c44-aa1c-0385b58e59e4");katex.render("c_p", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> and the density <span class="moose-katex-inline-equation" id="moose-equation-2993a25e-2bae-4e00-97ef-f7c4105e8178"><script>var element = document.getElementById("moose-equation-2993a25e-2bae-4e00-97ef-f7c4105e8178");katex.render("\\rho", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/INSADMass.html">INSADMass</a>This class computes the mass equation residual and Jacobian contributions (the latter using automatic differentiation) for the incompressible Navier-Stokes equations.</li><li class="collection-item"><a href="source/kernels/INSADMassPSPG.html">INSADMassPSPG</a>This class adds PSPG stabilization to the mass equation, enabling use of equal order shape functions for pressure and velocity variables</li><li class="collection-item"><a href="source/kernels/INSADMomentumAdvection.html">INSADMomentumAdvection</a>Adds the advective term to the INS momentum equation</li><li class="collection-item"><a href="source/kernels/INSADMomentumCoupledForce.html">INSADMomentumCoupledForce</a>Computes a body force due to a coupled vector variable or a vector function</li><li class="collection-item"><a href="source/kernels/INSADMomentumPressure.html">INSADMomentumPressure</a>Adds the pressure term to the INS momentum equation</li><li class="collection-item"><a href="source/kernels/INSADMomentumSUPG.html">INSADMomentumSUPG</a>Adds the supg stabilization to the INS momentum equation</li><li class="collection-item"><a href="source/kernels/INSADMomentumTimeDerivative.html">INSADMomentumTimeDerivative</a>This class computes the time derivative for the incompressible Navier-Stokes momentum equation.</li><li class="collection-item"><a href="source/kernels/INSADMomentumViscous.html">INSADMomentumViscous</a>Adds the viscous term to the INS momentum equation</li><li class="collection-item"><a href="source/kernels/INSADSmagorinskyEddyViscosity.html">INSADSmagorinskyEddyViscosity</a>Computes eddy viscosity term using Smagorinky&#x27;s LES model</li><li class="collection-item"><a href="source/kernels/INSChorinCorrector.html">INSChorinCorrector</a>This class computes the &#x27;Chorin&#x27; Corrector equation in fully-discrete (both time and space) form.</li><li class="collection-item"><a href="source/kernels/INSChorinPredictor.html">INSChorinPredictor</a>This class computes the &#x27;Chorin&#x27; Predictor equation in fully-discrete (both time and space) form.</li><li class="collection-item"><a href="source/kernels/INSChorinPressurePoisson.html">INSChorinPressurePoisson</a>This class computes the pressure Poisson solve which is part of the &#x27;split&#x27; scheme used for solving the incompressible Navier-Stokes equations.</li><li class="collection-item"><a href="source/kernels/INSCompressibilityPenalty.html">INSCompressibilityPenalty</a>The penalty term may be used when Dirichlet boundary condition is applied to the entire boundary.</li><li class="collection-item"><a href="source/kernels/INSFEFluidEnergyKernel.html">INSFEFluidEnergyKernel</a>Adds advection, diffusion, and heat source terms to energy equation, potentially with stabilization</li><li class="collection-item"><a href="source/kernels/INSFEFluidMassKernel.html">INSFEFluidMassKernel</a>Adds advective term of mass conservation equation along with pressure-stabilized Petrov-Galerkin terms</li><li class="collection-item"><a href="source/kernels/INSFEFluidMomentumKernel.html">INSFEFluidMomentumKernel</a>Adds advection, viscous, pressure, friction, and gravity terms to the Navier-Stokes momentum equation, potentially with stabilization</li><li class="collection-item"><a href="source/kernels/INSMass.html">INSMass</a>This class computes the mass equation residual and Jacobian contributions for the incompressible Navier-Stokes momentum equation.</li><li class="collection-item"><a href="source/kernels/INSMassRZ.html">INSMassRZ</a>This class computes the mass equation residual and Jacobian contributions for the incompressible Navier-Stokes momentum equation in RZ coordinates.</li><li class="collection-item"><a href="source/kernels/INSMomentumLaplaceForm.html">INSMomentumLaplaceForm</a>This class computes momentum equation residual and Jacobian viscous contributions for the &#x27;Laplacian&#x27; form of the governing equations.</li><li class="collection-item"><a href="source/kernels/INSMomentumLaplaceFormRZ.html">INSMomentumLaplaceFormRZ</a>This class computes additional momentum equation residual and Jacobian contributions for the incompressible Navier-Stokes momentum equation in RZ (axisymmetric cylindrical) coordinates, using the &#x27;Laplace&#x27; form of the governing equations.</li><li class="collection-item"><a href="source/kernels/INSMomentumTimeDerivative.html">INSMomentumTimeDerivative</a>This class computes the time derivative for the incompressible Navier-Stokes momentum equation.</li><li class="collection-item"><a href="source/kernels/INSMomentumTractionForm.html">INSMomentumTractionForm</a>This class computes momentum equation residual and Jacobian viscous contributions for the &#x27;traction&#x27; form of the governing equations.</li><li class="collection-item"><a href="source/kernels/INSMomentumTractionFormRZ.html">INSMomentumTractionFormRZ</a>This class computes additional momentum equation residual and Jacobian contributions for the incompressible Navier-Stokes momentum equation in RZ (axisymmetric cylindrical) coordinates.</li><li class="collection-item"><a href="source/kernels/INSPressurePoisson.html">INSPressurePoisson</a>This class computes the pressure Poisson solve which is part of the &#x27;split&#x27; scheme used for solving the incompressible Navier-Stokes equations.</li><li class="collection-item"><a href="source/kernels/INSProjection.html">INSProjection</a>This class computes the &#x27;projection&#x27; part of the &#x27;split&#x27; method for solving incompressible Navier-Stokes.</li><li class="collection-item"><a href="source/kernels/INSSplitMomentum.html">INSSplitMomentum</a>This class computes the &#x27;split&#x27; momentum equation residual.</li><li class="collection-item"><a href="source/kernels/INSTemperature.html">INSTemperature</a>This class computes the residual and Jacobian contributions for the incompressible Navier-Stokes temperature (energy) equation.</li><li class="collection-item"><a href="source/kernels/INSTemperatureTimeDerivative.html">INSTemperatureTimeDerivative</a>This class computes the time derivative for the incompressible Navier-Stokes momentum equation.</li><li class="collection-item"><a href="source/kernels/INSFEFluidEnergyKernel.html">MDFluidEnergyKernel</a>Adds advection, diffusion, and heat source terms to energy equation, potentially with stabilization</li><li class="collection-item"><a href="source/kernels/INSFEFluidMassKernel.html">MDFluidMassKernel</a>Adds advective term of mass conservation equation along with pressure-stabilized Petrov-Galerkin terms</li><li class="collection-item"><a href="source/kernels/INSFEFluidMomentumKernel.html">MDFluidMomentumKernel</a>Adds advection, viscous, pressure, friction, and gravity terms to the Navier-Stokes momentum equation, potentially with stabilization</li><li class="collection-item"><a href="source/kernels/MassConvectiveFlux.html">MassConvectiveFlux</a>Implements the advection term for the Navier Stokes mass equation.</li><li class="collection-item"><a href="source/kernels/MomentumConvectiveFlux.html">MomentumConvectiveFlux</a>Implements the advective term of the Navier Stokes momentum equation.</li><li class="collection-item"><a href="source/kernels/NSEnergyInviscidFlux.html">NSEnergyInviscidFlux</a>This class computes the inviscid part of the energy flux.</li><li class="collection-item"><a href="source/kernels/NSEnergyThermalFlux.html">NSEnergyThermalFlux</a>This class is responsible for computing residuals and Jacobian terms for the k * grad(T) * grad(phi) term in the Navier-Stokes energy equation.</li><li class="collection-item"><a href="source/kernels/NSEnergyViscousFlux.html">NSEnergyViscousFlux</a>Viscous flux terms in energy equation.</li><li class="collection-item"><a href="source/kernels/NSGravityForce.html">NSGravityForce</a>This class computes the gravity force contribution.</li><li class="collection-item"><a href="source/kernels/NSGravityPower.html">NSGravityPower</a>This class computes the momentum contributed by gravity.</li><li class="collection-item"><a href="source/kernels/NSMassInviscidFlux.html">NSMassInviscidFlux</a>This class computes the inviscid flux in the mass equation.</li><li class="collection-item"><a href="source/kernels/NSMomentumInviscidFlux.html">NSMomentumInviscidFlux</a>The inviscid flux (convective + pressure terms) for the momentum conservation equations.</li><li class="collection-item"><a href="source/kernels/NSMomentumInviscidFluxWithGradP.html">NSMomentumInviscidFluxWithGradP</a>This class computes the inviscid flux with pressure gradient in the momentum equation.</li><li class="collection-item"><a href="source/kernels/NSMomentumViscousFlux.html">NSMomentumViscousFlux</a>Derived instance of the NSViscousFluxBase class for the momentum equations.</li><li class="collection-item"><a href="source/kernels/NSSUPGEnergy.html">NSSUPGEnergy</a>Compute residual and Jacobian terms form the SUPG terms in the energy equation.</li><li class="collection-item"><a href="source/kernels/NSSUPGMass.html">NSSUPGMass</a>Compute residual and Jacobian terms form the SUPG terms in the mass equation.</li><li class="collection-item"><a href="source/kernels/NSSUPGMomentum.html">NSSUPGMomentum</a>Compute residual and Jacobian terms form the SUPG terms in the momentum equation.</li><li class="collection-item"><a href="source/kernels/NSTemperatureL2.html">NSTemperatureL2</a>This class was originally used to solve for the temperature using an L2-projection.</li><li class="collection-item"><a href="source/kernels/PINSFEFluidPressureTimeDerivative.html">PINSFEFluidPressureTimeDerivative</a>Adds the transient term of the porous-media mass conservation equation</li><li class="collection-item"><a href="source/kernels/PINSFEFluidTemperatureTimeDerivative.html">PINSFEFluidTemperatureTimeDerivative</a>The time derivative operator with the weak form of <span class="moose-katex-inline-equation" id="moose-equation-e493c4c4-886f-4532-9a8f-ccf4b47fa56f"><script>var element = document.getElementById("moose-equation-e493c4c4-886f-4532-9a8f-ccf4b47fa56f");katex.render("(\\psi_i, \\frac{\\partial u_h}{\\partial t})", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/PINSFEFluidVelocityTimeDerivative.html">PINSFEFluidVelocityTimeDerivative</a>The time derivative operator with the weak form of <span class="moose-katex-inline-equation" id="moose-equation-8608863c-7af5-4db7-b666-ee639e6d01d7"><script>var element = document.getElementById("moose-equation-8608863c-7af5-4db7-b666-ee639e6d01d7");katex.render("(\\psi_i, \\frac{\\partial u_h}{\\partial t})", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/PINSFEFluidPressureTimeDerivative.html">PMFluidPressureTimeDerivative</a>Adds the transient term of the porous-media mass conservation equation</li><li class="collection-item"><a href="source/kernels/PINSFEFluidTemperatureTimeDerivative.html">PMFluidTemperatureTimeDerivative</a>The time derivative operator with the weak form of <span class="moose-katex-inline-equation" id="moose-equation-2a3c796f-561a-4b87-9da3-cd282a661642"><script>var element = document.getElementById("moose-equation-2a3c796f-561a-4b87-9da3-cd282a661642");katex.render("(\\psi_i, \\frac{\\partial u_h}{\\partial t})", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/PINSFEFluidVelocityTimeDerivative.html">PMFluidVelocityTimeDerivative</a>The time derivative operator with the weak form of <span class="moose-katex-inline-equation" id="moose-equation-907a092a-f750-4055-878b-2a388fe22df7"><script>var element = document.getElementById("moose-equation-907a092a-f750-4055-878b-2a388fe22df7");katex.render("(\\psi_i, \\frac{\\partial u_h}{\\partial t})", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/PressureGradient.html">PressureGradient</a>Implements the pressure gradient term for one of the Navier Stokes momentum equations.</li><li class="collection-item"><a href="source/kernels/TotalEnergyConvectiveFlux.html">TotalEnergyConvectiveFlux</a>Implements the advection term for the Navier Stokes energy equation.</li><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/kernels/ADDynamicStressDivergenceTensors.html">ADDynamicStressDivergenceTensors</a>Residual due to stress related Rayleigh damping and HHT time integration terms</li><li class="collection-item"><a href="source/kernels/Gravity.html">ADGravity</a>Apply gravity. Value is in units of acceleration.</li><li class="collection-item"><a href="source/kernels/InertialForce.html">ADInertialForce</a>Calculates the residual for the inertial force (<span class="moose-katex-inline-equation" id="moose-equation-9e886a5a-db9f-44dd-99c4-f0c8a4746c7a"><script>var element = document.getElementById("moose-equation-9e886a5a-db9f-44dd-99c4-f0c8a4746c7a");katex.render("M \\cdot acceleration", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>) and the contribution of mass dependent Rayleigh damping and HHT time  integration scheme ($\eta \cdot M \cdot ((1+\alpha)velq2-\alpha \cdot vel-old) $)</li><li class="collection-item"><a href="source/kernels/ADInertialForceShell.html">ADInertialForceShell</a>Calculates the residual for the inertial force/moment and the contribution of mass dependent Rayleigh damping and HHT time integration scheme.</li><li class="collection-item"><a href="source/kernels/ADStressDivergenceRSphericalTensors.html">ADStressDivergenceRSphericalTensors</a>Calculate stress divergence for a spherically symmetric 1D problem in polar coordinates.</li><li class="collection-item"><a href="source/kernels/ADStressDivergenceRZTensors.html">ADStressDivergenceRZTensors</a>Calculate stress divergence for an axisymmetric problem in cylindrical coordinates.</li><li class="collection-item"><a href="source/kernels/ADStressDivergenceShell.html">ADStressDivergenceShell</a>Quasi-static stress divergence kernel for Shell element</li><li class="collection-item"><a href="source/kernels/ADStressDivergenceTensors.html">ADStressDivergenceTensors</a>Stress divergence kernel with automatic differentiation for the Cartesian coordinate system</li><li class="collection-item"><a href="source/kernels/ADStressDivergenceTensors.html">ADSymmetricStressDivergenceTensors</a>Stress divergence kernel with automatic differentiation for the Cartesian coordinate system</li><li class="collection-item"><a href="source/kernels/ADWeakPlaneStress.html">ADWeakPlaneStress</a>Plane stress kernel to provide out-of-plane strain contribution.</li><li class="collection-item"><a href="source/kernels/AsymptoticExpansionHomogenizationKernel.html">AsymptoticExpansionHomogenizationKernel</a>Kernel for asymptotic expansion homogenization for elasticity</li><li class="collection-item"><a href="source/kernels/CosseratStressDivergenceTensors.html">CosseratStressDivergenceTensors</a>Stress divergence kernel for the Cartesian coordinate system</li><li class="collection-item"><a href="source/kernels/DynamicStressDivergenceTensors.html">DynamicStressDivergenceTensors</a>Residual due to stress related Rayleigh damping and HHT time integration terms </li><li class="collection-item"><a href="source/kernels/GeneralizedPlaneStrainOffDiag.html">GeneralizedPlaneStrainOffDiag</a>Generalized Plane Strain kernel to provide contribution of the out-of-plane strain to other kernels</li><li class="collection-item"><a href="source/kernels/Gravity.html">Gravity</a>Apply gravity. Value is in units of acceleration.</li><li class="collection-item"><a href="source/kernels/lagrangian/HomogenizedTotalLagrangianStressDivergence.html">HomogenizedTotalLagrangianStressDivergence</a>Total Lagrangian stress equilibrium kernel with homogenization constraint Jacobian terms</li><li class="collection-item"><a href="source/kernels/InertialForce.html">InertialForce</a>Calculates the residual for the inertial force (<span class="moose-katex-inline-equation" id="moose-equation-32a45638-0538-4677-811c-ca80becaffb0"><script>var element = document.getElementById("moose-equation-32a45638-0538-4677-811c-ca80becaffb0");katex.render("M \\cdot acceleration", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>) and the contribution of mass dependent Rayleigh damping and HHT time  integration scheme ($\eta \cdot M \cdot ((1+\alpha)velq2-\alpha \cdot vel-old) $)</li><li class="collection-item"><a href="source/kernels/InertialForceBeam.html">InertialForceBeam</a>Calculates the residual for the inertial force/moment and the contribution of mass dependent Rayleigh damping and HHT time integration scheme.</li><li class="collection-item"><a href="source/kernels/InertialTorque.html">InertialTorque</a>Kernel for inertial torque: density * displacement x acceleration</li><li class="collection-item"><a href="source/kernels/MaterialVectorBodyForce.html">MaterialVectorBodyForce</a>Apply a body force vector to the coupled displacement component.</li><li class="collection-item"><a href="source/kernels/MomentBalancing.html">MomentBalancing</a></li><li class="collection-item"><a href="source/kernels/OutOfPlanePressure.html">OutOfPlanePressure</a>Apply pressure in the out-of-plane direction in 2D plane stress or generalized plane strain models </li><li class="collection-item"><a href="source/kernels/PhaseFieldFractureMechanicsOffDiag.html">PhaseFieldFractureMechanicsOffDiag</a>Stress divergence kernel for phase-field fracture: Computes off diagonal damage dependent Jacobian components. To be used with StressDivergenceTensors or DynamicStressDivergenceTensors.</li><li class="collection-item"><a href="source/kernels/PlasticHeatEnergy.html">PlasticHeatEnergy</a>Plastic heat energy density = coeff * stress * plastic_strain_rate</li><li class="collection-item"><a href="source/kernels/PoroMechanicsCoupling.html">PoroMechanicsCoupling</a>Adds <span class="moose-katex-inline-equation" id="moose-equation-5ff2b85a-0685-4310-8a4c-c0b7e9a11034"><script>var element = document.getElementById("moose-equation-5ff2b85a-0685-4310-8a4c-c0b7e9a11034");katex.render("-Bi \\cdot p_s \\cdot \\nabla \\Psi_c", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, where the subscript <span class="moose-katex-inline-equation" id="moose-equation-e99f8aae-e3b2-4a16-9e81-4e33561349ab"><script>var element = document.getElementById("moose-equation-e99f8aae-e3b2-4a16-9e81-4e33561349ab");katex.render("c", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> is the component.</li><li class="collection-item"><a href="source/kernels/StressDivergenceBeam.html">StressDivergenceBeam</a>Quasi-static and dynamic stress divergence kernel for Beam element</li><li class="collection-item"><a href="source/kernels/StressDivergenceRSphericalTensors.html">StressDivergenceRSphericalTensors</a>Calculate stress divergence for a spherically symmetric 1D problem in polar coordinates.</li><li class="collection-item"><a href="source/kernels/StressDivergenceRZTensors.html">StressDivergenceRZTensors</a>Calculate stress divergence for an axisymmetric problem in cylindrical coordinates.</li><li class="collection-item"><a href="source/kernels/StressDivergenceTensors.html">StressDivergenceTensors</a>Stress divergence kernel for the Cartesian coordinate system</li><li class="collection-item"><a href="source/kernels/StressDivergenceTensorsTruss.html">StressDivergenceTensorsTruss</a>Kernel for truss element</li><li class="collection-item"><a href="source/kernels/lagrangian/TotalLagrangianStressDivergence.html">TotalLagrangianStressDivergence</a>Enforce equilibrium with a total Lagrangian formulation in Cartesian coordinates.</li><li class="collection-item"><a href="source/kernels/lagrangian/TotalLagrangianStressDivergenceAxisymmetricCylindrical.html">TotalLagrangianStressDivergenceAxisymmetricCylindrical</a>Enforce equilibrium with a total Lagrangian formulation in axisymmetric cylindrical coordinates.</li><li class="collection-item"><a href="source/kernels/lagrangian/TotalLagrangianStressDivergenceCentrosymmetricSpherical.html">TotalLagrangianStressDivergenceCentrosymmetricSpherical</a>Enforce equilibrium with a total Lagrangian formulation in centrosymmetric spherical coordinates.</li><li class="collection-item"><a href="source/kernels/lagrangian/TotalLagrangianWeakPlaneStress.html">TotalLagrangianWeakPlaneStress</a>Plane stress kernel to provide out-of-plane strain contribution.</li><li class="collection-item"><a href="source/kernels/lagrangian/UpdatedLagrangianStressDivergence.html">UpdatedLagrangianStressDivergence</a>Enforce equilibrium with an updated Lagrangian formulation in Cartesian coordinates.</li><li class="collection-item"><a href="source/kernels/WeakPlaneStress.html">WeakPlaneStress</a>Plane stress kernel to provide out-of-plane strain contribution.</li><li class="collection-item"><a href="syntax/Kernels/DynamicTensorMechanics/index.html">DynamicTensorMechanics</a></li><li class="collection-item"><a href="syntax/Kernels/PoroMechanics/index.html">PoroMechanics</a></li><li class="collection-item"><a href="syntax/Kernels/TensorMechanics/index.html">TensorMechanics</a></li><li class="collection-header">Heat Conduction App</li><li class="collection-item"><a href="source/kernels/ADHeatConduction.html">ADHeatConduction</a>Same as <code>Diffusion</code> in terms of physics/residual, but the Jacobian is computed using forward automatic differentiation</li><li class="collection-item"><a href="source/kernels/ADHeatConductionTimeDerivative.html">ADHeatConductionTimeDerivative</a>AD Time derivative term <span class="moose-katex-inline-equation" id="moose-equation-1a902c91-f0e9-4b08-91fe-d2e8429ce658"><script>var element = document.getElementById("moose-equation-1a902c91-f0e9-4b08-91fe-d2e8429ce658");katex.render("\\rho c_p \\frac{\\partial T}{\\partial t}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> of the heat equation for quasi-constant specific heat <span class="moose-katex-inline-equation" id="moose-equation-077897e1-bea4-47c3-9fbe-f0010ee28a4b"><script>var element = document.getElementById("moose-equation-077897e1-bea4-47c3-9fbe-f0010ee28a4b");katex.render("c_p", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> and the density <span class="moose-katex-inline-equation" id="moose-equation-e3b51199-3a93-46fa-9ed1-c205a88b20a7"><script>var element = document.getElementById("moose-equation-e3b51199-3a93-46fa-9ed1-c205a88b20a7");katex.render("\\rho", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/ADJouleHeatingSource.html">ADJouleHeatingSource</a>Calculates the heat source term corresponding to electrostatic Joule heating, with Jacobian contributions calculated using the automatic differentiation system.</li><li class="collection-item"><a href="source/kernels/ADMatHeatSource.html">ADMatHeatSource</a>Force term in thermal transport to represent a heat source</li><li class="collection-item"><a href="source/kernels/AnisoHeatConduction.html">AnisoHeatConduction</a>Anisotropic HeatConduction kernel <span class="moose-katex-inline-equation" id="moose-equation-3729ed82-be74-41d0-96ae-1f89381c760e"><script>var element = document.getElementById("moose-equation-3729ed82-be74-41d0-96ae-1f89381c760e");katex.render("\\nabla \\cdot -\\widetilde{k} \\nabla u", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> with weak form given by <span class="moose-katex-inline-equation" id="moose-equation-d63c17df-a498-4fe3-8dfb-c6428d0a8d7f"><script>var element = document.getElementById("moose-equation-d63c17df-a498-4fe3-8dfb-c6428d0a8d7f");katex.render("(\\nabla \\psi_i, \\widetilde{k} \\nabla u)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/AnisoHomogenizedHeatConduction.html">AnisoHomogenizedHeatConduction</a>Kernel for asymptotic expansion homogenization for thermal conductivity when anisotropic thermal conductivities are used</li><li class="collection-item"><a href="source/kernels/HeatCapacityConductionTimeDerivative.html">HeatCapacityConductionTimeDerivative</a>Time derivative term <span class="moose-katex-inline-equation" id="moose-equation-f550e58a-a93b-4ec6-96af-21c19feefe4f"><script>var element = document.getElementById("moose-equation-f550e58a-a93b-4ec6-96af-21c19feefe4f");katex.render("C_p \\frac{\\partial T}{\\partial t}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> of the heat equation with the heat capacity <span class="moose-katex-inline-equation" id="moose-equation-9c87d8a6-58eb-4a10-9786-427b4a2c62f2"><script>var element = document.getElementById("moose-equation-9c87d8a6-58eb-4a10-9786-427b4a2c62f2");katex.render("C_p", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> as an argument.</li><li class="collection-item"><a href="source/kernels/HeatConduction.html">HeatConduction</a>Computes residual/Jacobian contribution for <span class="moose-katex-inline-equation" id="moose-equation-4d791fc9-fefd-4b1c-b770-cce9ecff6319"><script>var element = document.getElementById("moose-equation-4d791fc9-fefd-4b1c-b770-cce9ecff6319");katex.render("(k \\nabla T, \\nabla \\psi)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> term.</li><li class="collection-item"><a href="source/kernels/HeatConductionTimeDerivative.html">HeatConductionTimeDerivative</a>Time derivative term <span class="moose-katex-inline-equation" id="moose-equation-ebf8e59f-6bfd-46c0-b567-f4f7cb81616d"><script>var element = document.getElementById("moose-equation-ebf8e59f-6bfd-46c0-b567-f4f7cb81616d");katex.render("\\rho c_p \\frac{\\partial T}{\\partial t}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> of the heat equation for quasi-constant specific heat <span class="moose-katex-inline-equation" id="moose-equation-e0018280-1efe-4ce5-8c89-3a6a29d1ca17"><script>var element = document.getElementById("moose-equation-e0018280-1efe-4ce5-8c89-3a6a29d1ca17");katex.render("c_p", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> and the density <span class="moose-katex-inline-equation" id="moose-equation-d30c4d1c-35ed-4939-b832-a833c57891fe"><script>var element = document.getElementById("moose-equation-d30c4d1c-35ed-4939-b832-a833c57891fe");katex.render("\\rho", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/HeatSource.html">HeatSource</a>Demonstrates the multiple ways that scalar values can be introduced into kernels, e.g. (controllable) constants, functions, and postprocessors. Implements the weak form <span class="moose-katex-inline-equation" id="moose-equation-d19905ad-2a91-40ff-ab4f-b739626d234c"><script>var element = document.getElementById("moose-equation-d19905ad-2a91-40ff-ab4f-b739626d234c");katex.render("(\\psi_i, -f)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>.</li><li class="collection-item"><a href="source/kernels/HomogenizedHeatConduction.html">HomogenizedHeatConduction</a>Kernel for asymptotic expansion homogenization for thermal conductivity</li><li class="collection-item"><a href="source/kernels/JouleHeatingSource.html">JouleHeatingSource</a>Calculates the heat source term corresponding to electrostatic Joule heating.</li><li class="collection-item"><a href="source/kernels/SpecificHeatConductionTimeDerivative.html">SpecificHeatConductionTimeDerivative</a>Time derivative term <span class="moose-katex-inline-equation" id="moose-equation-ba1b3318-461c-43cb-b611-52cfb829f0c4"><script>var element = document.getElementById("moose-equation-ba1b3318-461c-43cb-b611-52cfb829f0c4");katex.render("\\rho c_p \\frac{\\partial T}{\\partial t}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> of the heat equation with the specific heat <span class="moose-katex-inline-equation" id="moose-equation-7f3ab6f9-1c70-4dc2-8961-5781f73f5010"><script>var element = document.getElementById("moose-equation-7f3ab6f9-1c70-4dc2-8961-5781f73f5010");katex.render("c_p", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> and the density <span class="moose-katex-inline-equation" id="moose-equation-51a162ff-f6b8-42a1-8182-ed282368b73d"><script>var element = document.getElementById("moose-equation-51a162ff-f6b8-42a1-8182-ed282368b73d");katex.render("\\rho", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> as arguments.</li><li class="collection-item"><a href="source/kernels/TrussHeatConduction.html">TrussHeatConduction</a>Computes conduction term in heat equation for truss elements, taking cross-sectional area into account</li><li class="collection-item"><a href="source/kernels/TrussHeatConductionTimeDerivative.html">TrussHeatConductionTimeDerivative</a>Computes time derivative term in heat equation for truss elements, taking cross-sectional area into account</li><li class="collection-header">Eel App</li><li class="collection-item"><a href="source/kernels/EnergyBalanceTimeDerivative.html">EnergyBalanceTimeDerivative</a>Time derivative term <span class="moose-katex-inline-equation" id="moose-equation-2307adf7-66ae-45f9-b0b3-40ba5d6c605c"><script>var element = document.getElementById("moose-equation-2307adf7-66ae-45f9-b0b3-40ba5d6c605c");katex.render("\\rho c_p \\frac{\\partial T}{\\partial t}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> of the heat equation.</li><li class="collection-item"><a href="source/kernels/MaterialSource.html">MaterialSource</a>Source term defined by the material property</li><li class="collection-item"><a href="source/kernels/PrimalDualProjection.html">PrimalDualProjection</a>Projecting a primal variable onto a dual variable</li><li class="collection-item"><a href="source/kernels/RankOneDivergence.html">RankOneDivergence</a>This class implements the weak form for the divergence of a vector.</li><li class="collection-item"><a href="source/kernels/RankTwoDivergence.html">RankTwoDivergence</a>This class implements the weak form for the divergence of a second order tensor</li></ul><section id="b108f506-6c10-4e02-86ee-88cb86402880" data-section-level="3" data-section-text="Kernels/DynamicTensorMechanics"><h3 id="kernels/dynamictensormechanics"><a href="syntax/Kernels/DynamicTensorMechanics/index.html">Kernels/DynamicTensorMechanics</a></h3><ul class="moose-syntax-list collection with-header"><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/actions/LegacyDynamicTensorMechanicsAction.html">LegacyDynamicTensorMechanicsAction</a>Set up dynamic stress divergence kernels</li></ul></section><section id="e72519a2-f027-46e7-a521-6526432e84c4" data-section-level="3" data-section-text="Kernels/PoroMechanics"><h3 id="kernels/poromechanics"><a href="syntax/Kernels/PoroMechanics/index.html">Kernels/PoroMechanics</a></h3><ul class="moose-syntax-list collection with-header"><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/actions/PoroMechanicsAction.html">PoroMechanicsAction</a>Set up stress divergence kernels with coordinate system aware logic</li></ul></section><section id="5f0d84a3-9074-4dfe-abe6-579499dbd4ac" data-section-level="3" data-section-text="Kernels/TensorMechanics"><h3 id="kernels/tensormechanics"><a href="syntax/Kernels/TensorMechanics/index.html">Kernels/TensorMechanics</a></h3><ul class="moose-syntax-list collection with-header"><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/actions/LegacyTensorMechanicsAction.html">LegacyTensorMechanicsAction</a>Set up stress divergence kernels with coordinate system aware logic</li></ul></section></section><section class="scrollspy" id="25626631-36bd-4bfc-a355-853281955081" data-section-level="2" data-section-text="Materials"><h2 id="materials"><a href="syntax/Materials/index.html">Materials</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddMaterialAction.html">AddMaterialAction</a>Add a Material object to the simulation.</li><li class="collection-item"><a href="source/materials/CoupledValueFunctionMaterial.html">ADCoupledValueFunctionMaterial</a>Compute a function value from coupled variables</li><li class="collection-item"><a href="source/materials/DerivativeParsedMaterial.html">ADDerivativeParsedMaterial</a>Parsed Function Material with automatic derivatives.</li><li class="collection-item"><a href="source/materials/DerivativeSumMaterial.html">ADDerivativeSumMaterial</a>Meta-material to sum up multiple derivative materials</li><li class="collection-item"><a href="source/functormaterials/GenericFunctorMaterial.html">ADGenericConstantFunctorMaterial</a>FunctorMaterial object for declaring properties that are populated by evaluation of a Functor (a constant, variable, function or functor material property) objects.</li><li class="collection-item"><a href="source/materials/GenericConstantMaterial.html">ADGenericConstantMaterial</a>Declares material properties based on names and values prescribed by input parameters.</li><li class="collection-item"><a href="source/materials/GenericConstantRankTwoTensor.html">ADGenericConstantRankTwoTensor</a>Object for declaring a constant rank two tensor as a material property.</li><li class="collection-item"><a href="source/functormaterials/GenericVectorFunctorMaterial.html">ADGenericConstantVectorFunctorMaterial</a>FunctorMaterial object for declaring vector properties that are populated by evaluation of functor (constants, functions, variables, matprops) object.</li><li class="collection-item"><a href="source/materials/GenericConstantVectorMaterial.html">ADGenericConstantVectorMaterial</a>Declares material properties based on names and vector values prescribed by input parameters.</li><li class="collection-item"><a href="source/functormaterials/GenericFunctorMaterial.html">ADGenericFunctionFunctorMaterial</a>FunctorMaterial object for declaring properties that are populated by evaluation of a Functor (a constant, variable, function or functor material property) objects.</li><li class="collection-item"><a href="source/materials/GenericFunctionMaterial.html">ADGenericFunctionMaterial</a>Material object for declaring properties that are populated by evaluation of Function object.</li><li class="collection-item"><a href="source/materials/GenericFunctionRankTwoTensor.html">ADGenericFunctionRankTwoTensor</a>Material object for defining rank two tensor properties using functions.</li><li class="collection-item"><a href="source/materials/GenericFunctionVectorMaterial.html">ADGenericFunctionVectorMaterial</a>Material object for declaring vector properties that are populated by evaluation of Function objects.</li><li class="collection-item"><a href="source/functormaterials/GenericFunctorGradientMaterial.html">ADGenericFunctorGradientMaterial</a>FunctorMaterial object for declaring properties that are populated by evaluation of gradients of Functors (a constant, variable, function or functor material property) objects.</li><li class="collection-item"><a href="source/functormaterials/GenericFunctorMaterial.html">ADGenericFunctorMaterial</a>FunctorMaterial object for declaring properties that are populated by evaluation of a Functor (a constant, variable, function or functor material property) objects.</li><li class="collection-item"><a href="source/functormaterials/GenericVectorFunctorMaterial.html">ADGenericVectorFunctorMaterial</a>FunctorMaterial object for declaring vector properties that are populated by evaluation of functor (constants, functions, variables, matprops) object.</li><li class="collection-item"><a href="source/materials/ParsedMaterial.html">ADParsedMaterial</a>Parsed expression Material.</li><li class="collection-item"><a href="source/functormaterials/PiecewiseByBlockFunctorMaterial.html">ADPiecewiseByBlockFunctorMaterial</a>Computes a property value on a per-subdomain basis</li><li class="collection-item"><a href="source/functormaterials/PiecewiseByBlockFunctorMaterial.html">ADPiecewiseByBlockVectorFunctorMaterial</a>Computes a property value on a per-subdomain basis</li><li class="collection-item"><a href="source/materials/PiecewiseConstantByBlockMaterial.html">ADPiecewiseConstantByBlockMaterial</a>Computes a property value on a per-subdomain basis</li><li class="collection-item"><a href="source/materials/ADPiecewiseLinearInterpolationMaterial.html">ADPiecewiseLinearInterpolationMaterial</a>Compute a property using a piecewise linear interpolation to define its dependence on a variable</li><li class="collection-item"><a href="source/functormaterials/VectorMagnitudeFunctorMaterial.html">ADVectorMagnitudeFunctorMaterial</a>This class takes up to three scalar-valued functors corresponding to vector components <em>or</em> a single vector functor and computes the Euclidean norm.</li><li class="collection-item"><a href="source/materials/CoupledValueFunctionMaterial.html">CoupledValueFunctionMaterial</a>Compute a function value from coupled variables</li><li class="collection-item"><a href="source/materials/DerivativeParsedMaterial.html">DerivativeParsedMaterial</a>Parsed Function Material with automatic derivatives.</li><li class="collection-item"><a href="source/materials/DerivativeSumMaterial.html">DerivativeSumMaterial</a>Meta-material to sum up multiple derivative materials</li><li class="collection-item"><a href="source/functormaterials/PiecewiseByBlockFunctorMaterial.html">FVADPropValPerSubdomainMaterial</a>Computes a property value on a per-subdomain basis</li><li class="collection-item"><a href="source/functormaterials/PiecewiseByBlockFunctorMaterial.html">FVPropValPerSubdomainMaterial</a>Computes a property value on a per-subdomain basis</li><li class="collection-item"><a href="source/functormaterials/FunctorADConverter.html">FunctorADConverter</a>Converts regular functors to AD functors and AD functors to regular functors</li><li class="collection-item"><a href="source/materials/GenericConstant2DArray.html">GenericConstant2DArray</a>A material evaluating one material property in type of RealEigenMatrix</li><li class="collection-item"><a href="source/materials/GenericConstantArray.html">GenericConstantArray</a>A material evaluating one material property in type of RealEigenVector</li><li class="collection-item"><a href="source/functormaterials/GenericFunctorMaterial.html">GenericConstantFunctorMaterial</a>FunctorMaterial object for declaring properties that are populated by evaluation of a Functor (a constant, variable, function or functor material property) objects.</li><li class="collection-item"><a href="source/materials/GenericConstantMaterial.html">GenericConstantMaterial</a>Declares material properties based on names and values prescribed by input parameters.</li><li class="collection-item"><a href="source/materials/GenericConstantRankTwoTensor.html">GenericConstantRankTwoTensor</a>Object for declaring a constant rank two tensor as a material property.</li><li class="collection-item"><a href="source/functormaterials/GenericVectorFunctorMaterial.html">GenericConstantVectorFunctorMaterial</a>FunctorMaterial object for declaring vector properties that are populated by evaluation of functor (constants, functions, variables, matprops) object.</li><li class="collection-item"><a href="source/materials/GenericConstantVectorMaterial.html">GenericConstantVectorMaterial</a>Declares material properties based on names and vector values prescribed by input parameters.</li><li class="collection-item"><a href="source/functormaterials/GenericFunctorMaterial.html">GenericFunctionFunctorMaterial</a>FunctorMaterial object for declaring properties that are populated by evaluation of a Functor (a constant, variable, function or functor material property) objects.</li><li class="collection-item"><a href="source/materials/GenericFunctionMaterial.html">GenericFunctionMaterial</a>Material object for declaring properties that are populated by evaluation of Function object.</li><li class="collection-item"><a href="source/materials/GenericFunctionRankTwoTensor.html">GenericFunctionRankTwoTensor</a>Material object for defining rank two tensor properties using functions.</li><li class="collection-item"><a href="source/materials/GenericFunctionVectorMaterial.html">GenericFunctionVectorMaterial</a>Material object for declaring vector properties that are populated by evaluation of Function objects.</li><li class="collection-item"><a href="source/functormaterials/GenericFunctorGradientMaterial.html">GenericFunctorGradientMaterial</a>FunctorMaterial object for declaring properties that are populated by evaluation of gradients of Functors (a constant, variable, function or functor material property) objects.</li><li class="collection-item"><a href="source/functormaterials/GenericFunctorMaterial.html">GenericFunctorMaterial</a>FunctorMaterial object for declaring properties that are populated by evaluation of a Functor (a constant, variable, function or functor material property) objects.</li><li class="collection-item"><a href="source/functormaterials/GenericVectorFunctorMaterial.html">GenericVectorFunctorMaterial</a>FunctorMaterial object for declaring vector properties that are populated by evaluation of functor (constants, functions, variables, matprops) object.</li><li class="collection-item"><a href="source/materials/MaterialADConverter.html">MaterialADConverter</a>Converts regular material properties to AD properties and vice versa</li><li class="collection-item"><a href="source/materials/MaterialADConverter.html">MaterialConverter</a>Converts regular material properties to AD properties and vice versa</li><li class="collection-item"><a href="source/materials/MaterialFunctorConverter.html">MaterialFunctorConverter</a>Converts functor to non-AD and AD regular material properties</li><li class="collection-item"><a href="source/materials/ParsedMaterial.html">ParsedMaterial</a>Parsed expression Material.</li><li class="collection-item"><a href="source/functormaterials/PiecewiseByBlockFunctorMaterial.html">PiecewiseByBlockFunctorMaterial</a>Computes a property value on a per-subdomain basis</li><li class="collection-item"><a href="source/functormaterials/PiecewiseByBlockFunctorMaterial.html">PiecewiseByBlockVectorFunctorMaterial</a>Computes a property value on a per-subdomain basis</li><li class="collection-item"><a href="source/materials/PiecewiseConstantByBlockMaterial.html">PiecewiseConstantByBlockMaterial</a>Computes a property value on a per-subdomain basis</li><li class="collection-item"><a href="source/materials/PiecewiseLinearInterpolationMaterial.html">PiecewiseLinearInterpolationMaterial</a>Compute a property using a piecewise linear interpolation to define its dependence on a variable</li><li class="collection-item"><a href="source/materials/MaterialADConverter.html">RankFourTensorMaterialADConverter</a>Converts regular material properties to AD properties and vice versa</li><li class="collection-item"><a href="source/materials/MaterialADConverter.html">RankFourTensorMaterialConverter</a>Converts regular material properties to AD properties and vice versa</li><li class="collection-item"><a href="source/materials/MaterialADConverter.html">RankTwoTensorMaterialADConverter</a>Converts regular material properties to AD properties and vice versa</li><li class="collection-item"><a href="source/materials/MaterialADConverter.html">RankTwoTensorMaterialConverter</a>Converts regular material properties to AD properties and vice versa</li><li class="collection-item"><a href="source/functormaterials/FunctorADConverter.html">VectorFunctorADConverter</a>Converts regular functors to AD functors and AD functors to regular functors</li><li class="collection-item"><a href="source/functormaterials/VectorMagnitudeFunctorMaterial.html">VectorMagnitudeFunctorMaterial</a>This class takes up to three scalar-valued functors corresponding to vector components <em>or</em> a single vector functor and computes the Euclidean norm.</li><li class="collection-item"><a href="source/materials/MaterialFunctorConverter.html">VectorMaterialFunctorConverter</a>Converts functor to non-AD and AD regular material properties</li><li class="collection-header">Navier Stokes App</li><li class="collection-item"><a href="source/materials/Air.html">Air</a>Air.</li><li class="collection-item"><a href="source/materials/ConservedVarValuesMaterial.html">ConservedVarValuesMaterial</a>Provides access to variables for a conserved variable set of density, total fluid energy, and momentum</li><li class="collection-item"><a href="source/functormaterials/ExponentialFrictionMaterial.html">ExponentialFrictionMaterial</a>Computes a Reynolds number-exponential friction factor.</li><li class="collection-item"><a href="source/materials/GeneralFluidProps.html">GeneralFluidProps</a>Computes fluid properties using a (P, T) formulation</li><li class="collection-item"><a href="source/functormaterials/GeneralFunctorFluidProps.html">GeneralFunctorFluidProps</a>Creates functor fluid properties using a (P, T) formulation</li><li class="collection-item"><a href="source/materials/PINSFEMaterial.html">GenericPorousMediumMaterial</a>Computes generic material properties related to simulation of fluid flow in a porous medium</li><li class="collection-item"><a href="source/materials/INSAD3Eqn.html">INSAD3Eqn</a>This material computes properties needed for stabilized formulations of the mass, momentum, and energy equations.</li><li class="collection-item"><a href="source/materials/INSADMaterial.html">INSADMaterial</a>This is the material class used to compute some of the strong residuals for the INS equations.</li><li class="collection-item"><a href="source/materials/INSADStabilized3Eqn.html">INSADStabilized3Eqn</a>This is the material class used to compute the stabilization parameter tau for momentum and tau_energy for the energy equation.</li><li class="collection-item"><a href="source/materials/INSADTauMaterial.html">INSADTauMaterial</a>This is the material class used to compute the stabilization parameter tau.</li><li class="collection-item"><a href="source/materials/INSFEMaterial.html">INSFEMaterial</a>Computes generic material properties related to simulation of fluid flow</li><li class="collection-item"><a href="source/materials/INSFVEnthalpyMaterial.html">INSFVEnthalpyMaterial</a>This is the material class used to compute enthalpy for the incompressible/weakly-compressible finite-volume implementation of the Navier-Stokes equations.</li><li class="collection-item"><a href="source/materials/INSFVMushyPorousFrictionMaterial.html">INSFVMushyPorousFrictionMaterial</a>Computes the mushy zone porous resistance for solidification/melting problems.</li><li class="collection-item"><a href="source/functormaterials/LinearFrictionFactorFunctorMaterial.html">LinearFrictionFactorFunctorMaterial</a>Material class used to compute a friction factor of the form A * f(r, t) + B * g(r, t) * |v_I| with A, B vector constants, f(r, t) and g(r, t) functors of space and time, and |v_I| the interstitial speed</li><li class="collection-item"><a href="source/materials/INSFEMaterial.html">MDFluidMaterial</a>Computes generic material properties related to simulation of fluid flow</li><li class="collection-item"><a href="source/materials/MixingLengthTurbulentViscosityMaterial.html">MixingLengthTurbulentViscosityMaterial</a>Computes the material property corresponding to the total viscositycomprising the mixing length model turbulent total_viscosityand the molecular viscosity.</li><li class="collection-item"><a href="source/materials/NSFVFrictionFlowDiodeMaterial.html">NSFVFrictionFlowDiodeMaterial</a>Increases the anistropic friction coefficients, linear or quadratic, by K_i * |direction_i| when the diode is turned on with a boolean</li><li class="collection-item"><a href="source/materials/NSFVMixtureMaterial.html">NSFVMixtureMaterial</a>Compute the arithmetic mean of material properties using a phase fraction.</li><li class="collection-item"><a href="source/materials/PINSFEMaterial.html">PINSFEMaterial</a>Computes generic material properties related to simulation of fluid flow in a porous medium</li><li class="collection-item"><a href="source/functormaterials/PINSFVSpeedFunctorMaterial.html">PINSFVSpeedFunctorMaterial</a>This is the material class used to compute the interstitial velocity norm for the incompressible and weakly compressible primitive superficial finite-volume implementation of porous media equations.</li><li class="collection-item"><a href="source/materials/PorousConservedVarMaterial.html">PorousConservedVarMaterial</a>Provides access to variables for a conserved variable set of density, total fluid energy, and momentum</li><li class="collection-item"><a href="source/materials/PorousMixedVarMaterial.html">PorousMixedVarMaterial</a>Provides access to variables for a primitive variable set of pressure, temperature, and superficial velocity</li><li class="collection-item"><a href="source/materials/PorousPrimitiveVarMaterial.html">PorousPrimitiveVarMaterial</a>Provides access to variables for a primitive variable set of pressure, temperature, and superficial velocity</li><li class="collection-item"><a href="source/functormaterials/ReynoldsNumberFunctorMaterial.html">ReynoldsNumberFunctorMaterial</a>Computes a Reynolds number.</li><li class="collection-item"><a href="source/functormaterials/RhoFromPTFunctorMaterial.html">RhoFromPTFunctorMaterial</a>Computes the density from coupled pressure and temperature functors (variables, functions, functor material properties</li><li class="collection-item"><a href="source/materials/SoundspeedMat.html">SoundspeedMat</a>Computes the speed of sound</li><li class="collection-item"><a href="source/functormaterials/ThermalDiffusivityFunctorMaterial.html">ThermalDiffusivityFunctorMaterial</a>Computes the thermal diffusivity given the thermal conductivity, specific heat capacity, and fluid density.</li><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/materials/ADAbruptSoftening.html">ADAbruptSoftening</a>Softening model with an abrupt stress release upon cracking. This class relies on automatic differentiation and is intended to be used with ADComputeSmearedCrackingStress.</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/CZMComputeDisplacementJumpSmallStrain.html">ADCZMComputeDisplacementJumpSmallStrain</a>Compute the total displacement jump across a czm interface in local coordinates for the Small Strain kinematic formulation</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/CZMComputeDisplacementJumpTotalLagrangian.html">ADCZMComputeDisplacementJumpTotalLagrangian</a>Compute the displacement jump increment across a czm interface in local coordinates for the Total Lagrangian kinematic formulation</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/ADCZMComputeGlobalTractionSmallStrain.html">ADCZMComputeGlobalTractionSmallStrain</a>Computes the czm traction in global coordinates for a small strain kinematic formulation</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/ADCZMComputeGlobalTractionTotalLagrangian.html">ADCZMComputeGlobalTractionTotalLagrangian</a>Compute the equilibrium traction (PK1) and its derivatives for the Total Lagrangian formulation.</li><li class="collection-item"><a href="source/materials/CombinedScalarDamage.html">ADCombinedScalarDamage</a>Scalar damage model which is computed as a function of multiple scalar damage models</li><li class="collection-item"><a href="source/materials/ADComputeAxisymmetricRZFiniteStrain.html">ADComputeAxisymmetricRZFiniteStrain</a>Compute a strain increment for finite strains under axisymmetric assumptions.</li><li class="collection-item"><a href="source/materials/ADComputeAxisymmetricRZIncrementalStrain.html">ADComputeAxisymmetricRZIncrementalStrain</a>Compute a strain increment and rotation increment for finite strains under axisymmetric assumptions.</li><li class="collection-item"><a href="source/materials/ADComputeAxisymmetricRZSmallStrain.html">ADComputeAxisymmetricRZSmallStrain</a>Compute a small strain in an Axisymmetric geometry</li><li class="collection-item"><a href="source/materials/ComputeDamageStress.html">ADComputeDamageStress</a>Compute stress for damaged elastic materials in conjunction with a damage model.</li><li class="collection-item"><a href="source/materials/ComputeDilatationThermalExpansionFunctionEigenstrain.html">ADComputeDilatationThermalExpansionFunctionEigenstrain</a>Computes eigenstrain due to thermal expansion using a function that describes the total dilatation as a function of temperature</li><li class="collection-item"><a href="source/materials/ComputeEigenstrain.html">ADComputeEigenstrain</a>Computes a constant Eigenstrain</li><li class="collection-item"><a href="source/materials/ComputeElasticityTensor.html">ADComputeElasticityTensor</a>Compute an elasticity tensor.</li><li class="collection-item"><a href="source/materials/ADComputeFiniteShellStrain.html">ADComputeFiniteShellStrain</a>Compute a large strain increment for the shell.</li><li class="collection-item"><a href="source/materials/ADComputeFiniteStrain.html">ADComputeFiniteStrain</a>Compute a strain increment and rotation increment for finite strains.</li><li class="collection-item"><a href="source/materials/ADComputeFiniteStrainElasticStress.html">ADComputeFiniteStrainElasticStress</a>Compute stress using elasticity for finite strains</li><li class="collection-item"><a href="source/materials/ADComputeGreenLagrangeStrain.html">ADComputeGreenLagrangeStrain</a>Compute a Green-Lagrange strain.</li><li class="collection-item"><a href="source/materials/ADComputeIncrementalShellStrain.html">ADComputeIncrementalShellStrain</a>Compute a small strain increment for the shell.</li><li class="collection-item"><a href="source/materials/ADComputeIncrementalSmallStrain.html">ADComputeIncrementalSmallStrain</a>Compute a strain increment and rotation increment for small strains.</li><li class="collection-item"><a href="source/materials/ComputeInstantaneousThermalExpansionFunctionEigenstrain.html">ADComputeInstantaneousThermalExpansionFunctionEigenstrain</a>Computes eigenstrain due to thermal expansion using a function that describes the instantaneous thermal expansion as a function of temperature</li><li class="collection-item"><a href="source/materials/ComputeIsotropicElasticityTensor.html">ADComputeIsotropicElasticityTensor</a>Compute a constant isotropic elasticity tensor.</li><li class="collection-item"><a href="source/materials/ADComputeIsotropicElasticityTensorShell.html">ADComputeIsotropicElasticityTensorShell</a>Compute a plane stress isotropic elasticity tensor.</li><li class="collection-item"><a href="source/materials/ADComputeLinearElasticStress.html">ADComputeLinearElasticStress</a>Compute stress using elasticity for small strains</li><li class="collection-item"><a href="source/materials/ComputeMeanThermalExpansionFunctionEigenstrain.html">ADComputeMeanThermalExpansionFunctionEigenstrain</a>Computes eigenstrain due to thermal expansion using a function that describes the mean thermal expansion as a function of temperature</li><li class="collection-item"><a href="source/materials/ADComputeMultipleInelasticStress.html">ADComputeMultipleInelasticStress</a>Compute state (stress and internal parameters such as plastic strains and internal parameters) using an iterative process.  Combinations of creep models and plastic models may be used.</li><li class="collection-item"><a href="source/materials/ADComputeMultiplePorousInelasticStress.html">ADComputeMultiplePorousInelasticStress</a>Compute state (stress and internal parameters such as plastic strains and internal parameters) using an iterative process. A porosity material property is defined and is calculated from the trace of inelastic strain increment.</li><li class="collection-item"><a href="source/materials/ADComputePlaneFiniteStrain.html">ADComputePlaneFiniteStrain</a>Compute strain increment and rotation increment for finite strain under 2D planar assumptions.</li><li class="collection-item"><a href="source/materials/ADComputePlaneIncrementalStrain.html">ADComputePlaneIncrementalStrain</a>Compute strain increment for small strain under 2D planar assumptions.</li><li class="collection-item"><a href="source/materials/ADComputePlaneSmallStrain.html">ADComputePlaneSmallStrain</a>Compute a small strain under generalized plane strain assumptions where the out of plane strain is generally nonzero.</li><li class="collection-item"><a href="source/materials/ADComputeRSphericalFiniteStrain.html">ADComputeRSphericalFiniteStrain</a>Compute a strain increment and rotation increment for finite strains in 1D spherical symmetry problems.</li><li class="collection-item"><a href="source/materials/ADComputeRSphericalIncrementalStrain.html">ADComputeRSphericalIncrementalStrain</a>Compute a strain increment for incremental strains in 1D spherical symmetry problems.</li><li class="collection-item"><a href="source/materials/ADComputeRSphericalSmallStrain.html">ADComputeRSphericalSmallStrain</a>Compute a small strain 1D spherical symmetry case.</li><li class="collection-item"><a href="source/materials/ADComputeShellStress.html">ADComputeShellStress</a>Compute in-plane stress using elasticity for shell</li><li class="collection-item"><a href="source/materials/ADComputeSmallStrain.html">ADComputeSmallStrain</a>Compute a small strain.</li><li class="collection-item"><a href="source/materials/ADComputeSmearedCrackingStress.html">ADComputeSmearedCrackingStress</a>Compute stress using a fixed smeared cracking model. Uses automatic differentiation</li><li class="collection-item"><a href="source/materials/ADComputeStrainIncrementBasedStress.html">ADComputeStrainIncrementBasedStress</a>Compute stress after subtracting inelastic strain increments</li><li class="collection-item"><a href="source/materials/ComputeThermalExpansionEigenstrain.html">ADComputeThermalExpansionEigenstrain</a>Computes eigenstrain due to thermal expansion with a constant coefficient</li><li class="collection-item"><a href="source/materials/ADComputeVariableIsotropicElasticityTensor.html">ADComputeVariableIsotropicElasticityTensor</a>Compute an isotropic elasticity tensor for elastic constants that change as a function of material properties</li><li class="collection-item"><a href="source/materials/EshelbyTensor.html">ADEshelbyTensor</a>Computes the Eshelby tensor as a function of strain energy density and the first Piola-Kirchhoff stress</li><li class="collection-item"><a href="source/materials/ADExponentialSoftening.html">ADExponentialSoftening</a>Softening model with an exponential softening response upon cracking. This class is intended to be used with ADComputeSmearedCrackingStress and relies on automatic differentiation.</li><li class="collection-item"><a href="source/materials/HillConstants.html">ADHillConstants</a>Build and rotate the Hill Tensor. It can be used with other Hill plasticity and creep materials.</li><li class="collection-item"><a href="source/materials/HillCreepStressUpdate.html">ADHillCreepStressUpdate</a>This class uses the stress update material in a generalized radial return anisotropic power law creep model.  This class can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/HillElastoPlasticityStressUpdate.html">ADHillElastoPlasticityStressUpdate</a>This class uses the generalized radial return for anisotropic elasto-plasticity model.This class can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/HillPlasticityStressUpdate.html">ADHillPlasticityStressUpdate</a>This class uses the generalized radial return for anisotropic plasticity model.This class can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/IsotropicPlasticityStressUpdate.html">ADIsotropicPlasticityStressUpdate</a>This class uses the discrete material in a radial return isotropic plasticity model.  This class is one of the basic radial return constitutive models, yet it can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/IsotropicPowerLawHardeningStressUpdate.html">ADIsotropicPowerLawHardeningStressUpdate</a>This class uses the discrete material in a radial return isotropic plasticity power law hardening model, solving for the yield stress as the intersection of the power law relation curve and Hooke&#x27;s law.  This class can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/LAROMANCEPartitionStressUpdateBase.html">ADLAROMANCEPartitionStressUpdate</a>LAROMANCE base class for partitioned reduced order models</li><li class="collection-item"><a href="source/materials/LAROMANCEStressUpdateBase.html">ADLAROMANCEStressUpdate</a>Base class to calculate the effective creep strain based on the rates predicted by a material  specific Los Alamos Reduced Order Model derived from a Visco-Plastic Self Consistent calculations.</li><li class="collection-item"><a href="source/materials/ADMultiplePowerLawCreepStressUpdate.html">ADMultiplePowerLawCreepStressUpdate</a>This class uses the stress update material in a radial return isotropic power law creep model. This class can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/NonlocalDamage.html">ADNonlocalDamage</a>Nonlocal damage model. Given an RadialAverage UO this creates a new damage index that can be used as for ComputeDamageStress without havign to change existing local damage models.</li><li class="collection-item"><a href="source/materials/PorosityFromStrain.html">ADPorosityFromStrain</a>Porosity calculation from the inelastic strain.</li><li class="collection-item"><a href="source/materials/PowerLawCreepStressUpdate.html">ADPowerLawCreepStressUpdate</a>This class uses the stress update material in a radial return isotropic power law creep model. This class can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/ADPowerLawSoftening.html">ADPowerLawSoftening</a>Softening model with an abrupt stress release upon cracking. This class is intended to be used with ADComputeSmearedCrackingStress and relies on automatic differentiation.</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/ADPureElasticTractionSeparation.html">ADPureElasticTractionSeparation</a>Pure elastic traction separation law.</li><li class="collection-item"><a href="source/materials/RankTwoCartesianComponent.html">ADRankTwoCartesianComponent</a>Access a component of a RankTwoTensor</li><li class="collection-item"><a href="source/materials/RankTwoCylindricalComponent.html">ADRankTwoCylindricalComponent</a>Compute components of a rank-2 tensor in a cylindrical coordinate system</li><li class="collection-item"><a href="source/materials/RankTwoDirectionalComponent.html">ADRankTwoDirectionalComponent</a>Compute a Direction scalar property of a RankTwoTensor</li><li class="collection-item"><a href="source/materials/RankTwoInvariant.html">ADRankTwoInvariant</a>Compute a invariant property of a RankTwoTensor</li><li class="collection-item"><a href="source/materials/RankTwoSphericalComponent.html">ADRankTwoSphericalComponent</a>Compute components of a rank-2 tensor in a spherical coordinate system</li><li class="collection-item"><a href="source/materials/ScalarMaterialDamage.html">ADScalarMaterialDamage</a>Scalar damage model for which the damage is prescribed by another material</li><li class="collection-item"><a href="source/materials/StrainEnergyDensity.html">ADStrainEnergyDensity</a>Computes the strain energy density using a combination of the elastic and inelastic components of the strain increment, which is a valid assumption for monotonic behavior.</li><li class="collection-item"><a href="source/materials/StrainEnergyRateDensity.html">ADStrainEnergyRateDensity</a>Computes the strain energy density rate using a combination of the elastic and inelastic components of the strain increment, which is a valid assumption for monotonic behavior.</li><li class="collection-item"><a href="source/materials/ADComputeFiniteStrain.html">ADSymmetricFiniteStrain</a>Compute a strain increment and rotation increment for finite strains.</li><li class="collection-item"><a href="source/materials/ADComputeFiniteStrainElasticStress.html">ADSymmetricFiniteStrainElasticStress</a>Compute stress using elasticity for finite strains</li><li class="collection-item"><a href="source/materials/ADComputeIncrementalSmallStrain.html">ADSymmetricIncrementalSmallStrain</a>Compute a strain increment and rotation increment for small strains.</li><li class="collection-item"><a href="source/materials/ComputeIsotropicElasticityTensor.html">ADSymmetricIsotropicElasticityTensor</a>Compute a constant isotropic elasticity tensor.</li><li class="collection-item"><a href="source/materials/ADComputeLinearElasticStress.html">ADSymmetricLinearElasticStress</a>Compute stress using elasticity for small strains</li><li class="collection-item"><a href="source/materials/ADComputeSmallStrain.html">ADSymmetricSmallStrain</a>Compute a small strain.</li><li class="collection-item"><a href="source/materials/TemperatureDependentHardeningStressUpdate.html">ADTemperatureDependentHardeningStressUpdate</a>Computes the stress as a function of temperature and plastic strain from user-supplied hardening functions. This class can be used in conjunction with other creep and plasticity materials for more complex simulations</li><li class="collection-item"><a href="source/materials/ADViscoplasticityStressUpdate.html">ADViscoplasticityStressUpdate</a>This material computes the non-linear homogenized gauge stress in order to compute the viscoplastic responce due to creep in porous materials. This material must be used in conjunction with ADComputeMultiplePorousInelasticStress</li><li class="collection-item"><a href="source/materials/abaqus/AbaqusUMATStress.html">AbaqusUMATStress</a>Coupling material to use Abaqus UMAT models in MOOSE</li><li class="collection-item"><a href="source/materials/AbruptSoftening.html">AbruptSoftening</a>Softening model with an abrupt stress release upon cracking. This class is intended to be used with ComputeSmearedCrackingStress.</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/BiLinearMixedModeTraction.html">BiLinearMixedModeTraction</a>Mixed mode bilinear traction separation law.</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/CZMComputeDisplacementJumpSmallStrain.html">CZMComputeDisplacementJumpSmallStrain</a>Compute the total displacement jump across a czm interface in local coordinates for the Small Strain kinematic formulation</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/CZMComputeDisplacementJumpTotalLagrangian.html">CZMComputeDisplacementJumpTotalLagrangian</a>Compute the displacement jump increment across a czm interface in local coordinates for the Total Lagrangian kinematic formulation</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/CZMComputeGlobalTractionSmallStrain.html">CZMComputeGlobalTractionSmallStrain</a>Computes the czm traction in global coordinates for a small strain kinematic formulation</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/CZMComputeGlobalTractionTotalLagrangian.html">CZMComputeGlobalTractionTotalLagrangian</a>Compute the equilibrium traction (PK1) and its derivatives for the Total Lagrangian formulation.</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/CZMRealVectorCartesianComponent.html">CZMRealVectorCartesianComponent</a>Access a component of a RealVectorValue defined on a cohesive zone</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/CZMRealVectorScalar.html">CZMRealVectorScalar</a>Compute the normal or tangent component of a vector quantity defined on a cohesive interface.</li><li class="collection-item"><a href="source/materials/CappedDruckerPragerCosseratStressUpdate.html">CappedDruckerPragerCosseratStressUpdate</a>Capped Drucker-Prager plasticity stress calculator for the Cosserat situation where the host medium (ie, the limit where all Cosserat effects are zero) is isotropic.  Note that the return-map flow rule uses an isotropic elasticity tensor built with the &#x27;host&#x27; properties defined by the user.</li><li class="collection-item"><a href="source/materials/CappedDruckerPragerStressUpdate.html">CappedDruckerPragerStressUpdate</a>Capped Drucker-Prager plasticity stress calculator</li><li class="collection-item"><a href="source/materials/CappedMohrCoulombCosseratStressUpdate.html">CappedMohrCoulombCosseratStressUpdate</a>Capped Mohr-Coulomb plasticity stress calculator for the Cosserat situation where the host medium (ie, the limit where all Cosserat effects are zero) is isotropic.  Note that the return-map flow rule uses an isotropic elasticity tensor built with the &#x27;host&#x27; properties defined by the user.</li><li class="collection-item"><a href="source/materials/CappedMohrCoulombStressUpdate.html">CappedMohrCoulombStressUpdate</a>Nonassociative, smoothed, Mohr-Coulomb plasticity capped with tensile (Rankine) and compressive caps, with hardening/softening</li><li class="collection-item"><a href="source/materials/CappedWeakInclinedPlaneStressUpdate.html">CappedWeakInclinedPlaneStressUpdate</a>Capped weak inclined plane plasticity stress calculator</li><li class="collection-item"><a href="source/materials/CappedWeakPlaneCosseratStressUpdate.html">CappedWeakPlaneCosseratStressUpdate</a>Capped weak-plane plasticity Cosserat stress calculator</li><li class="collection-item"><a href="source/materials/CappedWeakPlaneStressUpdate.html">CappedWeakPlaneStressUpdate</a>Capped weak-plane plasticity stress calculator</li><li class="collection-item"><a href="source/materials/CombinedScalarDamage.html">CombinedScalarDamage</a>Scalar damage model which is computed as a function of multiple scalar damage models</li><li class="collection-item"><a href="source/materials/CompositeEigenstrain.html">CompositeEigenstrain</a>Assemble an Eigenstrain tensor from multiple tensor contributions weighted by material properties</li><li class="collection-item"><a href="source/materials/CompositeElasticityTensor.html">CompositeElasticityTensor</a>Assemble an elasticity tensor from multiple tensor contributions weighted by material properties</li><li class="collection-item"><a href="source/materials/ComputeAxisymmetric1DFiniteStrain.html">ComputeAxisymmetric1DFiniteStrain</a>Compute a strain increment and rotation increment for finite strains in an axisymmetric 1D problem</li><li class="collection-item"><a href="source/materials/ComputeAxisymmetric1DIncrementalStrain.html">ComputeAxisymmetric1DIncrementalStrain</a>Compute strain increment for small strains in an axisymmetric 1D problem</li><li class="collection-item"><a href="source/materials/ComputeAxisymmetric1DSmallStrain.html">ComputeAxisymmetric1DSmallStrain</a>Compute a small strain in an Axisymmetric 1D problem</li><li class="collection-item"><a href="source/materials/ComputeAxisymmetricRZFiniteStrain.html">ComputeAxisymmetricRZFiniteStrain</a>Compute a strain increment for finite strains under axisymmetric assumptions.</li><li class="collection-item"><a href="source/materials/ComputeAxisymmetricRZIncrementalStrain.html">ComputeAxisymmetricRZIncrementalStrain</a>Compute a strain increment and rotation increment for small strains under axisymmetric assumptions.</li><li class="collection-item"><a href="source/materials/ComputeAxisymmetricRZSmallStrain.html">ComputeAxisymmetricRZSmallStrain</a>Compute a small strain in an Axisymmetric geometry</li><li class="collection-item"><a href="source/materials/ComputeBeamResultants.html">ComputeBeamResultants</a>Compute forces and moments using elasticity</li><li class="collection-item"><a href="source/materials/ComputeConcentrationDependentElasticityTensor.html">ComputeConcentrationDependentElasticityTensor</a>Compute concentration dependent elasticity tensor.</li><li class="collection-item"><a href="source/materials/ComputeCosseratElasticityTensor.html">ComputeCosseratElasticityTensor</a>Compute Cosserat elasticity and flexural bending rigidity tensors</li><li class="collection-item"><a href="source/materials/ComputeCosseratIncrementalSmallStrain.html">ComputeCosseratIncrementalSmallStrain</a>Compute incremental small Cosserat strains</li><li class="collection-item"><a href="source/materials/ComputeCosseratLinearElasticStress.html">ComputeCosseratLinearElasticStress</a>Compute Cosserat stress and couple-stress elasticity for small strains</li><li class="collection-item"><a href="source/materials/ComputeCosseratSmallStrain.html">ComputeCosseratSmallStrain</a>Compute small Cosserat strains</li><li class="collection-item"><a href="source/materials/ComputeCrackedStress.html">ComputeCrackedStress</a>Computes energy and modifies the stress for phase field fracture</li><li class="collection-item"><a href="source/materials/crystal_plasticity/ComputeCrystalPlasticityThermalEigenstrain.html">ComputeCrystalPlasticityThermalEigenstrain</a></li><li class="collection-item"><a href="source/materials/ComputeDamageStress.html">ComputeDamageStress</a>Compute stress for damaged elastic materials in conjunction with a damage model.</li><li class="collection-item"><a href="source/materials/ComputeDeformGradBasedStress.html">ComputeDeformGradBasedStress</a>Computes stress based on Lagrangian strain</li><li class="collection-item"><a href="source/materials/ComputeDilatationThermalExpansionFunctionEigenstrain.html">ComputeDilatationThermalExpansionFunctionEigenstrain</a>Computes eigenstrain due to thermal expansion using a function that describes the total dilatation as a function of temperature</li><li class="collection-item"><a href="source/materials/ComputeEigenstrain.html">ComputeEigenstrain</a>Computes a constant Eigenstrain</li><li class="collection-item"><a href="source/materials/ComputeEigenstrainBeamFromVariable.html">ComputeEigenstrainBeamFromVariable</a>Computes an eigenstrain from a set of variables</li><li class="collection-item"><a href="source/materials/ComputeEigenstrainFromInitialStress.html">ComputeEigenstrainFromInitialStress</a>Computes an eigenstrain from an initial stress</li><li class="collection-item"><a href="source/materials/ComputeElasticityBeam.html">ComputeElasticityBeam</a>Computes the equivalent of the elasticity tensor for the beam element, which are vectors of material translational and flexural stiffness.</li><li class="collection-item"><a href="source/materials/ComputeElasticityTensor.html">ComputeElasticityTensor</a>Compute an elasticity tensor.</li><li class="collection-item"><a href="source/materials/crystal_plasticity/ComputeElasticityTensorCP.html">ComputeElasticityTensorCP</a>Compute an elasticity tensor for crystal plasticity.</li><li class="collection-item"><a href="source/materials/crystal_plasticity/ComputeElasticityTensorConstantRotationCP.html">ComputeElasticityTensorConstantRotationCP</a>Deprecated Class: please use ComputeElasticityTensorCP instead. Compute an elasticity tensor for crystal plasticity, formulated in the reference frame, with constant Euler angles.</li><li class="collection-item"><a href="source/materials/ComputeExtraStressConstant.html">ComputeExtraStressConstant</a>Computes a constant extra stress that is added to the stress calculated by the constitutive model</li><li class="collection-item"><a href="source/materials/ComputeExtraStressVDWGas.html">ComputeExtraStressVDWGas</a>Computes a hydrostatic stress corresponding to the pressure of a van der Waals gas that is added as an extra_stress to the stress computed by the constitutive model</li><li class="collection-item"><a href="source/materials/ComputeFiniteBeamStrain.html">ComputeFiniteBeamStrain</a>Compute a rotation increment for finite rotations of the beam and computes the small/large strain increments in the current rotated configuration of the beam.</li><li class="collection-item"><a href="source/materials/ComputeFiniteStrain.html">ComputeFiniteStrain</a>Compute a strain increment and rotation increment for finite strains.</li><li class="collection-item"><a href="source/materials/ComputeFiniteStrainElasticStress.html">ComputeFiniteStrainElasticStress</a>Compute stress using elasticity for finite strains</li><li class="collection-item"><a href="source/materials/ComputeGlobalStrain.html">ComputeGlobalStrain</a>Material for storing the global strain values from the scalar variable</li><li class="collection-item"><a href="source/materials/lagrangian/ComputeHomogenizedLagrangianStrain.html">ComputeHomogenizedLagrangianStrain</a></li><li class="collection-item"><a href="source/materials/lagrangian/ComputeHypoelasticStVenantKirchhoffStress.html">ComputeHypoelasticStVenantKirchhoffStress</a>Calculate a small strain elastic stress that is equivalent to the hyperelastic St. Venant-Kirchhoff model if integrated using the Truesdell rate.</li><li class="collection-item"><a href="source/materials/ComputeIncrementalBeamStrain.html">ComputeIncrementalBeamStrain</a>Compute a infinitesimal/large strain increment for the beam.</li><li class="collection-item"><a href="source/materials/ComputeIncrementalSmallStrain.html">ComputeIncrementalSmallStrain</a>Compute a strain increment and rotation increment for small strains.</li><li class="collection-item"><a href="source/materials/ComputeInstantaneousThermalExpansionFunctionEigenstrain.html">ComputeInstantaneousThermalExpansionFunctionEigenstrain</a>Computes eigenstrain due to thermal expansion using a function that describes the instantaneous thermal expansion as a function of temperature</li><li class="collection-item"><a href="source/materials/ComputeInterfaceStress.html">ComputeInterfaceStress</a>Stress in the plane of an interface defined by the gradient of an order parameter</li><li class="collection-item"><a href="source/materials/ComputeIsotropicElasticityTensor.html">ComputeIsotropicElasticityTensor</a>Compute a constant isotropic elasticity tensor.</li><li class="collection-item"><a href="source/materials/lagrangian/ComputeLagrangianLinearElasticStress.html">ComputeLagrangianLinearElasticStress</a>Stress update based on the small (engineering) stress</li><li class="collection-item"><a href="source/materials/lagrangian/ComputeLagrangianStrain.html">ComputeLagrangianStrain</a>Compute strain in Cartesian coordinates.</li><li class="collection-item"><a href="source/materials/lagrangian/ComputeLagrangianStrainAxisymmetricCylindrical.html">ComputeLagrangianStrainAxisymmetricCylindrical</a>Compute strain in 2D axisymmetric RZ coordinates.</li><li class="collection-item"><a href="source/materials/lagrangian/ComputeLagrangianStrainCentrosymmetricSpherical.html">ComputeLagrangianStrainCentrosymmetricSpherical</a>Compute strain in centrosymmetric spherical coordinates.</li><li class="collection-item"><a href="source/materials/lagrangian/ComputeLagrangianWPSStrain.html">ComputeLagrangianWPSStrain</a>Compute strain in Cartesian coordinates.</li><li class="collection-item"><a href="source/materials/lagrangian/ComputeLagrangianWrappedStress.html">ComputeLagrangianWrappedStress</a>Stress update based on the small (engineering) stress</li><li class="collection-item"><a href="source/materials/ComputeLayeredCosseratElasticityTensor.html">ComputeLayeredCosseratElasticityTensor</a>Computes Cosserat elasticity and flexural bending rigidity tensors relevant for simulations with layered materials.  The layering direction is assumed to be perpendicular to the &#x27;z&#x27; direction.</li><li class="collection-item"><a href="source/materials/ComputeLinearElasticPFFractureStress.html">ComputeLinearElasticPFFractureStress</a>Computes the stress and free energy derivatives for the phase field fracture model, with small strain</li><li class="collection-item"><a href="source/materials/ComputeLinearElasticStress.html">ComputeLinearElasticStress</a>Compute stress using elasticity for small strains</li><li class="collection-item"><a href="source/materials/ComputeLinearViscoelasticStress.html">ComputeLinearViscoelasticStress</a>Divides total strain into elastic + creep + eigenstrains</li><li class="collection-item"><a href="source/materials/ComputeMeanThermalExpansionFunctionEigenstrain.html">ComputeMeanThermalExpansionFunctionEigenstrain</a>Computes eigenstrain due to thermal expansion using a function that describes the mean thermal expansion as a function of temperature</li><li class="collection-item"><a href="source/materials/ComputeMultiPlasticityStress.html">ComputeMultiPlasticityStress</a>Material for multi-surface finite-strain plasticity</li><li class="collection-item"><a href="source/materials/crystal_plasticity/ComputeMultipleCrystalPlasticityStress.html">ComputeMultipleCrystalPlasticityStress</a>Crystal Plasticity base class: handles the Newton iteration over the stress residual and calculates the Jacobian based on constitutive laws from multiple material classes that are inherited from CrystalPlasticityStressUpdateBase</li><li class="collection-item"><a href="source/materials/ComputeMultipleInelasticCosseratStress.html">ComputeMultipleInelasticCosseratStress</a>Compute state (stress and other quantities such as plastic strains and internal parameters) using an iterative process, as well as Cosserat versions of these quantities.  Only elasticity is currently implemented for the Cosserat versions.Combinations of creep models and plastic models may be used</li><li class="collection-item"><a href="source/materials/ComputeMultipleInelasticStress.html">ComputeMultipleInelasticStress</a>Compute state (stress and internal parameters such as plastic strains and internal parameters) using an iterative process.  Combinations of creep models and plastic models may be used.</li><li class="collection-item"><a href="source/materials/lagrangian/ComputeNeoHookeanStress.html">ComputeNeoHookeanStress</a>Stress update based on the first Piola-Kirchhoff stress</li><li class="collection-item"><a href="source/materials/ComputePlaneFiniteStrain.html">ComputePlaneFiniteStrain</a>Compute strain increment and rotation increment for finite strain under 2D planar assumptions.</li><li class="collection-item"><a href="source/materials/ComputePlaneIncrementalStrain.html">ComputePlaneIncrementalStrain</a>Compute strain increment for small strain under 2D planar assumptions.</li><li class="collection-item"><a href="source/materials/ComputePlaneSmallStrain.html">ComputePlaneSmallStrain</a>Compute a small strain under generalized plane strain assumptions where the out of plane strain is generally nonzero.</li><li class="collection-item"><a href="source/materials/ComputePlasticHeatEnergy.html">ComputePlasticHeatEnergy</a>Plastic heat energy density = stress * plastic_strain_rate</li><li class="collection-item"><a href="source/materials/ComputeRSphericalFiniteStrain.html">ComputeRSphericalFiniteStrain</a>Compute a strain increment and rotation increment for finite strains in 1D spherical symmetry problems.</li><li class="collection-item"><a href="source/materials/ComputeRSphericalIncrementalStrain.html">ComputeRSphericalIncrementalStrain</a>Compute a strain increment for incremental strains in 1D spherical symmetry problems.</li><li class="collection-item"><a href="source/materials/ComputeRSphericalSmallStrain.html">ComputeRSphericalSmallStrain</a>Compute a small strain 1D spherical symmetry case.</li><li class="collection-item"><a href="source/materials/ComputeReducedOrderEigenstrain.html">ComputeReducedOrderEigenstrain</a>accepts eigenstrains and computes a reduced order eigenstrain for consistency in the order of strain and eigenstrains.</li><li class="collection-item"><a href="source/materials/lagrangian/ComputeSimoHughesJ2PlasticityStress.html">ComputeSimoHughesJ2PlasticityStress</a>The Simo-Hughes style J2 plasticity.</li><li class="collection-item"><a href="source/materials/ComputeSmallStrain.html">ComputeSmallStrain</a>Compute a small strain.</li><li class="collection-item"><a href="source/materials/ComputeSmearedCrackingStress.html">ComputeSmearedCrackingStress</a>Compute stress using a fixed smeared cracking model</li><li class="collection-item"><a href="source/materials/lagrangian/ComputeStVenantKirchhoffStress.html">ComputeStVenantKirchhoffStress</a>Stress update based on the first Piola-Kirchhoff stress</li><li class="collection-item"><a href="source/materials/ComputeStrainIncrementBasedStress.html">ComputeStrainIncrementBasedStress</a>Compute stress after subtracting inelastic strain increments</li><li class="collection-item"><a href="source/materials/ComputeSurfaceTensionKKS.html">ComputeSurfaceTensionKKS</a>Surface tension of an interface defined by the gradient of an order parameter</li><li class="collection-item"><a href="source/materials/ComputeThermalExpansionEigenstrain.html">ComputeThermalExpansionEigenstrain</a>Computes eigenstrain due to thermal expansion with a constant coefficient</li><li class="collection-item"><a href="source/materials/ComputeThermalExpansionEigenstrainBeam.html">ComputeThermalExpansionEigenstrainBeam</a>Computes eigenstrain due to thermal expansion with a constant coefficient</li><li class="collection-item"><a href="source/materials/crystal_plasticity/ComputeUpdatedEulerAngle.html">ComputeUpdatedEulerAngle</a>This class computes the updated Euler angle for crystal plasticity simulations. This needs to be used together with the  ComputeMultipleCrystalPlasticityStress class, where the updated rotation material property is computed. </li><li class="collection-item"><a href="source/materials/ComputeVariableBaseEigenStrain.html">ComputeVariableBaseEigenStrain</a>Computes Eigenstrain based on material property tensor base</li><li class="collection-item"><a href="source/materials/ComputeVariableEigenstrain.html">ComputeVariableEigenstrain</a>Computes an Eigenstrain and its derivatives that is a function of multiple variables, where the prefactor is defined in a derivative material</li><li class="collection-item"><a href="source/materials/ComputeVariableIsotropicElasticityTensor.html">ComputeVariableIsotropicElasticityTensor</a>Compute an isotropic elasticity tensor for elastic constants that change as a function of material properties</li><li class="collection-item"><a href="source/materials/ComputeVolumetricDeformGrad.html">ComputeVolumetricDeformGrad</a>Computes volumetric deformation gradient and adjusts the total deformation gradient</li><li class="collection-item"><a href="source/materials/ComputeVolumetricEigenstrain.html">ComputeVolumetricEigenstrain</a>Computes an eigenstrain that is defined by a set of scalar material properties that summed together define the volumetric change.  This also computes the derivatives of that eigenstrain with respect to a supplied set of variable dependencies.</li><li class="collection-item"><a href="source/materials/crystal_plasticity/CrystalPlasticityHCPDislocationSlipBeyerleinUpdate.html">CrystalPlasticityHCPDislocationSlipBeyerleinUpdate</a>Two-term dislocation slip model for hexagonal close packed crystals from Beyerline and Tome</li><li class="collection-item"><a href="source/materials/crystal_plasticity/CrystalPlasticityKalidindiUpdate.html">CrystalPlasticityKalidindiUpdate</a>Kalidindi version of homogeneous crystal plasticity.</li><li class="collection-item"><a href="source/materials/crystal_plasticity/CrystalPlasticityTwinningKalidindiUpdate.html">CrystalPlasticityTwinningKalidindiUpdate</a>Twinning propagation model based on Kalidindi&#x27;s treatment of twinning in a FCC material</li><li class="collection-item"><a href="source/materials/DensityScaling.html">DensityScaling</a></li><li class="collection-item"><a href="source/materials/EshelbyTensor.html">EshelbyTensor</a>Computes the Eshelby tensor as a function of strain energy density and the first Piola-Kirchhoff stress</li><li class="collection-item"><a href="source/materials/ExponentialSoftening.html">ExponentialSoftening</a>Softening model with an exponential softening response upon cracking. This class is intended to be used with ComputeSmearedCrackingStress.</li><li class="collection-item"><a href="source/materials/crystal_plasticity/FiniteStrainCPSlipRateRes.html">FiniteStrainCPSlipRateRes</a>Crystal Plasticity base class: FCC system with power law flow rule implemented</li><li class="collection-item"><a href="source/materials/crystal_plasticity/FiniteStrainCrystalPlasticity.html">FiniteStrainCrystalPlasticity</a>Crystal Plasticity base class: FCC system with power law flow rule implemented</li><li class="collection-item"><a href="source/materials/FiniteStrainHyperElasticViscoPlastic.html">FiniteStrainHyperElasticViscoPlastic</a>Material class for hyper-elastic viscoplatic flow: Can handle multiple flow models defined by flowratemodel type user objects</li><li class="collection-item"><a href="source/materials/FiniteStrainPlasticMaterial.html">FiniteStrainPlasticMaterial</a>Associative J2 plasticity with isotropic hardening.</li><li class="collection-item"><a href="source/materials/crystal_plasticity/FiniteStrainUObasedCP.html">FiniteStrainUObasedCP</a>UserObject based Crystal Plasticity system.</li><li class="collection-item"><a href="source/materials/FluxBasedStrainIncrement.html">FluxBasedStrainIncrement</a>Compute strain increment based on flux</li><li class="collection-item"><a href="source/materials/GBRelaxationStrainIncrement.html">GBRelaxationStrainIncrement</a>Compute strain increment based on lattice relaxation at GB</li><li class="collection-item"><a href="source/materials/GeneralizedKelvinVoigtModel.html">GeneralizedKelvinVoigtModel</a>Generalized Kelvin-Voigt model composed of a serial assembly of unit Kelvin-Voigt modules</li><li class="collection-item"><a href="source/materials/GeneralizedMaxwellModel.html">GeneralizedMaxwellModel</a>Generalized Maxwell model composed of a parallel assembly of unit Maxwell modules</li><li class="collection-item"><a href="source/materials/HillConstants.html">HillConstants</a>Build and rotate the Hill Tensor. It can be used with other Hill plasticity and creep materials.</li><li class="collection-item"><a href="source/materials/HillCreepStressUpdate.html">HillCreepStressUpdate</a>This class uses the stress update material in a generalized radial return anisotropic power law creep model.  This class can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/HillElastoPlasticityStressUpdate.html">HillElastoPlasticityStressUpdate</a>This class uses the generalized radial return for anisotropic elasto-plasticity model.This class can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/HillPlasticityStressUpdate.html">HillPlasticityStressUpdate</a>This class uses the generalized radial return for anisotropic plasticity model.This class can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/HyperElasticPhaseFieldIsoDamage.html">HyperElasticPhaseFieldIsoDamage</a>Computes damaged stress and energy in the intermediate configuration assuming isotropy</li><li class="collection-item"><a href="source/materials/HyperbolicViscoplasticityStressUpdate.html">HyperbolicViscoplasticityStressUpdate</a>This class uses the discrete material for a hyperbolic sine viscoplasticity model in which the effective plastic strain is solved for using a creep approach.</li><li class="collection-item"><a href="source/materials/InclusionProperties.html">InclusionProperties</a></li><li class="collection-item"><a href="source/materials/IsotropicPlasticityStressUpdate.html">IsotropicPlasticityStressUpdate</a>This class uses the discrete material in a radial return isotropic plasticity model.  This class is one of the basic radial return constitutive models, yet it can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/IsotropicPowerLawHardeningStressUpdate.html">IsotropicPowerLawHardeningStressUpdate</a>This class uses the discrete material in a radial return isotropic plasticity power law hardening model, solving for the yield stress as the intersection of the power law relation curve and Hooke&#x27;s law.  This class can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/LAROMANCEPartitionStressUpdateBase.html">LAROMANCEPartitionStressUpdate</a>LAROMANCE base class for partitioned reduced order models</li><li class="collection-item"><a href="source/materials/LAROMANCEStressUpdateBase.html">LAROMANCEStressUpdate</a>Base class to calculate the effective creep strain based on the rates predicted by a material  specific Los Alamos Reduced Order Model derived from a Visco-Plastic Self Consistent calculations.</li><li class="collection-item"><a href="source/materials/LinearElasticTruss.html">LinearElasticTruss</a>Computes the linear elastic strain for a truss element</li><li class="collection-item"><a href="source/materials/LinearViscoelasticStressUpdate.html">LinearViscoelasticStressUpdate</a>Calculates an admissible state (stress that lies on or within the yield surface, plastic strains, internal parameters, etc).  This class is intended to be a parent class for classes with specific constitutive models.</li><li class="collection-item"><a href="source/materials/MultiPhaseStressMaterial.html">MultiPhaseStressMaterial</a>Compute a global stress form multiple phase stresses</li><li class="collection-item"><a href="source/materials/NonlocalDamage.html">NonlocalDamage</a>Nonlocal damage model. Given an RadialAverage UO this creates a new damage index that can be used as for ComputeDamageStress without havign to change existing local damage models.</li><li class="collection-item"><a href="source/materials/PlasticTruss.html">PlasticTruss</a>Computes the stress and strain for a truss element with plastic behavior defined by either linear hardening or a user-defined hardening function.</li><li class="collection-item"><a href="source/materials/PorosityFromStrain.html">PorosityFromStrain</a>Porosity calculation from the inelastic strain.</li><li class="collection-item"><a href="source/materials/PowerLawCreepStressUpdate.html">PowerLawCreepStressUpdate</a>This class uses the stress update material in a radial return isotropic power law creep model. This class can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="source/materials/PowerLawSoftening.html">PowerLawSoftening</a>Softening model with an abrupt stress release upon cracking. This class is intended to be used with ComputeSmearedCrackingStress.</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/PureElasticTractionSeparation.html">PureElasticTractionSeparation</a>Pure elastic traction separation law.</li><li class="collection-item"><a href="source/materials/RankTwoCartesianComponent.html">RankTwoCartesianComponent</a>Access a component of a RankTwoTensor</li><li class="collection-item"><a href="source/materials/RankTwoCylindricalComponent.html">RankTwoCylindricalComponent</a>Compute components of a rank-2 tensor in a cylindrical coordinate system</li><li class="collection-item"><a href="source/materials/RankTwoDirectionalComponent.html">RankTwoDirectionalComponent</a>Compute a Direction scalar property of a RankTwoTensor</li><li class="collection-item"><a href="source/materials/RankTwoInvariant.html">RankTwoInvariant</a>Compute a invariant property of a RankTwoTensor</li><li class="collection-item"><a href="source/materials/RankTwoSphericalComponent.html">RankTwoSphericalComponent</a>Compute components of a rank-2 tensor in a spherical coordinate system</li><li class="collection-item"><a href="source/materials/cohesive_zone_model/SalehaniIrani3DCTraction.html">SalehaniIrani3DCTraction</a>3D Coupled (3DC) cohesive law of Salehani and Irani with no damage</li><li class="collection-item"><a href="source/materials/ScalarMaterialDamage.html">ScalarMaterialDamage</a>Scalar damage model for which the damage is prescribed by another material</li><li class="collection-item"><a href="source/materials/StrainEnergyDensity.html">StrainEnergyDensity</a>Computes the strain energy density using a combination of the elastic and inelastic components of the strain increment, which is a valid assumption for monotonic behavior.</li><li class="collection-item"><a href="source/materials/StrainEnergyRateDensity.html">StrainEnergyRateDensity</a>Computes the strain energy density rate using a combination of the elastic and inelastic components of the strain increment, which is a valid assumption for monotonic behavior.</li><li class="collection-item"><a href="source/materials/StressBasedChemicalPotential.html">StressBasedChemicalPotential</a>Chemical potential from stress</li><li class="collection-item"><a href="source/materials/SumTensorIncrements.html">SumTensorIncrements</a>Compute tensor property by summing tensor increments</li><li class="collection-item"><a href="source/materials/ComputeIsotropicElasticityTensor.html">SymmetricIsotropicElasticityTensor</a>Compute a constant isotropic elasticity tensor.</li><li class="collection-item"><a href="source/materials/TemperatureDependentHardeningStressUpdate.html">TemperatureDependentHardeningStressUpdate</a>Computes the stress as a function of temperature and plastic strain from user-supplied hardening functions. This class can be used in conjunction with other creep and plasticity materials for more complex simulations</li><li class="collection-item"><a href="source/materials/TensileStressUpdate.html">TensileStressUpdate</a>Associative, smoothed, tensile (Rankine) plasticity with hardening/softening</li><li class="collection-item"><a href="source/materials/ThermalFractureIntegral.html">ThermalFractureIntegral</a>Calculates summation of the derivative of the eigenstrains with respect to temperature.</li><li class="collection-item"><a href="source/materials/TwoPhaseStressMaterial.html">TwoPhaseStressMaterial</a>Compute a global stress in a two phase model</li><li class="collection-item"><a href="source/materials/VolumeDeformGradCorrectedStress.html">VolumeDeformGradCorrectedStress</a>Transforms stress with volumetric term from previous configuration to this configuration</li><li class="collection-header">Rdg App</li><li class="collection-item"><a href="source/materials/AEFVMaterial.html">AEFVMaterial</a>A material kernel for the advection equation using a cell-centered finite volume method.</li><li class="collection-header">Heat Conduction App</li><li class="collection-item"><a href="source/materials/AnisoHeatConductionMaterial.html">ADAnisoHeatConductionMaterial</a>General-purpose material model for anisotropic heat conduction</li><li class="collection-item"><a href="source/materials/ElectricalConductivity.html">ADElectricalConductivity</a>Calculates resistivity and electrical conductivity as a function of temperature, using copper for parameter defaults.</li><li class="collection-item"><a href="source/materials/HeatConductionMaterial.html">ADHeatConductionMaterial</a>General-purpose material model for heat conduction</li><li class="collection-item"><a href="source/materials/AnisoHeatConductionMaterial.html">AnisoHeatConductionMaterial</a>General-purpose material model for anisotropic heat conduction</li><li class="collection-item"><a href="source/materials/ElectricalConductivity.html">ElectricalConductivity</a>Calculates resistivity and electrical conductivity as a function of temperature, using copper for parameter defaults.</li><li class="collection-item"><a href="source/materials/FunctionPathEllipsoidHeatSource.html">FunctionPathEllipsoidHeatSource</a>Double ellipsoid volumetric source heat with function path.</li><li class="collection-item"><a href="source/materials/GapConductance.html">GapConductance</a></li><li class="collection-item"><a href="source/materials/GapConductanceConstant.html">GapConductanceConstant</a>Material to compute a constant, prescribed gap conductance</li><li class="collection-item"><a href="source/materials/HeatConductionMaterial.html">HeatConductionMaterial</a>General-purpose material model for heat conduction</li><li class="collection-item"><a href="source/materials/SemiconductorLinearConductivity.html">SemiconductorLinearConductivity</a>Calculates electrical conductivity of a semiconductor from temperature</li><li class="collection-item"><a href="source/materials/SideSetHeatTransferMaterial.html">SideSetHeatTransferMaterial</a>This material constructs the necessary coefficients and properties for SideSetHeatTransferKernel.</li><li class="collection-header">Fluid Properties App</li><li class="collection-item"><a href="source/materials/SaturationPressureMaterial.html">ADSaturationPressureMaterial</a>Computes saturation pressure at some temperature.</li><li class="collection-item"><a href="source/materials/ADSaturationTemperatureMaterial.html">ADSaturationTemperatureMaterial</a>Computes saturation temperature at some pressure</li><li class="collection-item"><a href="source/materials/ADSurfaceTensionMaterial.html">ADSurfaceTensionMaterial</a>Computes surface tension at some temperature</li><li class="collection-item"><a href="source/materials/FluidPropertiesMaterialVE.html">FluidPropertiesMaterial</a>Computes fluid properties using (specific internal energy, specific volume) formulation</li><li class="collection-item"><a href="source/materials/FluidPropertiesMaterialPT.html">FluidPropertiesMaterialPT</a>Fluid properties using the (pressure, temperature) formulation</li><li class="collection-item"><a href="source/materials/FluidPropertiesMaterialVE.html">FluidPropertiesMaterialVE</a>Computes fluid properties using (specific internal energy, specific volume) formulation</li><li class="collection-item"><a href="source/materials/SaturationPressureMaterial.html">SaturationPressureMaterial</a>Computes saturation pressure at some temperature.</li><li class="collection-item"><a href="source/materials/SodiumPropertiesMaterial.html">SodiumPropertiesMaterial</a>Material properties for liquid sodium sampled from SodiumProperties.</li><li class="collection-header">Eel App</li><li class="collection-item"><a href="source/materials/electrodynamics/BulkChargeTransport.html">BulkChargeTransport</a>This class computes the electrical energy density and its corresponding thermodynamic forces. We assume the electrical energy density depends on at least the deformation gradient and the gradient of electrical potential This class defines the electrical potential for charge transfer in the bulk</li><li class="collection-item"><a href="source/materials/forces/CauchyStress.html">CauchyStress</a>This class computes the Cauchy stress given the PK1 stress</li><li class="collection-item"><a href="source/materials/electrodynamics/ChargeTransferReaction.html">ChargeTransferReaction</a>The Butler-Volmer condition for current density across the electrode/electrolyte interface.</li><li class="collection-item"><a href="source/materials/chemistry/ChemicalPotential.html">ChemicalPotential</a>This class defines the mass flux.</li><li class="collection-item"><a href="source/materials/forces/CurrentDensity.html">CurrentDensity</a>This class computes the current density associated with given energy densities.</li><li class="collection-item"><a href="source/materials/kinematics/DeformationGradient.html">DeformationGradient</a>This class computes the deformation gradient. The F-bar approach can optionally be used to correct volumetric locking.</li><li class="collection-item"><a href="source/materials/chemistry/EntropicChemicalEnergyDensity.html">EntropicChemicalEnergyDensity</a>This class computes the chemical energy density and its corresponding thermodynamic forces. We assume the chemical energy density depends on the chemical concentration.</li><li class="collection-item"><a href="source/materials/forces/FirstPiolaKirchhoffStress.html">FirstPiolaKirchhoffStress</a>This class computes the first Piola-Kirchhoff stress associated with given energy densities.</li><li class="collection-item"><a href="source/materials/thermology/FourierPotential.html">FourierPotential</a>This class computes the thermal energy density and its corresponding thermodynamic forces. We assume the thermal energy density depends on the gradient of log temperature. This class defines the Fourier potential for heat conduction.</li><li class="collection-item"><a href="source/materials/forces/HeatFlux.html">HeatFlux</a>This class computes the heat flux associated with given energy densities for a given species.</li><li class="collection-item"><a href="source/materials/mechanics/InterfaceTractionWithCreepDegradation.html">InterfaceTractionWithCreepDegradation</a>Base class for implementing cohesive zone constituive material models that can be formulated using the total displacement jump</li><li class="collection-item"><a href="source/materials/electrodynamics/JouleHeating.html">JouleHeating</a>This class computes volumetric heat source due to Joule heating from electric displacement.</li><li class="collection-item"><a href="source/materials/chemistry/MassDiffusion.html">MassDiffusion</a>This class computes the dual chemical energy density and its corresponding thermodynamic forces. We assume the dual chemical energy density depends on the gradient of chemical potential.</li><li class="collection-item"><a href="source/materials/forces/MassFlux.html">MassFlux</a>This class computes the mass flux associated with given energy densities for a given species.</li><li class="collection-item"><a href="source/materials/forces/MassSource.html">MassSource</a>This class computes the mass source associated with given energy densities for a given species.</li><li class="collection-item"><a href="source/materials/kinematics/MechanicalDeformationGradient.html">MechanicalDeformationGradient</a>This class computes the deformation gradient. The F-bar approach can optionally be used to correct volumetric locking. Eigen deformation gradients are extracted from the total deformation gradient.</li><li class="collection-item"><a href="source/materials/kinematics/MechanicalStrain.html">MechanicalStrain</a>Compute mechanical strain by subtracting eigenstrains from the total strain</li><li class="collection-item"><a href="source/materials/electrochemistry/Migration.html">Migration</a>This class computes the electrochemical energy density and its corresponding thermodynamic forces. We assume the electrochemical energy density depends on the gradients of electrical potential and chemical potential This class defines the electrochemical potential for the migration mechanism</li><li class="collection-item"><a href="source/materials/mechanics/NeoHookeanSolid.html">NeoHookeanSolid</a>This class computes the elastic energy density and its corresponding thermodynamic forces. We assume the mechanical energy density depends on the mechanical deformation gradient. This class defines the Neo-Hookean elastic energy density.</li><li class="collection-item"><a href="source/materials/mechanics/SDElasticEnergyDensity.html">SDElasticEnergyDensity</a>This class defines the small deformation elastic energy density.</li><li class="collection-item"><a href="source/materials/forces/SDStress.html">SDStress</a>This class computes the small deformation Cauchy stress associated with given energy densities.</li><li class="collection-item"><a href="source/materials/chemistry/SEIGrowth.html">SEIGrowth</a>This object models the growth of solid electrolyte interphase (SEI).</li><li class="collection-item"><a href="source/materials/kinematics/Strain.html">Strain</a>This class computes the total strain. The F-bar approach can optionally be used to correct volumetric locking.</li><li class="collection-item"><a href="source/materials/kinematics/SwellingDeformationGradient.html">SwellingDeformationGradient</a>This class computes the eigen deformation gradient due to swelling.</li><li class="collection-item"><a href="source/materials/kinematics/SwellingStrain.html">SwellingStrain</a>This class computes the eigenstrain due to swelling.</li><li class="collection-item"><a href="source/materials/kinematics/ThermalDeformationGradient.html">ThermalDeformationGradient</a>This class computes the thermal deformation gradient.</li><li class="collection-item"><a href="source/materials/forces/VariationalHeatSource.html">VariationalHeatSource</a>This class computes the heat source associated with given energy densities for a given species.</li><li class="collection-item"><a href="source/materials/mechanics/WeldedInterfaceTraction.html">WeldedInterfaceTraction</a>Base class for implementing cohesive zone constituive material models that can be formulated using the total displacement jump</li></ul></section><section class="scrollspy" id="520cd38d-6dbd-43f9-a827-154644d60c06" data-section-level="2" data-section-text="Mesh"><h2 id="mesh"><a href="syntax/Mesh/index.html">Mesh</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/CreateDisplacedProblemAction.html">CreateDisplacedProblemAction</a>Create a Problem object that utilizes displacements.</li><li class="collection-item"><a href="source/actions/DisplayGhostingAction.html">DisplayGhostingAction</a>Action to setup AuxVariables and AuxKernels to display ghosting when running in parallel</li><li class="collection-item"><a href="source/actions/ElementIDOutputAction.html">ElementIDOutputAction</a>Action for copying extra element IDs into auxiliary variables for output.</li><li class="collection-item"><a href="source/actions/SetupMeshAction.html">SetupMeshAction</a>Add or create Mesh object to the simulation.</li><li class="collection-item"><a href="source/actions/SetupMeshCompleteAction.html">SetupMeshCompleteAction</a>Perform operations on the mesh in preparation for a simulation.</li><li class="collection-item"><a href="source/actions/AddMeshGeneratorAction.html">AddMeshGeneratorAction</a>Add a MeshGenerator object to the simulation.</li><li class="collection-item"><a href="source/meshgenerators/AddMetaDataGenerator.html">AddMetaDataGenerator</a>This mesh generator assigns extraneous mesh metadata to the input mesh</li><li class="collection-item"><a href="source/meshgenerators/AdvancedExtruderGenerator.html">AdvancedExtruderGenerator</a>Extrudes a 1D mesh into 2D, or a 2D mesh into 3D, can have a variable height for each elevation, variable number of layers within each elevation, variable growth factors of axial element sizes within each elevation and remap subdomain_ids, boundary_ids and element extra integers within each elevation as well as interface boundaries between neighboring elevation layers.</li><li class="collection-item"><a href="source/meshgenerators/AllSideSetsByNormalsGenerator.html">AllSideSetsByNormalsGenerator</a>Adds sidesets to the entire mesh based on unique normals.</li><li class="collection-item"><a href="source/meshgenerators/AnnularMeshGenerator.html">AnnularMeshGenerator</a>For rmin&gt;0: creates an annular mesh of QUAD4 elements. For rmin=0: creates a disc mesh of QUAD4 and TRI3 elements. Boundary sidesets are created at rmax and rmin, and given these names. If dmin!<u>0 and dmax!</u>360, a sector of an annulus or disc is created. In this case boundary sidesets are also created at dmin and dmax, and given these names</li><li class="collection-item"><a href="source/meshgenerators/BlockDeletionGenerator.html">BlockDeletionGenerator</a>Mesh generator which removes elements from the specified subdomains</li><li class="collection-item"><a href="source/meshgenerators/BlockToMeshConverterGenerator.html">BlockToMeshConverterGenerator</a>Converts one or more blocks (subdomains) from a mesh into a stand-alone mesh with a single block in it.</li><li class="collection-item"><a href="source/meshgenerators/BoundaryDeletionGenerator.html">BoundaryDeletionGenerator</a>Mesh generator which removes side sets</li><li class="collection-item"><a href="source/meshgenerators/BoundingBoxNodeSetGenerator.html">BoundingBoxNodeSetGenerator</a>Assigns all of the nodes either inside or outside of a bounding box to a new nodeset.</li><li class="collection-item"><a href="source/meshgenerators/BreakBoundaryOnSubdomainGenerator.html">BreakBoundaryOnSubdomainGenerator</a>Break boundaries based on the subdomains to which their sides are attached. Naming convention for the new boundaries will be the old boundary name plus &quot;_to_&quot; plus the subdomain name</li><li class="collection-item"><a href="source/meshgenerators/BreakMeshByBlockGenerator.html">BreakMeshByBlockGenerator</a>Break boundaries based on the subdomains to which their sides are attached. Naming convention for the new boundaries will be the old boundary name plus &quot;_to_&quot; plus the subdomain name. At the momentthis only works on REPLICATED mesh</li><li class="collection-item"><a href="source/meshgenerators/CartesianMeshGenerator.html">CartesianMeshGenerator</a>This CartesianMeshGenerator creates a non-uniform Cartesian mesh.</li><li class="collection-item"><a href="source/meshgenerators/CircularBoundaryCorrectionGenerator.html">CircularBoundaryCorrectionGenerator</a>This CircularBoundaryCorrectionGenerator object is designed to correct full or partial circular boundaries in a 2D mesh to preserve areas.</li><li class="collection-item"><a href="source/meshgenerators/CombinerGenerator.html">CombinerGenerator</a>Combine multiple meshes (or copies of one mesh) together into one (disjoint) mesh.  Can optionally translate those meshes before combining them.</li><li class="collection-item"><a href="source/meshgenerators/ConcentricCircleMeshGenerator.html">ConcentricCircleMeshGenerator</a>This ConcentricCircleMeshGenerator source code is to generate concentric circle meshes.</li><li class="collection-item"><a href="source/meshgenerators/DistributedRectilinearMeshGenerator.html">DistributedRectilinearMeshGenerator</a>Create a line, square, or cube mesh with uniformly spaced or biased elements.</li><li class="collection-item"><a href="source/meshgenerators/ElementGenerator.html">ElementGenerator</a>Generates individual elements given a list of nodal positions.</li><li class="collection-item"><a href="source/meshgenerators/ElementSubdomainIDGenerator.html">ElementSubdomainIDGenerator</a>Allows the user to assign each element the subdomain ID of their choice</li><li class="collection-item"><a href="source/meshgenerators/ExplodeMeshGenerator.html">ExplodeMeshGenerator</a>Break all element-element interfaces in the specified subdomains.</li><li class="collection-item"><a href="source/meshgenerators/ExtraNodesetGenerator.html">ExtraNodesetGenerator</a>Creates a new node set and a new boundary made with the nodes the user provides.</li><li class="collection-item"><a href="source/meshgenerators/AdvancedExtruderGenerator.html">FancyExtruderGenerator</a>Extrudes a 1D mesh into 2D, or a 2D mesh into 3D, can have a variable height for each elevation, variable number of layers within each elevation, variable growth factors of axial element sizes within each elevation and remap subdomain_ids, boundary_ids and element extra integers within each elevation as well as interface boundaries between neighboring elevation layers.</li><li class="collection-item"><a href="source/meshgenerators/FileMeshGenerator.html">FileMeshGenerator</a>Read a mesh from a file.</li><li class="collection-item"><a href="source/meshgenerators/FillBetweenCurvesGenerator.html">FillBetweenCurvesGenerator</a>This FillBetweenCurvesGenerator object is designed to generate a transition layer to connect two boundaries of two input meshes.</li><li class="collection-item"><a href="source/meshgenerators/FillBetweenPointVectorsGenerator.html">FillBetweenPointVectorsGenerator</a>This FillBetweenPointVectorsGenerator object is designed to generate a transition layer with two sides containing different numbers of nodes.</li><li class="collection-item"><a href="source/meshgenerators/FillBetweenSidesetsGenerator.html">FillBetweenSidesetsGenerator</a>This FillBetweenSidesetsGenerator object is designed to generate a transition layer to connect two boundaries of two input meshes.</li><li class="collection-item"><a href="source/meshgenerators/GeneratedMeshGenerator.html">GeneratedMeshGenerator</a>Create a line, square, or cube mesh with uniformly spaced or biased elements.</li><li class="collection-item"><a href="source/meshgenerators/ImageMeshGenerator.html">ImageMeshGenerator</a>Generated mesh with the aspect ratio of a given image stack.</li><li class="collection-item"><a href="source/meshgenerators/ImageSubdomainGenerator.html">ImageSubdomainGenerator</a>Samples an image at the coordinates of each element centroid, using the resulting pixel color value as each element&#x27;s subdomain ID</li><li class="collection-item"><a href="source/meshgenerators/LowerDBlockFromSidesetGenerator.html">LowerDBlockFromSidesetGenerator</a>Adds lower dimensional elements on the specified sidesets.</li><li class="collection-item"><a href="source/meshgenerators/MeshCollectionGenerator.html">MeshCollectionGenerator</a>Collects multiple meshes into a single (unconnected) mesh.</li><li class="collection-item"><a href="source/meshgenerators/MeshExtruderGenerator.html">MeshExtruderGenerator</a>Takes a 1D or 2D mesh and extrudes the entire structure along the specified axis increasing the dimensionality of the mesh.</li><li class="collection-item"><a href="source/meshgenerators/MoveNodeGenerator.html">MoveNodeGenerator</a>Modifies the position of one or more nodes</li><li class="collection-item"><a href="source/meshgenerators/NodeSetsFromSideSetsGenerator.html">NodeSetsFromSideSetsGenerator</a>Mesh generator which constructs node sets from side sets</li><li class="collection-item"><a href="source/meshgenerators/OrientedSubdomainBoundingBoxGenerator.html">OrientedSubdomainBoundingBoxGenerator</a>Defines a subdomain inside or outside of a bounding box with arbitrary orientation.</li><li class="collection-item"><a href="source/meshgenerators/ParsedCurveGenerator.html">ParsedCurveGenerator</a>This ParsedCurveGenerator object is designed to generate a mesh of a curve that consists of EDGE2 elements.</li><li class="collection-item"><a href="source/meshgenerators/ParsedGenerateSideset.html">ParsedGenerateSideset</a>A MeshGenerator that adds element sides to a sideset if the centroid satisfies the <code>combinatorial_geometry</code> expression. Optionally, element sides are also added if they are included in <code>included_subdomain_ids</code> and if they feature the designated normal.</li><li class="collection-item"><a href="source/meshgenerators/ParsedNodeTransformGenerator.html">ParsedNodeTransformGenerator</a>Applies a transform to a the x,y,z coordinates of a Mesh</li><li class="collection-item"><a href="source/meshgenerators/ParsedSubdomainMeshGenerator.html">ParsedSubdomainMeshGenerator</a>Uses a parsed expression (<code>combinatorial_geometry</code>) to determine if an element (via its centroid) is inside the region defined by the expression and assigns a new block ID.</li><li class="collection-item"><a href="source/meshgenerators/PatchMeshGenerator.html">PatchMeshGenerator</a>Creates 2D or 3D patch meshes.</li><li class="collection-item"><a href="source/meshgenerators/PatternedMeshGenerator.html">PatternedMeshGenerator</a>Creates a 2D mesh from a specified set of unique &#x27;tiles&#x27; meshes and a two-dimensional pattern.</li><li class="collection-item"><a href="source/meshgenerators/PlaneDeletionGenerator.html">PlaneDeletionGenerator</a>Removes elements lying &#x27;above&#x27; the plane (in the direction of the normal).</li><li class="collection-item"><a href="source/meshgenerators/PlaneIDMeshGenerator.html">PlaneIDMeshGenerator</a>Adds an extra element integer that identifies planes in a mesh.</li><li class="collection-item"><a href="source/meshgenerators/PolyLineMeshGenerator.html">PolyLineMeshGenerator</a>Generates meshes from edges connecting a list of points.</li><li class="collection-item"><a href="source/meshgenerators/RefineBlockGenerator.html">RefineBlockGenerator</a>Mesh generator which refines one or more blocks in an existing mesh</li><li class="collection-item"><a href="source/meshgenerators/RefineSidesetGenerator.html">RefineSidesetGenerator</a>Mesh generator which refines one or more sidesets</li><li class="collection-item"><a href="source/meshgenerators/RenameBlockGenerator.html">RenameBlockGenerator</a>Changes the block IDs and/or block names for a given set of blocks defined by either block ID or block name. The changes are independent of ordering. The merging of blocks is supported.</li><li class="collection-item"><a href="source/meshgenerators/RenameBoundaryGenerator.html">RenameBoundaryGenerator</a>Changes the boundary IDs and/or boundary names for a given set of boundaries defined by either boundary ID or boundary name. The changes are independent of ordering. The merging of boundaries is supported.</li><li class="collection-item"><a href="source/meshgenerators/RinglebMeshGenerator.html">RinglebMeshGenerator</a>Creates a mesh for the Ringleb problem.</li><li class="collection-item"><a href="source/meshgenerators/SideSetExtruderGenerator.html">SideSetExtruderGenerator</a>Takes a 1D or 2D mesh and extrudes a selected sideset along the specified axis.</li><li class="collection-item"><a href="source/meshgenerators/SideSetsAroundSubdomainGenerator.html">SideSetsAroundSubdomainGenerator</a>Adds element faces that are on the exterior of the given block to the sidesets specified</li><li class="collection-item"><a href="source/meshgenerators/SideSetsBetweenSubdomainsGenerator.html">SideSetsBetweenSubdomainsGenerator</a>MeshGenerator that creates a sideset composed of the nodes located between two or more subdomains.</li><li class="collection-item"><a href="source/meshgenerators/SideSetsFromBoundingBoxGenerator.html">SideSetsFromBoundingBoxGenerator</a>Defines new sidesets using currently-defined sideset IDs inside or outside of a bounding box.</li><li class="collection-item"><a href="source/meshgenerators/SideSetsFromNodeSetsGenerator.html">SideSetsFromNodeSetsGenerator</a>Mesh generator which constructs side sets from node sets</li><li class="collection-item"><a href="source/meshgenerators/SideSetsFromNormalsGenerator.html">SideSetsFromNormalsGenerator</a>Adds a new named sideset to the mesh for all faces matching the specified normal.</li><li class="collection-item"><a href="source/meshgenerators/SideSetsFromPointsGenerator.html">SideSetsFromPointsGenerator</a>Adds a new sideset starting at the specified point containing all connected element faces with the same normal.</li><li class="collection-item"><a href="source/meshgenerators/SmoothMeshGenerator.html">SmoothMeshGenerator</a>Utilizes a simple Laplacian based smoother to attempt to improve mesh quality.  Will not move boundary nodes or nodes along block/subdomain boundaries</li><li class="collection-item"><a href="source/meshgenerators/SphereMeshGenerator.html">SphereMeshGenerator</a>Generate a 3-D sphere mesh centered on the origin</li><li class="collection-item"><a href="source/meshgenerators/SpiralAnnularMeshGenerator.html">SpiralAnnularMeshGenerator</a>Creates an annular mesh based on TRI3 or TRI6 elements on several rings.</li><li class="collection-item"><a href="source/meshgenerators/StackGenerator.html">StackGenerator</a>Use the supplied meshes and stitch them on top of each other</li><li class="collection-item"><a href="source/meshgenerators/StitchedMeshGenerator.html">StitchedMeshGenerator</a>Allows multiple mesh files to be stitched together to form a single mesh.</li><li class="collection-item"><a href="source/meshgenerators/SubdomainBoundingBoxGenerator.html">SubdomainBoundingBoxGenerator</a>Changes the subdomain ID of elements either (XOR) inside or outside the specified box to the specified ID.</li><li class="collection-item"><a href="source/meshgenerators/SubdomainIDGenerator.html">SubdomainIDGenerator</a>Sets all the elements of the input mesh to a unique subdomain ID.</li><li class="collection-item"><a href="source/meshgenerators/SymmetryTransformGenerator.html">SymmetryTransformGenerator</a>Applies a symmetry transformation to the entire mesh.</li><li class="collection-item"><a href="source/meshgenerators/TiledMeshGenerator.html">TiledMeshGenerator</a>Use the supplied mesh and create a tiled grid by repeating this mesh in the x, y, and z directions.</li><li class="collection-item"><a href="source/meshgenerators/TransfiniteMeshGenerator.html">TransfiniteMeshGenerator</a>Creates a QUAD4 mesh given a set of corner vertices and edge types. The edge type can be either LINE, CIRCARC, DISCRETE or PARSED, with LINE as the default option. For the non-default options the user needs to specify additional parameters via the edge_parameter option as follows: for CIRCARC the deviation of the midpoint from an arccircle, for DISCRETE a set of points, or a paramterization via the PARSED option. Opposite edges may have different distributions s long as the number of points is identical. Along opposite edges a different point distribution can be prescribed via the options bias_x or bias_y for opposing edges.</li><li class="collection-item"><a href="source/meshgenerators/TransformGenerator.html">TransformGenerator</a>Applies a linear transform to the entire mesh.</li><li class="collection-item"><a href="source/meshgenerators/UniqueExtraIDMeshGenerator.html">UniqueExtraIDMeshGenerator</a>Add a new extra element integer ID by finding unique combinations of the existing extra element integer ID values</li><li class="collection-item"><a href="source/meshgenerators/XYDelaunayGenerator.html">XYDelaunayGenerator</a>Triangulates meshes within boundaries defined by input meshes.</li><li class="collection-item"><a href="source/meshgenerators/XYMeshLineCutter.html">XYMeshLineCutter</a>This XYMeshLineCutter object is designed to trim the input mesh by removing all the elements on one side of a given straight line with special processing on the elements crossed by the cutting line to ensure a smooth cross-section.</li><li class="collection-item"><a href="source/mesh/AnnularMesh.html">AnnularMesh</a>For rmin&gt;0: creates an annular mesh of QUAD4 elements.  For rmin=0: creates a disc mesh of QUAD4 and TRI3 elements.  Boundary sidesets are created at rmax and rmin, and given these names.  If dmin!<u>0 and dmax!</u>360, a sector of an annulus or disc is created.  In this case boundary sidesets are also created a dmin and dmax, and given these names</li><li class="collection-item"><a href="source/mesh/ConcentricCircleMesh.html">ConcentricCircleMesh</a>This ConcentricCircleMesh source code is to generate concentric circle meshes.</li><li class="collection-item"><a href="source/mesh/FileMesh.html">FileMesh</a>Read a mesh from a file.</li><li class="collection-item"><a href="source/mesh/GeneratedMesh.html">GeneratedMesh</a>Create a line, square, or cube mesh with uniformly spaced or biased elements.</li><li class="collection-item"><a href="source/mesh/ImageMesh.html">ImageMesh</a>Generated mesh with the aspect ratio of a given image stack.</li><li class="collection-item"><a href="source/mesh/MeshGeneratorMesh.html">MeshGeneratorMesh</a>Mesh generated using mesh generators</li><li class="collection-item"><a href="source/mesh/PatternedMesh.html">PatternedMesh</a>Creates a 2D mesh from a specified set of unique &#x27;tiles&#x27; meshes and a two-dimensional pattern.</li><li class="collection-item"><a href="source/mesh/RinglebMesh.html">RinglebMesh</a>Creates a mesh for the Ringleb problem.</li><li class="collection-item"><a href="source/mesh/SpiralAnnularMesh.html">SpiralAnnularMesh</a>Creates an annual mesh based on TRI3 elements (it can also be TRI6 elements) on several rings.</li><li class="collection-item"><a href="source/mesh/StitchedMesh.html">StitchedMesh</a>Reads in all of the given meshes and stitches them all together into one mesh.</li><li class="collection-item"><a href="source/mesh/TiledMesh.html">TiledMesh</a>Use the supplied mesh and create a tiled grid by repeating this mesh in the x,y, and z directions.</li><li class="collection-item"><a href="syntax/Mesh/Partitioner/index.html">Partitioner</a></li><li class="collection-header">Heat Conduction App</li><li class="collection-item"><a href="source/meshgenerators/PatchSidesetGenerator.html">PatchSidesetGenerator</a>Divides the given sideset into smaller patches of roughly equal size.</li></ul><section id="c1348c4b-7037-4303-9642-42a1ae980d69" data-section-level="3" data-section-text="Mesh/Partitioner"><h3 id="mesh/partitioner"><a href="syntax/Mesh/Partitioner/index.html">Mesh/Partitioner</a></h3><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/PartitionerAction.html">PartitionerAction</a>Add a Partitioner object to the simulation.</li><li class="collection-item"><a href="source/partitioner/BlockWeightedPartitioner.html">BlockWeightedPartitioner</a>Partition mesh by weighting blocks</li><li class="collection-item"><a href="source/partitioner/GridPartitioner.html">GridPartitioner</a>Create a uniform grid that overlays the mesh to be partitioned.  Assign all elements within each cell of the grid to the same processor.</li><li class="collection-item"><a href="source/partitioner/HierarchicalGridPartitioner.html">HierarchicalGridPartitioner</a>Partitions a mesh into sub-partitions for each computational node then into partitions within that node.  All partitions are made using a regular grid.</li><li class="collection-item"><a href="source/partitioner/LibmeshPartitioner.html">LibmeshPartitioner</a>Mesh partitioning using capabilities defined in libMesh.</li><li class="collection-item"><a href="source/partitioner/PetscExternalPartitioner.html">PetscExternalPartitioner</a>Partition mesh using external packages via PETSc MatPartitioning interface</li><li class="collection-item"><a href="source/partitioner/RandomPartitioner.html">RandomPartitioner</a>Assigns element processor ids randomly with a given seed.</li><li class="collection-item"><a href="source/partitioner/SingleRankPartitioner.html">SingleRankPartitioner</a>Assigns element processor ids to a single MPI rank.</li></ul></section></section><section class="scrollspy" id="65e03989-dbd0-4934-9a08-0fbf95a48fdc" data-section-level="2" data-section-text="Modules"><h2 id="modules"><a href="syntax/Modules/index.html">Modules</a></h2><section id="1b698aec-d168-4ffd-be2e-23027922e685" data-section-level="3" data-section-text="Modules/CompressibleNavierStokes"><h3 id="modules/compressiblenavierstokes"><a href="syntax/Modules/CompressibleNavierStokes/index.html">Modules/CompressibleNavierStokes</a></h3><ul class="moose-syntax-list collection with-header"><li class="collection-header">Navier Stokes App</li><li class="collection-item"><a href="source/actions/CNSAction.html">CNSAction</a>This class allows us to have a section of the input file like the following which automatically adds Kernels and AuxKernels for all the required nonlinear and auxiliary variables.</li></ul></section><section id="44e6af5e-c42c-4c5d-9e83-4549b7892359" data-section-level="3" data-section-text="Modules/FluidProperties"><h3 id="modules/fluidproperties"><a href="syntax/Modules/FluidProperties/index.html">Modules/FluidProperties</a></h3><ul class="moose-syntax-list collection with-header"><li class="collection-header">Fluid Properties App</li><li class="collection-item"><a href="source/actions/AddFluidPropertiesDeprecatedAction.html">AddFluidPropertiesDeprecatedAction</a>Add a UserObject object to the simulation.</li><li class="collection-item"><a href="source/fluidproperties/BrineFluidProperties.html">BrineFluidProperties</a>Fluid properties for brine</li><li class="collection-item"><a href="source/fluidproperties/CO2FluidProperties.html">CO2FluidProperties</a>Fluid properties for carbon dioxide (CO2) using the Span &amp; Wagner EOS</li><li class="collection-item"><a href="source/fluidproperties/CaloricallyImperfectGas.html">CaloricallyImperfectGas</a>Fluid properties for an ideal gas with imperfect caloric behavior.</li><li class="collection-item"><a href="source/fluidproperties/FlibeFluidProperties.html">FlibeFluidProperties</a>Fluid properties for flibe</li><li class="collection-item"><a href="source/fluidproperties/FlinakFluidProperties.html">FlinakFluidProperties</a>Fluid properties for flinak</li><li class="collection-item"><a href="source/fluidproperties/HeliumFluidProperties.html">HeliumFluidProperties</a>Fluid properties for helium</li><li class="collection-item"><a href="source/fluidproperties/HydrogenFluidProperties.html">HydrogenFluidProperties</a>Fluid properties for Hydrogen (H2)</li><li class="collection-item"><a href="source/fluidproperties/IdealGasFluidProperties.html">IdealGasFluidProperties</a>Fluid properties for an ideal gas</li><li class="collection-item"><a href="source/fluidproperties/IdealRealGasMixtureFluidProperties.html">IdealRealGasMixtureFluidProperties</a>Class for fluid properties of an arbitrary vapor mixture</li><li class="collection-item"><a href="source/fluidproperties/LeadBismuthFluidProperties.html">LeadBismuthFluidProperties</a>Fluid properties for Lead Bismuth eutectic 2LiF-BeF2</li><li class="collection-item"><a href="source/fluidproperties/LeadFluidProperties.html">LeadFluidProperties</a>Fluid properties for Lead</li><li class="collection-item"><a href="source/fluidproperties/MethaneFluidProperties.html">MethaneFluidProperties</a>Fluid properties for methane (CH4)</li><li class="collection-item"><a href="source/fluidproperties/NaClFluidProperties.html">NaClFluidProperties</a>Fluid properties for NaCl</li><li class="collection-item"><a href="source/fluidproperties/NaKFluidProperties.html">NaKFluidProperties</a>Fluid properties for NaK</li><li class="collection-item"><a href="source/fluidproperties/NitrogenFluidProperties.html">NitrogenFluidProperties</a>Fluid properties for Nitrogen (N2)</li><li class="collection-item"><a href="source/fluidproperties/SimpleFluidProperties.html">SimpleFluidProperties</a>Fluid properties for a simple fluid with a constant bulk density</li><li class="collection-item"><a href="source/fluidproperties/SodiumProperties.html">SodiumProperties</a>Fluid properties for sodium</li><li class="collection-item"><a href="source/fluidproperties/SodiumSaturationFluidProperties.html">SodiumSaturationFluidProperties</a>Fluid properties for liquid sodium at saturation conditions</li><li class="collection-item"><a href="source/fluidproperties/StiffenedGasFluidProperties.html">StiffenedGasFluidProperties</a>Fluid properties for a stiffened gas</li><li class="collection-item"><a href="source/fluidproperties/StiffenedGasTwoPhaseFluidProperties.html">StiffenedGasTwoPhaseFluidProperties</a>Two-phase stiffened gas fluid properties</li><li class="collection-item"><a href="source/fluidproperties/TabulatedBicubicFluidProperties.html">TabulatedBicubicFluidProperties</a>Fluid properties using bicubic interpolation on tabulated values provided</li><li class="collection-item"><a href="source/fluidproperties/TabulatedBicubicFluidProperties.html">TabulatedFluidProperties</a>Fluid properties using bicubic interpolation on tabulated values provided</li><li class="collection-item"><a href="source/fluidproperties/TemperaturePressureFunctionFluidProperties.html">TemperaturePressureFunctionFluidProperties</a>Single-phase fluid properties that allows to provide thermal conductivity, density, and viscosity as functions of temperature and pressure.</li><li class="collection-item"><a href="source/fluidproperties/TwoPhaseFluidPropertiesIndependent.html">TwoPhaseFluidPropertiesIndependent</a>2-phase fluid properties for 2 independent single-phase fluid properties</li><li class="collection-item"><a href="source/fluidproperties/Water97FluidProperties.html">Water97FluidProperties</a>Fluid properties for water and steam (H2O) using IAPWS-IF97</li></ul></section><section id="6b0fd8c6-dea1-4bbe-b563-ae179b2fa2cf" data-section-level="3" data-section-text="Modules/HeatConduction"><h3 id="modules/heatconduction"><a href="syntax/Modules/HeatConduction/index.html">Modules/HeatConduction</a></h3><section id="037f12f4-2c9d-457a-b930-7d730a8040e4" data-section-level="4" data-section-text="Modules/HeatConduction/ThermalContact"><h4 id="modules/heatconduction/thermalcontact"><a href="syntax/Modules/HeatConduction/ThermalContact/index.html">Modules/HeatConduction/ThermalContact</a></h4><section id="a33d4277-98bd-433b-8b6f-fe404513f31d" data-section-level="5" data-section-text="Modules/HeatConduction/ThermalContact/BC"><h5 id="modules/heatconduction/thermalcontact/bc"><a href="syntax/Modules/HeatConduction/ThermalContact/BC/index.html">Modules/HeatConduction/ThermalContact/BC</a></h5><ul class="moose-syntax-list collection with-header"><li class="collection-header">Heat Conduction App</li><li class="collection-item"><a href="source/actions/ThermalContactAction.html">ThermalContactAction</a>Action that controls the creation of all of the necessary objects for calculation of Thermal Contact</li></ul></section></section><section id="95d1d85e-3045-47e6-a792-d50d6709822b" data-section-level="3" data-section-text="Modules/IncompressibleNavierStokes"><h3 id="modules/incompressiblenavierstokes"><a href="syntax/Modules/IncompressibleNavierStokes/index.html">Modules/IncompressibleNavierStokes</a></h3><ul class="moose-syntax-list collection with-header"><li class="collection-header">Navier Stokes App</li><li class="collection-item"><a href="source/actions/INSAction.html">INSAction</a>This class allows us to have a section of the input file for setting up incompressible Navier-Stokes equations.</li></ul></section><section id="bc7371ce-d2a1-425c-91e1-2f9ddd9008da" data-section-level="3" data-section-text="Modules/NavierStokesFV"><h3 id="modules/navierstokesfv"><a href="syntax/Modules/NavierStokesFV/index.html">Modules/NavierStokesFV</a></h3><ul class="moose-syntax-list collection with-header"><li class="collection-header">Navier Stokes App</li><li class="collection-item"><a href="source/actions/NSFVAction.html">NSFVAction</a>This class allows us to set up Navier-Stokes equations for porous medium or clean fluid flows using incompressible or weakly compressible approximations with a finite volume discretization.</li></ul></section><section id="d28658a8-3a44-4aae-9d0c-9936105eb17b" data-section-level="3" data-section-text="Modules/TensorMechanics"><h3 id="modules/tensormechanics"><a href="syntax/Modules/TensorMechanics/index.html">Modules/TensorMechanics</a></h3><section id="30225fc1-f29e-4432-a630-b47e4229e098" data-section-level="4" data-section-text="Modules/TensorMechanics/CohesiveZoneMaster"><h4 id="modules/tensormechanics/cohesivezonemaster"><a href="syntax/Modules/TensorMechanics/CohesiveZoneMaster/index.html">Modules/TensorMechanics/CohesiveZoneMaster</a></h4><ul class="moose-syntax-list collection with-header"><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/actions/CommonCohesiveZoneAction.html">CommonCohesiveZoneAction</a>Store common cohesive zone paramters</li><li class="collection-item"><a href="source/actions/CohesiveZoneAction.html">CohesiveZoneAction</a>Action to create an instance of the cohesive zone model kernel for each displacement component</li></ul></section><section id="dc9d6410-f8d1-4d7c-a927-d643ecbf3113" data-section-level="4" data-section-text="Modules/TensorMechanics/DynamicMaster"><h4 id="modules/tensormechanics/dynamicmaster"><a href="syntax/Modules/TensorMechanics/DynamicMaster/index.html">Modules/TensorMechanics/DynamicMaster</a></h4><ul class="moose-syntax-list collection with-header"><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/actions/CommonTensorMechanicsAction.html">CommonTensorMechanicsAction</a>Store common tensor mechanics parameters</li><li class="collection-item"><a href="source/actions/DynamicTensorMechanicsAction.html">DynamicTensorMechanicsAction</a>Set up dynamic stress divergence kernels</li></ul></section><section id="950b5b27-a141-4af0-8014-fe0113327aa1" data-section-level="4" data-section-text="Modules/TensorMechanics/GeneralizedPlaneStrain"><h4 id="modules/tensormechanics/generalizedplanestrain"><a href="syntax/Modules/TensorMechanics/GeneralizedPlaneStrain/index.html">Modules/TensorMechanics/GeneralizedPlaneStrain</a></h4><ul class="moose-syntax-list collection with-header"><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/actions/GeneralizedPlaneStrainAction.html">GeneralizedPlaneStrainAction</a>Set up the GeneralizedPlaneStrain environment</li></ul></section><section id="87e0bb84-8c9a-4ee2-8783-12e81f001fc3" data-section-level="4" data-section-text="Modules/TensorMechanics/GlobalStrain"><h4 id="modules/tensormechanics/globalstrain"><a href="syntax/Modules/TensorMechanics/GlobalStrain/index.html">Modules/TensorMechanics/GlobalStrain</a></h4><ul class="moose-syntax-list collection with-header"><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/actions/GlobalStrainAction.html">GlobalStrainAction</a>Set up the GlobalStrainAction environment</li></ul></section><section id="765940a0-c1b4-419f-87c9-c924fb33c0b4" data-section-level="4" data-section-text="Modules/TensorMechanics/LineElementMaster"><h4 id="modules/tensormechanics/lineelementmaster"><a href="syntax/Modules/TensorMechanics/LineElementMaster/index.html">Modules/TensorMechanics/LineElementMaster</a></h4><ul class="moose-syntax-list collection with-header"><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/actions/CommonLineElementAction.html">CommonLineElementAction</a>Sets up variables, stress divergence kernels and materials required for a static analysis with beam or truss elements. Also sets up aux variables, aux kernels, and consistent or nodal inertia kernels for dynamic analysis with beam elements.</li><li class="collection-item"><a href="source/actions/LineElementAction.html">LineElementAction</a>Sets up variables, stress divergence kernels and materials required for a static analysis with beam or truss elements. Also sets up aux variables, aux kernels, and consistent or nodal inertia kernels for dynamic analysis with beam elements.</li></ul></section><section id="0dbfeb48-ca0e-4885-aa05-29ba1fd7b2e4" data-section-level="4" data-section-text="Modules/TensorMechanics/Master"><h4 id="modules/tensormechanics/master"><a href="syntax/Modules/TensorMechanics/Master/index.html">Modules/TensorMechanics/Master</a></h4><ul class="moose-syntax-list collection with-header"><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/actions/CommonTensorMechanicsAction.html">CommonTensorMechanicsAction</a>Store common tensor mechanics parameters</li><li class="collection-item"><a href="source/actions/TensorMechanicsAction.html">TensorMechanicsAction</a>Set up stress divergence kernels with coordinate system aware logic</li></ul></section><section id="b4ba8eed-2f94-4b37-a4b1-0076e1e97993" data-section-level="4" data-section-text="Modules/TensorMechanics/MaterialVectorBodyForce"><h4 id="modules/tensormechanics/materialvectorbodyforce"><a href="syntax/Modules/TensorMechanics/MaterialVectorBodyForce/index.html">Modules/TensorMechanics/MaterialVectorBodyForce</a></h4><ul class="moose-syntax-list collection with-header"><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/actions/MaterialVectorBodyForceAction.html">MaterialVectorBodyForceAction</a>Set up volumetric body force kernels</li></ul></section></section><section class="scrollspy" id="05317cab-7a5f-46d9-8e7e-e8d235a2cdfb" data-section-level="2" data-section-text="MortarGapHeatTransfer"><h2 id="mortargapheattransfer"><a href="syntax/MortarGapHeatTransfer/index.html">MortarGapHeatTransfer</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Heat Conduction App</li><li class="collection-item"><a href="source/actions/MortarGapHeatTransferAction.html">MortarGapHeatTransferAction</a>Action that controls the creation of all of the necessary objects for calculation of heat transfer through an open/closed gap using a mortar formulation and a modular design approach</li></ul></section><section class="scrollspy" id="2f9d2807-df83-47c0-9049-61aa6eb20139" data-section-level="2" data-section-text="MultiApps"><h2 id="multiapps"><a href="syntax/MultiApps/index.html">MultiApps</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddMultiAppAction.html">AddMultiAppAction</a>Add a MultiApp object to the simulation.</li><li class="collection-item"><a href="source/multiapps/CentroidMultiApp.html">CentroidMultiApp</a>Automatically generates Sub-App positions from centroids of elements in the parent app  mesh.</li><li class="collection-item"><a href="source/multiapps/FullSolveMultiApp.html">FullSolveMultiApp</a>Performs a complete simulation during each execution.</li><li class="collection-item"><a href="source/multiapps/QuadraturePointMultiApp.html">QuadraturePointMultiApp</a>Automatically generates sub-App positions from the elemental quadrature points, with the default quadrature, in the parent mesh.</li><li class="collection-item"><a href="source/multiapps/TransientMultiApp.html">TransientMultiApp</a>MultiApp for performing coupled simulations with the parent and sub-application both progressing in time.</li></ul></section><section class="scrollspy" id="e9df0f13-3c39-4b67-bf74-e7e4ca27a0c0" data-section-level="2" data-section-text="NodalKernels"><h2 id="nodalkernels"><a href="syntax/NodalKernels/index.html">NodalKernels</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddNodalKernelAction.html">AddNodalKernelAction</a>Add a NodalKernel object to the simulation.</li><li class="collection-item"><a href="source/nodalkernels/ConstantRate.html">ConstantRate</a>Computes residual or the rate in a simple ODE of du/dt = rate.</li><li class="collection-item"><a href="source/nodalkernels/CoupledForceNodalKernel.html">CoupledForceNodalKernel</a>Adds a force proportional to the value of the coupled variable</li><li class="collection-item"><a href="source/nodalkernels/LowerBoundNodalKernel.html">LowerBoundNodalKernel</a>Used to prevent a coupled variable from going below a lower bound</li><li class="collection-item"><a href="source/nodalkernels/PenaltyDirichletNodalKernel.html">PenaltyDirichletNodalKernel</a>Enforces a Dirichlet boundary condition in a weak sense by penalizing differences between the current solution and the Dirichlet value on nodesets.</li><li class="collection-item"><a href="source/nodalkernels/ReactionNodalKernel.html">ReactionNodalKernel</a>Implements a simple consuming reaction term at nodes</li><li class="collection-item"><a href="source/nodalkernels/TimeDerivativeNodalKernel.html">TimeDerivativeNodalKernel</a>Forms the contribution to the residual and jacobian of the time derivative term from an ODE being solved at all nodes.</li><li class="collection-item"><a href="source/nodalkernels/UpperBoundNodalKernel.html">UpperBoundNodalKernel</a>Used to prevent a coupled variable from going above a upper bound</li><li class="collection-item"><a href="source/nodalkernels/UserForcingFunctionNodalKernel.html">UserForcingFunctionNodalKernel</a>Residual contribution to an ODE from a source function acting at nodes.</li><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/nodalkernels/NodalGravity.html">NodalGravity</a>Computes the gravitational force for a given nodal mass.</li><li class="collection-item"><a href="source/nodalkernels/NodalRotationalInertia.html">NodalRotationalInertia</a>Calculates the inertial torques and inertia proportional damping corresponding to the nodal rotational inertia.</li><li class="collection-item"><a href="source/nodalkernels/NodalTranslationalInertia.html">NodalTranslationalInertia</a>Computes the inertial forces and mass proportional damping terms corresponding to nodal mass.</li></ul></section><section class="scrollspy" id="e1a5b14e-27ad-42ee-a2e8-abbc02d8b089" data-section-level="2" data-section-text="NodalNormals"><h2 id="nodalnormals"><a href="syntax/NodalNormals/index.html">NodalNormals</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddNodalNormalsAction.html">AddNodalNormalsAction</a>Creates Auxiliary variables and objects for computing the outward facing normal from a node.</li></ul></section><section class="scrollspy" id="fa8a2361-0b91-4f22-8a5a-cd7cd9fa3659" data-section-level="2" data-section-text="Outputs"><h2 id="outputs"><a href="syntax/Outputs/index.html">Outputs</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/CommonOutputAction.html">CommonOutputAction</a>Adds short-cut syntax and common parameters to the Outputs block.</li><li class="collection-item"><a href="source/actions/AddOutputAction.html">AddOutputAction</a>Action responsible for creating Output objects.</li><li class="collection-item"><a href="source/outputs/CSV.html">CSV</a>Output for postprocessors, vector postprocessors, and scalar variables using comma seperated values (CSV).</li><li class="collection-item"><a href="source/outputs/Checkpoint.html">Checkpoint</a>Output for MOOSE recovery checkpoint files.</li><li class="collection-item"><a href="source/outputs/Console.html">Console</a>Object for screen output.</li><li class="collection-item"><a href="source/outputs/ControlOutput.html">ControlOutput</a>Output for displaying objects and parameters associated with the Control system.</li><li class="collection-item"><a href="source/outputs/DOFMapOutput.html">DOFMap</a>Output degree-of-freedom (DOF) map.</li><li class="collection-item"><a href="source/outputs/Exodus.html">Exodus</a>Object for output data in the Exodus II format</li><li class="collection-item"><a href="source/outputs/GMVOutput.html">GMV</a>Object for outputting data in the GMV format</li><li class="collection-item"><a href="source/outputs/Gnuplot.html">Gnuplot</a>Output for postprocessors and scalar variables in GNU plot format.</li><li class="collection-item"><a href="source/outputs/JSONOutput.html">JSON</a>Output for Reporter values using JSON format.</li><li class="collection-item"><a href="source/outputs/MaterialPropertyDebugOutput.html">MaterialPropertyDebugOutput</a>Debug output object for displaying material property information.</li><li class="collection-item"><a href="source/outputs/Nemesis.html">Nemesis</a>Object for output data in the Nemesis (parallel ExodusII) format.</li><li class="collection-item"><a href="source/outputs/PerfGraphOutput.html">PerfGraphOutput</a>Controls output of the PerfGraph: the performance log for MOOSE</li><li class="collection-item"><a href="source/outputs/ReporterDebugOutput.html">ReporterDebugOutput</a>Debug output object for displaying Reporter information.</li><li class="collection-item"><a href="source/outputs/SolutionHistory.html">SolutionHistory</a>Outputs the non-linear and linear iteration solve history.</li><li class="collection-item"><a href="source/outputs/Tecplot.html">Tecplot</a>Object for outputting data in the Tecplot format</li><li class="collection-item"><a href="source/outputs/TopResidualDebugOutput.html">TopResidualDebugOutput</a>Debug output object for displaying the top contributing residuals.</li><li class="collection-item"><a href="source/outputs/VTKOutput.html">VTK</a>Output data using the Visualization Toolkit (VTK).</li><li class="collection-item"><a href="source/outputs/VariableResidualNormsDebugOutput.html">VariableResidualNormsDebugOutput</a>Reports the residual norm for each variable.</li><li class="collection-item"><a href="source/outputs/XDA.html">XDA</a>Object for outputting data in the XDA/XDR format.</li><li class="collection-item"><a href="source/outputs/XDA.html">XDR</a>Object for outputting data in the XDA/XDR format.</li><li class="collection-item"><a href="source/outputs/XMLOutput.html">XMLOutput</a>Output for VectorPostprocessor using XML format.</li><li class="collection-header">Ray Tracing App</li><li class="collection-item"><a href="source/outputs/RayTracingExodus.html">RayTracingExodus</a>Outputs ray segments and data as segments using the Exodus format.</li><li class="collection-item"><a href="source/outputs/RayTracingNemesis.html">RayTracingNemesis</a>Outputs ray segments and data as segments using the Nemesis format.</li></ul></section><section class="scrollspy" id="2eeaed53-8cf8-4fc7-8015-5dbf94ccc01c" data-section-level="2" data-section-text="Positions"><h2 id="positions"><a href="syntax/Positions/index.html">Positions</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddPositionsAction.html">AddPositionsAction</a>Add a Positions object to the simulation.</li><li class="collection-item"><a href="source/positions/ElementCentroidPositions.html">ElementCentroidPositions</a>Positions of element centroids.</li><li class="collection-item"><a href="source/positions/ElementGroupCentroidPositions.html">ElementGroupCentroidPositions</a>Gets the Positions of the centroid of groups of elements. Groups may be defined using subdomains or element extra ids.</li><li class="collection-item"><a href="source/positions/FilePositions.html">FilePositions</a>Import positions from one or more files.</li><li class="collection-item"><a href="source/positions/InputPositions.html">InputPositions</a>Positions set directly from a user parameter in the input file</li><li class="collection-item"><a href="source/positions/MultiAppPositions.html">MultiAppPositions</a>Obtain positions from MultiApps. This may only be used to set the positions of those same multiapps if an &#x27;initial_positions&#x27; parameter is used.</li><li class="collection-item"><a href="source/positions/ReporterPositions.html">ReporterPositions</a>Import positions from one or more reporters, for example other Positions</li></ul></section><section class="scrollspy" id="18d0fefe-1b33-43f1-b143-ed62cbce47f9" data-section-level="2" data-section-text="Postprocessors"><h2 id="postprocessors"><a href="syntax/Postprocessors/index.html">Postprocessors</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddPostprocessorAction.html">AddPostprocessorAction</a>Add a Postprocessor object to the simulation.</li><li class="collection-item"><a href="source/postprocessors/ElementAverageMaterialProperty.html">ADElementAverageMaterialProperty</a>Computes the average of a material property over a volume.</li><li class="collection-item"><a href="source/postprocessors/ElementExtremeFunctorValue.html">ADElementExtremeFunctorValue</a>Finds either the min or max elemental value of a variable over the domain.</li><li class="collection-item"><a href="source/postprocessors/ElementExtremeMaterialProperty.html">ADElementExtremeMaterialProperty</a>Determines the minimum or maximum of a material property over a volume.</li><li class="collection-item"><a href="source/postprocessors/ElementIntegralFunctorPostprocessor.html">ADElementIntegralFunctorPostprocessor</a>Computes a volume integral of the specified functor</li><li class="collection-item"><a href="source/postprocessors/ElementIntegralMaterialProperty.html">ADElementIntegralMaterialProperty</a>Compute the integral of the material property over the domain</li><li class="collection-item"><a href="source/postprocessors/ElementL2FunctorError.html">ADElementL2FunctorError</a>Computes L2 error between an &#x27;approximate&#x27; functor and an &#x27;exact&#x27; functor</li><li class="collection-item"><a href="source/postprocessors/InterfaceDiffusiveFluxAverage.html">ADInterfaceDiffusiveFluxAverage</a>Computes the diffusive flux on the interface.</li><li class="collection-item"><a href="source/postprocessors/InterfaceDiffusiveFluxIntegral.html">ADInterfaceDiffusiveFluxIntegral</a>Computes the diffusive flux on the interface.</li><li class="collection-item"><a href="source/postprocessors/SideAverageMaterialProperty.html">ADSideAverageMaterialProperty</a>Computes the average of a material property over a side set.</li><li class="collection-item"><a href="source/postprocessors/SideDiffusiveFluxAverage.html">ADSideDiffusiveFluxAverage</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="source/postprocessors/SideDiffusiveFluxIntegral.html">ADSideDiffusiveFluxIntegral</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="source/postprocessors/SideDiffusiveFluxAverage.html">ADSideFluxAverage</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="source/postprocessors/SideDiffusiveFluxIntegral.html">ADSideFluxIntegral</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="source/postprocessors/SideIntegralFunctorPostprocessor.html">ADSideIntegralFunctorPostprocessor</a>Computes a surface integral of the specified functor, using the single-sided face argument, which usually means that the functor will be evaluated from a single side of the surface, not interpolated between both sides.</li><li class="collection-item"><a href="source/postprocessors/SideIntegralMaterialProperty.html">ADSideIntegralMaterialProperty</a>Compute the integral of a scalar material property component over the domain.</li><li class="collection-item"><a href="source/postprocessors/SideDiffusiveFluxIntegral.html">ADSideVectorDiffusivityFluxIntegral</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="source/postprocessors/AreaPostprocessor.html">AreaPostprocessor</a>Computes the &quot;area&quot; or dimension - 1 &quot;volume&quot; of a given boundary or boundaries in your mesh.</li><li class="collection-item"><a href="source/postprocessors/AverageElementSize.html">AverageElementSize</a>Computes the average element size.</li><li class="collection-item"><a href="source/postprocessors/AverageNodalVariableValue.html">AverageNodalVariableValue</a>Computes the average value of a field by sampling all nodal solutions on the domain or within a subdomain</li><li class="collection-item"><a href="source/postprocessors/AxisymmetricCenterlineAverageValue.html">AxisymmetricCenterlineAverageValue</a>Computes the average value of a variable on a sideset located along the centerline of an axisymmetric model.</li><li class="collection-item"><a href="source/postprocessors/ChangeOverFixedPointPostprocessor.html">ChangeOverFixedPointPostprocessor</a>Computes the change or relative change in a post-processor value over a single or multiple fixed point iterations</li><li class="collection-item"><a href="source/postprocessors/ChangeOverTimePostprocessor.html">ChangeOverTimePostprocessor</a>Computes the change or relative change in a post-processor value over a timestep or the entire transient</li><li class="collection-item"><a href="source/postprocessors/ChangeOverTimestepPostprocessor.html">ChangeOverTimestepPostprocessor</a>Computes the change or relative change in a post-processor value over a timestep or the entire transient</li><li class="collection-item"><a href="source/postprocessors/ConstantPostprocessor.html">ConstantPostprocessor</a>Postprocessor that holds a constant value</li><li class="collection-item"><a href="source/postprocessors/CumulativeValuePostprocessor.html">CumulativeValuePostprocessor</a>Creates a cumulative sum of a Postprocessor value with time.</li><li class="collection-item"><a href="source/postprocessors/DifferencePostprocessor.html">DifferencePostprocessor</a>Computes the difference between two postprocessors</li><li class="collection-item"><a href="source/postprocessors/ElementArrayL2Norm.html">ElementArrayL2Norm</a>Evaluates L2-norm of a component of an array variable</li><li class="collection-item"><a href="source/postprocessors/ElementAverageMaterialProperty.html">ElementAverageMaterialProperty</a>Computes the average of a material property over a volume.</li><li class="collection-item"><a href="source/postprocessors/ElementAverageSecondTimeDerivative.html">ElementAverageSecondTimeDerivative</a>Computes the element averaged second derivative of variable</li><li class="collection-item"><a href="source/postprocessors/ElementAverageTimeDerivative.html">ElementAverageTimeDerivative</a>Computes a volume integral of the time derivative of a given variable</li><li class="collection-item"><a href="source/postprocessors/ElementAverageValue.html">ElementAverageValue</a>Computes the volumetric average of a variable</li><li class="collection-item"><a href="source/postprocessors/ElementExtremeFunctorValue.html">ElementExtremeFunctorValue</a>Finds either the min or max elemental value of a variable over the domain.</li><li class="collection-item"><a href="source/postprocessors/ElementExtremeMaterialProperty.html">ElementExtremeMaterialProperty</a>Determines the minimum or maximum of a material property over a volume.</li><li class="collection-item"><a href="source/postprocessors/ElementExtremeValue.html">ElementExtremeValue</a>Finds either the min or max elemental value of a variable over the domain.</li><li class="collection-item"><a href="source/postprocessors/ElementH1Error.html">ElementH1Error</a>Computes the H1 error between a variable and a function</li><li class="collection-item"><a href="source/postprocessors/ElementH1SemiError.html">ElementH1SemiError</a>Returns the gradient difference norm part of the H1 error</li><li class="collection-item"><a href="source/postprocessors/ElementIntegralArrayVariablePostprocessor.html">ElementIntegralArrayVariablePostprocessor</a>Integral of one component of an array variable.</li><li class="collection-item"><a href="source/postprocessors/ElementIntegralFunctorPostprocessor.html">ElementIntegralFunctorPostprocessor</a>Computes a volume integral of the specified functor</li><li class="collection-item"><a href="source/postprocessors/ElementIntegralMaterialProperty.html">ElementIntegralMaterialProperty</a>Compute the integral of the material property over the domain</li><li class="collection-item"><a href="source/postprocessors/ElementIntegralVariablePostprocessor.html">ElementIntegralVariablePostprocessor</a>Computes a volume integral of the specified variable</li><li class="collection-item"><a href="source/postprocessors/ElementL1Error.html">ElementL1Error</a>Computes L1 error between an elemental field variable and an analytical function.</li><li class="collection-item"><a href="source/postprocessors/ElementL2Difference.html">ElementL2Difference</a>Computes the element-wise L2 difference between the current variable and a coupled variable.</li><li class="collection-item"><a href="source/postprocessors/ElementL2Error.html">ElementL2Error</a>Computes L2 error between a field variable and an analytical function</li><li class="collection-item"><a href="source/postprocessors/ElementL2FunctorError.html">ElementL2FunctorError</a>Computes L2 error between an &#x27;approximate&#x27; functor and an &#x27;exact&#x27; functor</li><li class="collection-item"><a href="source/postprocessors/ElementL2Norm.html">ElementL2Norm</a>Computes a volume integral of the specified variable</li><li class="collection-item"><a href="source/postprocessors/ElementSidesL2Norm.html">ElementSidesL2Norm</a>Computes the L2 norm of a variable over element sides.</li><li class="collection-item"><a href="source/postprocessors/ElementVectorL2Error.html">ElementVectorL2Error</a>Computes the Vector L2 difference of up to three variables simultaneously (normally x, y, z)</li><li class="collection-item"><a href="source/postprocessors/ElementW1pError.html">ElementW1pError</a>Computes the W1p norm of the difference between a variable and an analytic solution, as a function</li><li class="collection-item"><a href="source/postprocessors/ElementalVariableValue.html">ElementalVariableValue</a>Outputs an elemental variable value at a particular location</li><li class="collection-item"><a href="source/postprocessors/EmptyPostprocessor.html">EmptyPostprocessor</a>A postprocessor object that returns a value of zero.</li><li class="collection-item"><a href="source/postprocessors/FindValueOnLine.html">FindValueOnLine</a>Find a specific target value along a sampling line. The variable values along the line should change monotonically. The target value is searched using a bisection algorithm.</li><li class="collection-item"><a href="source/postprocessors/FunctionElementAverage.html">FunctionElementAverage</a>Computes the average of a function over a volume.</li><li class="collection-item"><a href="source/postprocessors/FunctionElementIntegral.html">FunctionElementIntegral</a>Integrates a function over elements</li><li class="collection-item"><a href="source/postprocessors/FunctionSideAverage.html">FunctionSideAverage</a>Computes the average of a function over a boundary.</li><li class="collection-item"><a href="source/postprocessors/FunctionSideIntegral.html">FunctionSideIntegral</a>Computes the integral of a function over a boundary.</li><li class="collection-item"><a href="source/postprocessors/FunctionValuePostprocessor.html">FunctionValuePostprocessor</a>Computes the value of a supplied function at a single point (scalable)</li><li class="collection-item"><a href="source/postprocessors/GreaterThanLessThanPostprocessor.html">GreaterThanLessThanPostprocessor</a>Count number of DOFs of a non-linear variable that are greater than or less than a given threshold</li><li class="collection-item"><a href="source/postprocessors/InterfaceAverageVariableValuePostprocessor.html">InterfaceAverageVariableValuePostprocessor</a>Computes the average value of a variable on an interface. Note that this cannot be used on the centerline of an axisymmetric model.</li><li class="collection-item"><a href="source/postprocessors/InterfaceDiffusiveFluxAverage.html">InterfaceDiffusiveFluxAverage</a>Computes the diffusive flux on the interface.</li><li class="collection-item"><a href="source/postprocessors/InterfaceDiffusiveFluxIntegral.html">InterfaceDiffusiveFluxIntegral</a>Computes the diffusive flux on the interface.</li><li class="collection-item"><a href="source/postprocessors/InterfaceIntegralVariableValuePostprocessor.html">InterfaceIntegralVariableValuePostprocessor</a>Add access to variables and their gradient on an interface.</li><li class="collection-item"><a href="source/postprocessors/InternalSideIntegralVariablePostprocessor.html">InternalSideIntegralVariablePostprocessor</a>Computes an integral on internal sides of the specified variable</li><li class="collection-item"><a href="source/postprocessors/LinearCombinationPostprocessor.html">LinearCombinationPostprocessor</a>Computes a linear combination between an arbitrary number of post-processors</li><li class="collection-item"><a href="source/postprocessors/MemoryUsage.html">MemoryUsage</a>Memory usage statistics for the running simulation.</li><li class="collection-item"><a href="source/postprocessors/NearestNodeNumber.html">NearestNodeNumber</a>Outputs the nearest node number to a point</li><li class="collection-item"><a href="source/postprocessors/NodalExtremeValue.html">NodalExtremeValue</a>Finds either the min or max elemental value of a variable over the domain.</li><li class="collection-item"><a href="source/postprocessors/NodalL2Error.html">NodalL2Error</a>The L2-norm of the difference between a variable and a function computed at nodes.</li><li class="collection-item"><a href="source/postprocessors/NodalL2Norm.html">NodalL2Norm</a>Computes the nodal L2-norm of the coupled variable, which is defined by summing the square of its value at every node and taking the square root.</li><li class="collection-item"><a href="source/postprocessors/NodalMaxValue.html">NodalMaxValue</a>Computes the maximum (over all the nodal values) of a variable.</li><li class="collection-item"><a href="source/postprocessors/NodalMaxValueId.html">NodalMaxValueId</a>Finds the node id with the maximum nodal value across all postprocessors.</li><li class="collection-item"><a href="source/postprocessors/NodalMaxValueId.html">NodalProxyMaxValue</a>Finds the node id with the maximum nodal value across all postprocessors.</li><li class="collection-item"><a href="source/postprocessors/NodalSum.html">NodalSum</a>Computes the sum of all of the nodal values of the specified variable. Note: This object sets the default &quot;unique_node_execute&quot; flag to true to avoid double counting nodes between shared blocks.</li><li class="collection-item"><a href="source/postprocessors/NodalVariableValue.html">NodalVariableValue</a>Outputs values of a nodal variable at a particular location</li><li class="collection-item"><a href="source/postprocessors/NumDOFs.html">NumDOFs</a>Return the number of Degrees of freedom from either the NL, Aux or both systems.</li><li class="collection-item"><a href="source/postprocessors/NumElems.html">NumElems</a>Return the number of active or total elements in the simulation.</li><li class="collection-item"><a href="source/postprocessors/NumFailedTimeSteps.html">NumFailedTimeSteps</a>Collects the number of failed time steps from the time stepper.</li><li class="collection-item"><a href="source/postprocessors/NumFixedPointIterations.html">NumFixedPointIterations</a>Returns the number of fixed point iterations taken by the executioner.</li><li class="collection-item"><a href="source/postprocessors/NumLinearIterations.html">NumLinearIterations</a>Compute the number of linear iterations.</li><li class="collection-item"><a href="source/postprocessors/NumNodes.html">NumNodes</a>Returns the total number of nodes in a simulation (works with DistributedMesh)</li><li class="collection-item"><a href="source/postprocessors/NumNonlinearIterations.html">NumNonlinearIterations</a>Outputs the number of nonlinear iterations</li><li class="collection-item"><a href="source/postprocessors/NumFixedPointIterations.html">NumPicardIterations</a>Returns the number of fixed point iterations taken by the executioner.</li><li class="collection-item"><a href="source/postprocessors/NumPositions.html">NumPositions</a>Return the number of Positions from a Positions object.</li><li class="collection-item"><a href="source/postprocessors/NumRelationshipManagers.html">NumRelationshipManagers</a>Return the number of relationship managers active.</li><li class="collection-item"><a href="source/postprocessors/NumResidualEvaluations.html">NumResidualEvaluations</a>Returns the total number of residual evaluations performed.</li><li class="collection-item"><a href="source/postprocessors/NumVars.html">NumVars</a>Return the number of variables from either the NL, Aux, or both systems.</li><li class="collection-item"><a href="source/postprocessors/ParsedPostprocessor.html">ParsedPostprocessor</a>Computes a parsed expression with post-processors</li><li class="collection-item"><a href="source/postprocessors/PercentChangePostprocessor.html">PercentChangePostprocessor</a>Computes the percent change of a postprocessor value compared to the value at the previous timestep.</li><li class="collection-item"><a href="source/postprocessors/PerfGraphData.html">PerfGraphData</a>Retrieves performance information about a section from the PerfGraph.</li><li class="collection-item"><a href="source/postprocessors/PointValue.html">PointValue</a>Compute the value of a variable at a specified location</li><li class="collection-item"><a href="source/postprocessors/PostprocessorComparison.html">PostprocessorComparison</a>Compares two post-processors and produces a boolean value</li><li class="collection-item"><a href="source/postprocessors/Receiver.html">Receiver</a>Reports the value stored in this processor, which is usually filled in by another object. The Receiver does not compute its own value.</li><li class="collection-item"><a href="source/postprocessors/RelativeDifferencePostprocessor.html">RelativeDifferencePostprocessor</a>Computes the absolute value of the relative difference between 2 post-processor values.</li><li class="collection-item"><a href="source/postprocessors/RelativeSolutionDifferenceNorm.html">RelativeSolutionDifferenceNorm</a>Computes the relative norm of the solution difference of two consecutive time steps.</li><li class="collection-item"><a href="source/postprocessors/Residual.html">Residual</a>Report the non-linear residual.</li><li class="collection-item"><a href="source/postprocessors/ScalarL2Error.html">ScalarL2Error</a>Compute L2 error of a scalar variable using analytic function.</li><li class="collection-item"><a href="source/postprocessors/ScalarVariable.html">ScalarVariable</a>Returns the value of a scalar variable as a postprocessor value.</li><li class="collection-item"><a href="source/postprocessors/ScalePostprocessor.html">ScalePostprocessor</a>Scales a post-processor by a value</li><li class="collection-item"><a href="source/postprocessors/SideAverageMaterialProperty.html">SideAverageMaterialProperty</a>Computes the average of a material property over a side set.</li><li class="collection-item"><a href="source/postprocessors/SideAverageValue.html">SideAverageValue</a>Computes the average value of a variable on a sideset. Note that this cannot be used on the centerline of an axisymmetric model.</li><li class="collection-item"><a href="source/postprocessors/SideDiffusiveFluxAverage.html">SideDiffusiveFluxAverage</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="source/postprocessors/SideDiffusiveFluxIntegral.html">SideDiffusiveFluxIntegral</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="source/postprocessors/SideExtremeValue.html">SideExtremeValue</a>Finds either the min or max variable value of a variable over a boundary.</li><li class="collection-item"><a href="source/postprocessors/SideDiffusiveFluxAverage.html">SideFluxAverage</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="source/postprocessors/SideDiffusiveFluxIntegral.html">SideFluxIntegral</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="source/postprocessors/SideIntegralFunctorPostprocessor.html">SideIntegralFunctorPostprocessor</a>Computes a surface integral of the specified functor, using the single-sided face argument, which usually means that the functor will be evaluated from a single side of the surface, not interpolated between both sides.</li><li class="collection-item"><a href="source/postprocessors/SideIntegralMaterialProperty.html">SideIntegralMaterialProperty</a>Compute the integral of a scalar material property component over the domain.</li><li class="collection-item"><a href="source/postprocessors/SideIntegralVariablePostprocessor.html">SideIntegralVariablePostprocessor</a>Computes a surface integral of the specified variable</li><li class="collection-item"><a href="source/postprocessors/SideDiffusiveFluxIntegral.html">SideVectorDiffusivityFluxIntegral</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="source/postprocessors/TimeExtremeValue.html">TimeExtremeValue</a>A postprocessor for reporting the extreme value of another postprocessor over time.</li><li class="collection-item"><a href="source/postprocessors/TimeIntegratedPostprocessor.html">TimeIntegratedPostprocessor</a>Integrate a Postprocessor value over time using trapezoidal rule.</li><li class="collection-item"><a href="source/postprocessors/TimePostprocessor.html">TimePostprocessor</a>Reports the current time</li><li class="collection-item"><a href="source/postprocessors/TimestepSize.html">TimestepSize</a>Reports the timestep size</li><li class="collection-item"><a href="source/postprocessors/TimeIntegratedPostprocessor.html">TotalVariableValue</a>Integrate a Postprocessor value over time using trapezoidal rule.</li><li class="collection-item"><a href="source/postprocessors/VariableInnerProduct.html">VariableInnerProduct</a>Computes a volume integral of the specified variable</li><li class="collection-item"><a href="source/postprocessors/VariableResidual.html">VariableResidual</a>Computes the L2 norm of the residual of a single variable in the solution vector.</li><li class="collection-item"><a href="source/postprocessors/VectorPostprocessorComparison.html">VectorPostprocessorComparison</a>Compares two vector post-processors of equal size and produces a boolean value</li><li class="collection-item"><a href="source/postprocessors/VectorPostprocessorComponent.html">VectorPostprocessorComponent</a>Returns the value of the specified component of a VectorPostprocessor</li><li class="collection-item"><a href="source/postprocessors/VectorPostprocessorReductionValue.html">VectorPostprocessorReductionValue</a>Takes a VectorPostprocessor and performs a reduction operation on it (max, min, sum, average) and stores as postprocessor.</li><li class="collection-item"><a href="source/postprocessors/VolumePostprocessor.html">VolumePostprocessor</a>Computes the volume of a specified block</li><li class="collection-header">Navier Stokes App</li><li class="collection-item"><a href="source/postprocessors/CFLTimeStepSize.html">ADCFLTimeStepSize</a>Computes a time step size based on a user-specified CFL number</li><li class="collection-item"><a href="source/postprocessors/CFLTimeStepSize.html">CFLTimeStepSize</a>Computes a time step size based on a user-specified CFL number</li><li class="collection-item"><a href="source/postprocessors/INSElementIntegralEnergyAdvection.html">INSADElementIntegralEnergyAdvection</a>Computes the net volumetric balance of energy transported by advection</li><li class="collection-item"><a href="source/postprocessors/INSElementIntegralEnergyAdvection.html">INSElementIntegralEnergyAdvection</a>Computes the net volumetric balance of energy transported by advection</li><li class="collection-item"><a href="source/postprocessors/INSExplicitTimestepSelector.html">INSExplicitTimestepSelector</a>Postprocessor that computes the minimum value of h_min/|u|, where |u| is coupled in as an aux variable.</li><li class="collection-item"><a href="source/postprocessors/MassFluxWeightedFlowRate.html">MassFluxWeightedFlowRate</a>Computes the mass flux weighted average of the quantity provided by advected_quantity over a boundary.</li><li class="collection-item"><a href="source/postprocessors/MfrPostprocessor.html">MfrPostprocessor</a>Object for outputting boundary mass fluxes in conjunction with FVFluxBC derived objects that support it</li><li class="collection-item"><a href="source/postprocessors/NSEntropyError.html">NSEntropyError</a>Computes entropy error.</li><li class="collection-item"><a href="source/postprocessors/PressureDrop.html">PressureDrop</a>Computes the pressure drop between an upstream and a downstream boundary.</li><li class="collection-item"><a href="source/postprocessors/RayleighNumber.html">RayleighNumber</a>Postprocessor that computes the Rayleigh number for free flow with natural circulation</li><li class="collection-item"><a href="source/postprocessors/VolumetricFlowRate.html">VolumetricFlowRate</a>Computes the volumetric flow rate of an advected quantity through a sideset.</li><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/postprocessors/Mass.html">ADMass</a>Computes a volume integral of the specified variable</li><li class="collection-item"><a href="source/postprocessors/MaterialTensorAverage.html">ADMaterialTensorAverage</a>Computes the average of a RankTwoTensor component over a volume.</li><li class="collection-item"><a href="source/postprocessors/MaterialTensorIntegral.html">ADMaterialTensorIntegral</a>This postprocessor computes an element integral of a component of a material tensor as specified by the user-supplied indices</li><li class="collection-item"><a href="source/postprocessors/SidesetReaction.html">ADSidesetReaction</a>Computes the integrated reaction force in a user-specified direction on a sideset from the surface traction</li><li class="collection-item"><a href="source/postprocessors/AsymptoticExpansionHomogenizationElasticConstants.html">AsymptoticExpansionHomogenizationElasticConstants</a>Postprocessor for asymptotic expansion homogenization for elasticity</li><li class="collection-item"><a href="source/postprocessors/CavityPressurePostprocessor.html">CavityPressurePostprocessor</a>Interfaces with the CavityPressureUserObject to store the initial number of moles of a gas contained within an internal volume.</li><li class="collection-item"><a href="source/postprocessors/CrackFrontData.html">CrackFrontData</a>Determines which nodes are along the crack front</li><li class="collection-item"><a href="source/postprocessors/CriticalTimeStep.html">CriticalTimeStep</a>Computes and reports the critical time step for the explicit solver.</li><li class="collection-item"><a href="source/postprocessors/Mass.html">Mass</a>Computes a volume integral of the specified variable</li><li class="collection-item"><a href="source/postprocessors/MaterialTensorAverage.html">MaterialTensorAverage</a>Computes the average of a RankTwoTensor component over a volume.</li><li class="collection-item"><a href="source/postprocessors/MaterialTensorIntegral.html">MaterialTensorIntegral</a>This postprocessor computes an element integral of a component of a material tensor as specified by the user-supplied indices</li><li class="collection-item"><a href="source/postprocessors/MaterialTimeStepPostprocessor.html">MaterialTimeStepPostprocessor</a>This postprocessor estimates a timestep that reduces the increment change in a material property below a given threshold.</li><li class="collection-item"><a href="source/postprocessors/NormalBoundaryDisplacement.html">NormalBoundaryDisplacement</a>This postprocessor computes the normal displacement on a given set of boundaries.</li><li class="collection-item"><a href="source/postprocessors/PolarMomentOfInertia.html">PolarMomentOfInertia</a>Compute the polar moment of inertia of a sideset w.r.t. a point and a direction</li><li class="collection-item"><a href="source/postprocessors/SidesetReaction.html">SidesetReaction</a>Computes the integrated reaction force in a user-specified direction on a sideset from the surface traction</li><li class="collection-item"><a href="source/postprocessors/TorqueReaction.html">TorqueReaction</a>TorqueReaction calculates the torque in 2D and 3Dabout a user-specified axis of rotation centeredat a user-specified origin.</li><li class="collection-header">Rdg App</li><li class="collection-item"><a href="source/postprocessors/BoundaryFluxPostprocessor.html">BoundaryFluxPostprocessor</a>Computes the side integral of a flux entry from a BoundaryFluxBase user object</li><li class="collection-header">Ray Tracing App</li><li class="collection-item"><a href="source/postprocessors/RayDataValue.html">RayDataValue</a>Obtains a value from the data or aux data of a Ray after tracing has been completed.</li><li class="collection-item"><a href="source/postprocessors/RayIntegralValue.html">RayIntegralValue</a>Obtains the integrated value accumulated into a Ray from an IntegralRayKernel-derived class.</li><li class="collection-item"><a href="source/postprocessors/RayTracingStudyResult.html">RayTracingStudyResult</a>Gets a result from a RayTracingStudy.</li><li class="collection-header">Heat Conduction App</li><li class="collection-item"><a href="source/postprocessors/ConvectiveHeatTransferSideIntegral.html">ADConvectiveHeatTransferSideIntegral</a>Computes the total convective heat transfer across a boundary.</li><li class="collection-item"><a href="source/postprocessors/ConvectiveHeatTransferSideIntegral.html">ConvectiveHeatTransferSideIntegral</a>Computes the total convective heat transfer across a boundary.</li><li class="collection-item"><a href="source/postprocessors/ExposedSideAverageValue.html">ExposedSideAverageValue</a>Computes the average value of a variable on the exposed portion of a sideset. Note that this cannot be used on the centerline of an axisymmetric model.</li><li class="collection-item"><a href="source/postprocessors/GrayLambertSurfaceRadiationPP.html">GrayLambertSurfaceRadiationPP</a>This postprocessor allows to extract radiosity, heat flux density, and temperature from the GrayLambertSurfaceRadiationBase object.</li><li class="collection-item"><a href="source/postprocessors/HomogenizedThermalConductivity.html">HomogenizedThermalConductivity</a>Postprocessor for asymptotic expansion homogenization for thermal conductivity</li><li class="collection-item"><a href="source/postprocessors/ThermalConductivity.html">ThermalConductivity</a>Computes the average value of a variable on a sideset. Note that this cannot be used on the centerline of an axisymmetric model.</li><li class="collection-item"><a href="source/postprocessors/ViewFactorPP.html">ViewFactorPP</a>This postprocessor allows to extract view factors from ViewFactor userobjects.</li></ul></section><section class="scrollspy" id="2ecd1045-1def-4431-9bb3-29246665f267" data-section-level="2" data-section-text="Preconditioning"><h2 id="preconditioning"><a href="syntax/Preconditioning/index.html">Preconditioning</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/SetupPreconditionerAction.html">SetupPreconditionerAction</a>Add a Preconditioner object to the simulation.</li><li class="collection-item"><a href="source/actions/AddFieldSplitAction.html">AddFieldSplitAction</a>Add a Split object to the simulation.</li><li class="collection-item"><a href="source/splits/Split.html">Split</a>Field split based preconditioner for nonlinear solver.</li><li class="collection-item"><a href="source/preconditioners/FiniteDifferencePreconditioner.html">FDP</a>Finite difference preconditioner (FDP) builds a numerical Jacobian for preconditioning, only use for testing and verification.</li><li class="collection-item"><a href="source/preconditioners/FieldSplitPreconditioner.html">FSP</a>Preconditioner designed to map onto PETSc&#x27;s PCFieldSplit.</li><li class="collection-item"><a href="source/preconditioners/PhysicsBasedPreconditioner.html">PBP</a>Physics-based preconditioner (PBP) allows individual physics to have their own preconditioner.</li><li class="collection-item"><a href="source/preconditioners/SingleMatrixPreconditioner.html">SMP</a>Single matrix preconditioner (SMP) builds a preconditioner using user defined off-diagonal parts of the Jacobian.</li><li class="collection-item"><a href="source/preconditioners/VariableCondensationPreconditioner.html">VCP</a>Varialble condensation preconditioner (VCP) condenses out specified variable(s) from the Jacobian matrix and produces a system of equations with less unkowns to be solved by the underlying preconditioners.</li></ul></section><section class="scrollspy" id="42b1ae75-0055-4431-ad31-85e493744465" data-section-level="2" data-section-text="Problem"><h2 id="problem"><a href="syntax/Problem/index.html">Problem</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/CreateProblemAction.html">CreateProblemAction</a>Add a Problem object to the simulation.</li><li class="collection-item"><a href="source/actions/DynamicObjectRegistrationAction.html">DynamicObjectRegistrationAction</a>Register MooseObjects from other applications dynamically.</li><li class="collection-item"><a href="source/problems/DisplacedProblem.html">DisplacedProblem</a>A Problem object for providing access to the displaced finite element mesh and associated variables.</li><li class="collection-item"><a href="source/problems/DumpObjectsProblem.html">DumpObjectsProblem</a>Single purpose problem object that does not run the given input but allows deconstructing actions into their series of underlying Moose objects and variables.</li><li class="collection-item"><a href="source/problems/EigenProblem.html">EigenProblem</a>Problem object for solving an eigenvalue problem.</li><li class="collection-item"><a href="source/problems/FEProblem.html">FEProblem</a>A normal (default) Problem object that contains a single NonlinearSystem and a single AuxiliarySystem object.</li><li class="collection-item"><a href="source/problems/ReferenceResidualProblem.html">ReferenceResidualProblem</a>Problem that checks for convergence relative to a user-supplied reference quantity rather than the initial residual</li></ul></section><section class="scrollspy" id="df2aed87-1654-4d19-8a3f-ad574c1f44c7" data-section-level="2" data-section-text="RayBCs"><h2 id="raybcs"><a href="syntax/RayBCs/index.html">RayBCs</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Ray Tracing App</li><li class="collection-item"><a href="source/actions/AddRayBCAction.html">AddRayBCAction</a>Adds a RayBC for use in ray tracing to the simulation.</li><li class="collection-item"><a href="source/raybcs/KillRayBC.html">KillRayBC</a>A RayBC that kills a Ray on a boundary.</li><li class="collection-item"><a href="source/raybcs/NullRayBC.html">NullRayBC</a>A RayBC that does nothing to a Ray on a boundary.</li><li class="collection-item"><a href="source/raybcs/ReflectRayBC.html">ReflectRayBC</a>A RayBC that reflects a Ray in a specular manner on a boundary.</li><li class="collection-header">Heat Conduction App</li><li class="collection-item"><a href="source/raybcs/ViewFactorRayBC.html">ViewFactorRayBC</a>This ray boundary condition is applied on all sidesets bounding a radiation cavity except symmetry sidesets. It kills rays that hit the sideset and scores the ray for computation of view factors.</li></ul></section><section class="scrollspy" id="c708e091-0a62-45c4-a8f3-6a13ab2eeb00" data-section-level="2" data-section-text="RayKernels"><h2 id="raykernels"><a href="syntax/RayKernels/index.html">RayKernels</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Ray Tracing App</li><li class="collection-item"><a href="source/actions/AddRayKernelAction.html">AddRayKernelAction</a>Adds a RayKernel for use in ray tracing to the simulation.</li><li class="collection-item"><a href="source/raykernels/LineSourceRayKernel.html">ADLineSourceRayKernel</a>Demonstrates the multiple ways that scalar values can be introduced into RayKernels, e.g. (controllable) constants, functions, postprocessors, and data on rays. Implements the weak form <span class="moose-katex-inline-equation" id="moose-equation-302fb32a-2fb6-4279-9f3c-3f32b2a98efa"><script>var element = document.getElementById("moose-equation-302fb32a-2fb6-4279-9f3c-3f32b2a98efa");katex.render("(\\psi_i, -f)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> along a line.</li><li class="collection-item"><a href="source/raykernels/FunctionIntegralRayKernel.html">FunctionIntegralRayKernel</a>Integrates a function along a Ray.</li><li class="collection-item"><a href="source/raykernels/KillRayKernel.html">KillRayKernel</a>A RayKernel that kills a Ray.</li><li class="collection-item"><a href="source/raykernels/LineSourceRayKernel.html">LineSourceRayKernel</a>Demonstrates the multiple ways that scalar values can be introduced into RayKernels, e.g. (controllable) constants, functions, postprocessors, and data on rays. Implements the weak form <span class="moose-katex-inline-equation" id="moose-equation-d843a931-1702-4456-b117-a7d21a2b40ab"><script>var element = document.getElementById("moose-equation-d843a931-1702-4456-b117-a7d21a2b40ab");katex.render("(\\psi_i, -f)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> along a line.</li><li class="collection-item"><a href="source/raykernels/MaterialIntegralRayKernel.html">MaterialIntegralRayKernel</a>Integrates a Material property along a Ray.</li><li class="collection-item"><a href="source/raykernels/NullRayKernel.html">NullRayKernel</a>A RayKernel that does nothing.</li><li class="collection-item"><a href="source/raykernels/RayDistanceAux.html">RayDistanceAux</a>Accumulates the distance traversed by each Ray segment into an aux variable for the element that the segments are in.</li><li class="collection-item"><a href="source/raykernels/VariableIntegralRayKernel.html">VariableIntegralRayKernel</a>Integrates a Variable or AuxVariable along a Ray.</li></ul></section><section class="scrollspy" id="86961cb1-22af-4a53-b0bf-7a769d1301ff" data-section-level="2" data-section-text="Reporters"><h2 id="reporters"><a href="syntax/Reporters/index.html">Reporters</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddReporterAction.html">AddReporterAction</a>Add a Reporter object to the simulation.</li><li class="collection-item"><a href="source/reporters/AccumulateReporter.html">AccumulateReporter</a>Reporter which accumulates the value of a inputted reporter value over time into a vector reporter value of the same type.</li><li class="collection-item"><a href="source/reporters/ConstantReporter.html">ConstantReporter</a>Reporter with constant values to be accessed by other objects, can be modified using transfers.</li><li class="collection-item"><a href="source/reporters/ElementVariableStatistics.html">ElementVariableStatistics</a>Element reporter to get statistics for a coupled variable. This can be transfered to other apps.</li><li class="collection-item"><a href="source/reporters/ExtraIDIntegralReporter.html">ExtraIDIntegralReporter</a>This ExtraIDIntegralReporter source code is to integrate variables based on parsed extra IDs based on reporter system.</li><li class="collection-item"><a href="source/reporters/IterationInfo.html">IterationInfo</a>Report the time and iteration information for the simulation.</li><li class="collection-item"><a href="source/reporters/MeshInfo.html">MeshInfo</a>Report mesh information, such as the number of elements, nodes, and degrees of freedom.</li><li class="collection-item"><a href="source/reporters/NodalVariableStatistics.html">NodalVariableStatistics</a>Nodal reporter to get statistics for a coupled variable. This can be transfered to other apps.</li><li class="collection-item"><a href="source/reporters/PerfGraphReporter.html">PerfGraphReporter</a>Reports the full performance graph from the PerfGraph.</li><li class="collection-item"><a href="source/reporters/SolutionInvalidityReporter.html">SolutionInvalidityReporter</a>Reports the Summary Table of Solution Invalid Counts.</li></ul></section><section class="scrollspy" id="a6c5e22e-e21d-4d3b-9774-89fdfb8a3c7e" data-section-level="2" data-section-text="Samplers"><h2 id="samplers"><a href="syntax/Samplers/index.html">Samplers</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddSamplerAction.html">AddSamplerAction</a>Add a Sampler object to the simulation.</li></ul></section><section class="scrollspy" id="ade3bb00-d8a3-40f0-94a8-e8744e9bfdcf" data-section-level="2" data-section-text="ScalarKernels"><h2 id="scalarkernels"><a href="syntax/ScalarKernels/index.html">ScalarKernels</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddScalarKernelAction.html">AddScalarKernelAction</a>Add a AuxScalarKernel object to the simulation.</li><li class="collection-item"><a href="source/scalarkernels/ADScalarTimeDerivative.html">ADScalarTimeDerivative</a>Adds the time derivative contribution to the residual for a scalar variable.</li><li class="collection-item"><a href="source/scalarkernels/AverageValueConstraint.html">AverageValueConstraint</a>This class is used to enforce integral of phi with a Lagrange multiplier approach.</li><li class="collection-item"><a href="source/scalarkernels/CoupledODETimeDerivative.html">CoupledODETimeDerivative</a>Residual contribution of ODE from the time derivative of a coupled variable.</li><li class="collection-item"><a href="source/scalarkernels/NodalEqualValueConstraint.html">NodalEqualValueConstraint</a>Constrain two nodes to have identical values.</li><li class="collection-item"><a href="source/scalarkernels/NullScalarKernel.html">NullScalarKernel</a>Scalar kernel that sets a zero residual, to avoid error from system missing this variable.</li><li class="collection-item"><a href="source/scalarkernels/ODETimeDerivative.html">ODETimeDerivative</a>Returns the time derivative contribution to the residual for a scalar variable.</li><li class="collection-item"><a href="source/scalarkernels/ParsedODEKernel.html">ParsedODEKernel</a>Parsed expression ODE kernel.</li><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/scalarkernels/GeneralizedPlaneStrain.html">GeneralizedPlaneStrain</a>Generalized Plane Strain Scalar Kernel</li><li class="collection-item"><a href="source/scalarkernels/GlobalStrain.html">GlobalStrain</a>Scalar Kernel to solve for the global strain</li><li class="collection-item"><a href="source/scalarkernels/lagrangian/HomogenizationConstraintScalarKernel.html">HomogenizationConstraintScalarKernel</a></li></ul></section><section class="scrollspy" id="8b7d9d01-7361-4503-a478-71a5fbefbdb6" data-section-level="2" data-section-text="ThermalContact"><h2 id="thermalcontact"><a href="syntax/ThermalContact/index.html">ThermalContact</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Heat Conduction App</li><li class="collection-item"><a href="source/actions/ThermalContactAction.html">ThermalContactAction</a>Action that controls the creation of all of the necessary objects for calculation of Thermal Contact</li></ul></section><section class="scrollspy" id="bdd30d04-543b-4de4-8ca9-9ab99b14fd3b" data-section-level="2" data-section-text="Times"><h2 id="times"><a href="syntax/Times/index.html">Times</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddTimesAction.html">AddTimesAction</a>Add a Times object to the simulation.</li><li class="collection-item"><a href="source/times/CSVFileTimes.html">CSVFileTimes</a>Import times from one or more files.</li><li class="collection-item"><a href="source/times/ExodusFileTimes.html">ExodusFileTimes</a>Import times from one or more Exodus files.</li><li class="collection-item"><a href="source/times/FunctorTimes.html">FunctorTimes</a>Times created by evaluating a functor at the (0,0,0) point and the current time</li><li class="collection-item"><a href="source/times/InputTimes.html">InputTimes</a>Times set directly from a user parameter in the input file</li><li class="collection-item"><a href="source/times/ReporterTimes.html">ReporterTimes</a>Import times from one or more reporters, for example other Times</li><li class="collection-item"><a href="source/times/SimulationTimes.html">SimulationTimes</a>Times simulated</li></ul></section><section class="scrollspy" id="35983bfe-b5f9-431d-a634-5fc50bc3afcc" data-section-level="2" data-section-text="Transfers"><h2 id="transfers"><a href="syntax/Transfers/index.html">Transfers</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddTransferAction.html">AddTransferAction</a>Add a Transfer object to the simulation.</li><li class="collection-item"><a href="source/transfers/MultiAppCloneReporterTransfer.html">MultiAppCloneReporterTransfer</a>Declare and transfer reporter data from sub-application(s) to main application.</li><li class="collection-item"><a href="source/transfers/MultiAppCopyTransfer.html">MultiAppCopyTransfer</a>Copies variables (nonlinear and auxiliary) between multiapps that have identical meshes.</li><li class="collection-item"><a href="source/transfers/MultiAppGeneralFieldNearestNodeTransfer.html">MultiAppGeneralFieldNearestNodeTransfer</a>Transfers field data at the MultiApp position by finding the value at the nearest neighbor(s) in the origin application.</li><li class="collection-item"><a href="source/transfers/MultiAppGeneralFieldShapeEvaluationTransfer.html">MultiAppGeneralFieldShapeEvaluationTransfer</a>Transfers field data at the MultiApp position using the finite element shape functions from the origin application.</li><li class="collection-item"><a href="source/transfers/MultiAppGeneralFieldUserObjectTransfer.html">MultiAppGeneralFieldUserObjectTransfer</a>Transfers user object spatial evaluations from an origin app onto a variable in the target application.</li><li class="collection-item"><a href="source/transfers/MultiAppGeometricInterpolationTransfer.html">MultiAppGeometricInterpolationTransfer</a>Transfers the value to the target domain from a combination/interpolation of the values on the nearest nodes in the source domain, using coefficients based on the distance to each node.</li><li class="collection-item"><a href="source/transfers/MultiAppGeometricInterpolationTransfer.html">MultiAppInterpolationTransfer</a>Transfers the value to the target domain from a combination/interpolation of the values on the nearest nodes in the source domain, using coefficients based on the distance to each node.</li><li class="collection-item"><a href="source/transfers/MultiAppShapeEvaluationTransfer.html">MultiAppMeshFunctionTransfer</a>Transfers field data at the MultiApp position using solution the finite element function from the main/parent application, via a &#x27;libMesh::MeshFunction&#x27; object.</li><li class="collection-item"><a href="source/transfers/MultiAppNearestNodeTransfer.html">MultiAppNearestNodeTransfer</a>Transfer the value to the target domain from the nearest node in the source domain.</li><li class="collection-item"><a href="source/transfers/MultiAppPostprocessorInterpolationTransfer.html">MultiAppPostprocessorInterpolationTransfer</a>Transfer postprocessor data from sub-application into field data on the parent application.</li><li class="collection-item"><a href="source/transfers/MultiAppPostprocessorToAuxScalarTransfer.html">MultiAppPostprocessorToAuxScalarTransfer</a>Transfers from a postprocessor to a scalar auxiliary variable.</li><li class="collection-item"><a href="source/transfers/MultiAppPostprocessorTransfer.html">MultiAppPostprocessorTransfer</a>Transfers postprocessor data between the master application and sub-application(s).</li><li class="collection-item"><a href="source/transfers/MultiAppProjectionTransfer.html">MultiAppProjectionTransfer</a>Perform a projection between a master and sub-application mesh of a field variable.</li><li class="collection-item"><a href="source/transfers/MultiAppReporterTransfer.html">MultiAppReporterTransfer</a>Transfers reporter data between two applications.</li><li class="collection-item"><a href="source/transfers/MultiAppScalarToAuxScalarTransfer.html">MultiAppScalarToAuxScalarTransfer</a>Transfers data from a scalar variable to an auxiliary scalar variable from different applications.</li><li class="collection-item"><a href="source/transfers/MultiAppShapeEvaluationTransfer.html">MultiAppShapeEvaluationTransfer</a>Transfers field data at the MultiApp position using solution the finite element function from the main/parent application, via a &#x27;libMesh::MeshFunction&#x27; object.</li><li class="collection-item"><a href="source/transfers/MultiAppUserObjectTransfer.html">MultiAppUserObjectTransfer</a>Samples a variable&#x27;s value in the Parent app domain at the point where the MultiApp is and copies that value into a post-processor in the MultiApp</li><li class="collection-item"><a href="source/transfers/MultiAppVariableValueSamplePostprocessorTransfer.html">MultiAppVariableValueSamplePostprocessorTransfer</a>Samples the value of a variable within the main application at each sub-application position and transfers the value to a postprocessor on the sub-application(s) when performing the to-multiapp transfer. Reconstructs the value of a CONSTANT MONOMIAL variable associating the value of each element to the value of the postprocessor in the closest sub-application whem performing the from-multiapp transfer.</li><li class="collection-item"><a href="source/transfers/MultiAppVariableValueSampleTransfer.html">MultiAppVariableValueSampleTransfer</a>Transfers the value of a variable within the master application at each sub-application position and transfers the value to a field variable on the sub-application(s).</li><li class="collection-item"><a href="source/transfers/MultiAppVectorPostprocessorTransfer.html">MultiAppVectorPostprocessorTransfer</a>This transfer distributes the N values of a VectorPostprocessor to Postprocessors located in N sub-apps or collects Postprocessor values from N sub-apps into a VectorPostprocessor</li></ul></section><section class="scrollspy" id="563f092f-28e9-4763-9ddb-3682f71c5ef9" data-section-level="2" data-section-text="UserObjects"><h2 id="userobjects"><a href="syntax/UserObjects/index.html">UserObjects</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddUserObjectAction.html">AddUserObjectAction</a>Add a UserObject object to the simulation.</li><li class="collection-item"><a href="source/postprocessors/ElementAverageMaterialProperty.html">ADElementAverageMaterialProperty</a>Computes the average of a material property over a volume.</li><li class="collection-item"><a href="source/postprocessors/ElementExtremeFunctorValue.html">ADElementExtremeFunctorValue</a>Finds either the min or max elemental value of a variable over the domain.</li><li class="collection-item"><a href="source/postprocessors/ElementExtremeMaterialProperty.html">ADElementExtremeMaterialProperty</a>Determines the minimum or maximum of a material property over a volume.</li><li class="collection-item"><a href="source/postprocessors/ElementIntegralFunctorPostprocessor.html">ADElementIntegralFunctorPostprocessor</a>Computes a volume integral of the specified functor</li><li class="collection-item"><a href="source/postprocessors/ElementIntegralMaterialProperty.html">ADElementIntegralMaterialProperty</a>Compute the integral of the material property over the domain</li><li class="collection-item"><a href="source/postprocessors/ElementL2FunctorError.html">ADElementL2FunctorError</a>Computes L2 error between an &#x27;approximate&#x27; functor and an &#x27;exact&#x27; functor</li><li class="collection-item"><a href="source/postprocessors/InterfaceDiffusiveFluxAverage.html">ADInterfaceDiffusiveFluxAverage</a>Computes the diffusive flux on the interface.</li><li class="collection-item"><a href="source/postprocessors/InterfaceDiffusiveFluxIntegral.html">ADInterfaceDiffusiveFluxIntegral</a>Computes the diffusive flux on the interface.</li><li class="collection-item"><a href="source/postprocessors/SideAverageMaterialProperty.html">ADSideAverageMaterialProperty</a>Computes the average of a material property over a side set.</li><li class="collection-item"><a href="source/postprocessors/SideDiffusiveFluxAverage.html">ADSideDiffusiveFluxAverage</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="source/postprocessors/SideDiffusiveFluxIntegral.html">ADSideDiffusiveFluxIntegral</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="source/postprocessors/SideDiffusiveFluxAverage.html">ADSideFluxAverage</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="source/postprocessors/SideDiffusiveFluxIntegral.html">ADSideFluxIntegral</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="source/postprocessors/SideIntegralFunctorPostprocessor.html">ADSideIntegralFunctorPostprocessor</a>Computes a surface integral of the specified functor, using the single-sided face argument, which usually means that the functor will be evaluated from a single side of the surface, not interpolated between both sides.</li><li class="collection-item"><a href="source/postprocessors/SideIntegralMaterialProperty.html">ADSideIntegralMaterialProperty</a>Compute the integral of a scalar material property component over the domain.</li><li class="collection-item"><a href="source/postprocessors/SideDiffusiveFluxIntegral.html">ADSideVectorDiffusivityFluxIntegral</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="source/userobjects/ActivateElementsByPath.html">ActivateElementsByPath</a>Determine activated elements.</li><li class="collection-item"><a href="source/userobjects/ActivateElementsCoupled.html">ActivateElementsCoupled</a>Determine activated elements.</li><li class="collection-item"><a href="source/postprocessors/AreaPostprocessor.html">AreaPostprocessor</a>Computes the &quot;area&quot; or dimension - 1 &quot;volume&quot; of a given boundary or boundaries in your mesh.</li><li class="collection-item"><a href="source/postprocessors/AverageElementSize.html">AverageElementSize</a>Computes the average element size.</li><li class="collection-item"><a href="source/postprocessors/AverageNodalVariableValue.html">AverageNodalVariableValue</a>Computes the average value of a field by sampling all nodal solutions on the domain or within a subdomain</li><li class="collection-item"><a href="source/postprocessors/AxisymmetricCenterlineAverageValue.html">AxisymmetricCenterlineAverageValue</a>Computes the average value of a variable on a sideset located along the centerline of an axisymmetric model.</li><li class="collection-item"><a href="source/postprocessors/ChangeOverFixedPointPostprocessor.html">ChangeOverFixedPointPostprocessor</a>Computes the change or relative change in a post-processor value over a single or multiple fixed point iterations</li><li class="collection-item"><a href="source/postprocessors/ChangeOverTimePostprocessor.html">ChangeOverTimePostprocessor</a>Computes the change or relative change in a post-processor value over a timestep or the entire transient</li><li class="collection-item"><a href="source/postprocessors/ChangeOverTimestepPostprocessor.html">ChangeOverTimestepPostprocessor</a>Computes the change or relative change in a post-processor value over a timestep or the entire transient</li><li class="collection-item"><a href="source/postprocessors/ConstantPostprocessor.html">ConstantPostprocessor</a>Postprocessor that holds a constant value</li><li class="collection-item"><a href="source/userobjects/CoupledVarThresholdElementSubdomainModifier.html">CoupledVarThresholdElementSubdomainModifier</a>Modify element subdomain ID. This userobject only runs on the undisplaced mesh, and it will modify both the undisplaced and the displaced mesh.</li><li class="collection-item"><a href="source/postprocessors/CumulativeValuePostprocessor.html">CumulativeValuePostprocessor</a>Creates a cumulative sum of a Postprocessor value with time.</li><li class="collection-item"><a href="source/postprocessors/DifferencePostprocessor.html">DifferencePostprocessor</a>Computes the difference between two postprocessors</li><li class="collection-item"><a href="source/userobjects/ElemSideNeighborLayersGeomTester.html">ElemSideNeighborLayersGeomTester</a>User object to calculate ghosted elements on a single processor or the union across all processors.</li><li class="collection-item"><a href="source/userobjects/ElemSideNeighborLayersTester.html">ElemSideNeighborLayersTester</a>User object to calculate ghosted elements on a single processor or the union across all processors.</li><li class="collection-item"><a href="source/postprocessors/ElementArrayL2Norm.html">ElementArrayL2Norm</a>Evaluates L2-norm of a component of an array variable</li><li class="collection-item"><a href="source/postprocessors/ElementAverageMaterialProperty.html">ElementAverageMaterialProperty</a>Computes the average of a material property over a volume.</li><li class="collection-item"><a href="source/postprocessors/ElementAverageSecondTimeDerivative.html">ElementAverageSecondTimeDerivative</a>Computes the element averaged second derivative of variable</li><li class="collection-item"><a href="source/postprocessors/ElementAverageTimeDerivative.html">ElementAverageTimeDerivative</a>Computes a volume integral of the time derivative of a given variable</li><li class="collection-item"><a href="source/postprocessors/ElementAverageValue.html">ElementAverageValue</a>Computes the volumetric average of a variable</li><li class="collection-item"><a href="source/postprocessors/ElementExtremeFunctorValue.html">ElementExtremeFunctorValue</a>Finds either the min or max elemental value of a variable over the domain.</li><li class="collection-item"><a href="source/postprocessors/ElementExtremeMaterialProperty.html">ElementExtremeMaterialProperty</a>Determines the minimum or maximum of a material property over a volume.</li><li class="collection-item"><a href="source/postprocessors/ElementExtremeValue.html">ElementExtremeValue</a>Finds either the min or max elemental value of a variable over the domain.</li><li class="collection-item"><a href="source/postprocessors/ElementH1Error.html">ElementH1Error</a>Computes the H1 error between a variable and a function</li><li class="collection-item"><a href="source/postprocessors/ElementH1SemiError.html">ElementH1SemiError</a>Returns the gradient difference norm part of the H1 error</li><li class="collection-item"><a href="source/postprocessors/ElementIntegralArrayVariablePostprocessor.html">ElementIntegralArrayVariablePostprocessor</a>Integral of one component of an array variable.</li><li class="collection-item"><a href="source/postprocessors/ElementIntegralFunctorPostprocessor.html">ElementIntegralFunctorPostprocessor</a>Computes a volume integral of the specified functor</li><li class="collection-item"><a href="source/postprocessors/ElementIntegralMaterialProperty.html">ElementIntegralMaterialProperty</a>Compute the integral of the material property over the domain</li><li class="collection-item"><a href="source/postprocessors/ElementIntegralVariablePostprocessor.html">ElementIntegralVariablePostprocessor</a>Computes a volume integral of the specified variable</li><li class="collection-item"><a href="source/userobjects/ElementIntegralVariableUserObject.html">ElementIntegralVariableUserObject</a>computes a volume integral of a variable.</li><li class="collection-item"><a href="source/postprocessors/ElementL1Error.html">ElementL1Error</a>Computes L1 error between an elemental field variable and an analytical function.</li><li class="collection-item"><a href="source/postprocessors/ElementL2Difference.html">ElementL2Difference</a>Computes the element-wise L2 difference between the current variable and a coupled variable.</li><li class="collection-item"><a href="source/postprocessors/ElementL2Error.html">ElementL2Error</a>Computes L2 error between a field variable and an analytical function</li><li class="collection-item"><a href="source/postprocessors/ElementL2FunctorError.html">ElementL2FunctorError</a>Computes L2 error between an &#x27;approximate&#x27; functor and an &#x27;exact&#x27; functor</li><li class="collection-item"><a href="source/postprocessors/ElementL2Norm.html">ElementL2Norm</a>Computes a volume integral of the specified variable</li><li class="collection-item"><a href="source/userobjects/PropertyReadFile.html">ElementPropertyReadFile</a>User Object to read property data from an external file and assign to elements.</li><li class="collection-item"><a href="source/userobjects/ElementQualityChecker.html">ElementQualityChecker</a>Class to check the quality of each element using different metrics from libmesh.</li><li class="collection-item"><a href="source/postprocessors/ElementSidesL2Norm.html">ElementSidesL2Norm</a>Computes the L2 norm of a variable over element sides.</li><li class="collection-item"><a href="source/postprocessors/ElementVectorL2Error.html">ElementVectorL2Error</a>Computes the Vector L2 difference of up to three variables simultaneously (normally x, y, z)</li><li class="collection-item"><a href="source/postprocessors/ElementW1pError.html">ElementW1pError</a>Computes the W1p norm of the difference between a variable and an analytic solution, as a function</li><li class="collection-item"><a href="source/postprocessors/ElementalVariableValue.html">ElementalVariableValue</a>Outputs an elemental variable value at a particular location</li><li class="collection-item"><a href="source/postprocessors/EmptyPostprocessor.html">EmptyPostprocessor</a>A postprocessor object that returns a value of zero.</li><li class="collection-item"><a href="source/postprocessors/FindValueOnLine.html">FindValueOnLine</a>Find a specific target value along a sampling line. The variable values along the line should change monotonically. The target value is searched using a bisection algorithm.</li><li class="collection-item"><a href="source/postprocessors/FunctionElementAverage.html">FunctionElementAverage</a>Computes the average of a function over a volume.</li><li class="collection-item"><a href="source/postprocessors/FunctionElementIntegral.html">FunctionElementIntegral</a>Integrates a function over elements</li><li class="collection-item"><a href="source/userobjects/FunctionElementIntegralUserObject.html">FunctionElementIntegralUserObject</a>Computes a volume integral of a function.</li><li class="collection-item"><a href="source/userobjects/FunctionLayeredIntegral.html">FunctionLayeredIntegral</a>Integrates a function in layers</li><li class="collection-item"><a href="source/postprocessors/FunctionSideAverage.html">FunctionSideAverage</a>Computes the average of a function over a boundary.</li><li class="collection-item"><a href="source/postprocessors/FunctionSideIntegral.html">FunctionSideIntegral</a>Computes the integral of a function over a boundary.</li><li class="collection-item"><a href="source/postprocessors/FunctionValuePostprocessor.html">FunctionValuePostprocessor</a>Computes the value of a supplied function at a single point (scalable)</li><li class="collection-item"><a href="source/userobjects/GeometrySphere.html">GeometrySphere</a>Snap nodes to the surface of a sphere on adaptivity</li><li class="collection-item"><a href="source/userobjects/GhostingUserObject.html">GhostingUserObject</a>Creates ghosting maps that can be queried by external objects.</li><li class="collection-item"><a href="source/postprocessors/GreaterThanLessThanPostprocessor.html">GreaterThanLessThanPostprocessor</a>Count number of DOFs of a non-linear variable that are greater than or less than a given threshold</li><li class="collection-item"><a href="source/postprocessors/InterfaceAverageVariableValuePostprocessor.html">InterfaceAverageVariableValuePostprocessor</a>Computes the average value of a variable on an interface. Note that this cannot be used on the centerline of an axisymmetric model.</li><li class="collection-item"><a href="source/postprocessors/InterfaceDiffusiveFluxAverage.html">InterfaceDiffusiveFluxAverage</a>Computes the diffusive flux on the interface.</li><li class="collection-item"><a href="source/postprocessors/InterfaceDiffusiveFluxIntegral.html">InterfaceDiffusiveFluxIntegral</a>Computes the diffusive flux on the interface.</li><li class="collection-item"><a href="source/postprocessors/InterfaceIntegralVariableValuePostprocessor.html">InterfaceIntegralVariableValuePostprocessor</a>Add access to variables and their gradient on an interface.</li><li class="collection-item"><a href="source/userobjects/InterfaceQpMaterialPropertyRealUO.html">InterfaceQpMaterialPropertyRealUO</a>Computes the value, rate or increment of a Real Material property across an interface. The value, rate or increment is computed according to the provided interface_value_type parameter</li><li class="collection-item"><a href="source/userobjects/InterfaceQpValueUserObject.html">InterfaceQpValueUserObject</a>Computes the variable value, rate or increment across an interface. The value, rate or increment is computed according to the provided interface_value_type parameter</li><li class="collection-item"><a href="source/postprocessors/InternalSideIntegralVariablePostprocessor.html">InternalSideIntegralVariablePostprocessor</a>Computes an integral on internal sides of the specified variable</li><li class="collection-item"><a href="source/userobjects/LayeredAverage.html">LayeredAverage</a>Computes averages of variables over layers</li><li class="collection-item"><a href="source/userobjects/LayeredExtremumMaterialProperty.html">LayeredExtremumMaterialProperty</a>Compute material property extrema over layers.</li><li class="collection-item"><a href="source/userobjects/LayeredIntegral.html">LayeredIntegral</a>Compute variable integrals over layers.</li><li class="collection-item"><a href="source/userobjects/LayeredSideAverage.html">LayeredSideAverage</a>Computes side averages of a variable storing partial sums for the specified number of intervals in a direction (x,y,z).</li><li class="collection-item"><a href="source/userobjects/LayeredSideDiffusiveFluxAverage.html">LayeredSideDiffusiveFluxAverage</a>Computes the diffusive flux of a variable on layers alongside a boundary.</li><li class="collection-item"><a href="source/userobjects/LayeredSideDiffusiveFluxAverage.html">LayeredSideFluxAverage</a>Computes the diffusive flux of a variable on layers alongside a boundary.</li><li class="collection-item"><a href="source/userobjects/LayeredSideIntegral.html">LayeredSideIntegral</a>Computes surface integral of a variable storing partial sums for the specified number of intervals in a direction (x,y,z).</li><li class="collection-item"><a href="source/postprocessors/LinearCombinationPostprocessor.html">LinearCombinationPostprocessor</a>Computes a linear combination between an arbitrary number of post-processors</li><li class="collection-item"><a href="source/postprocessors/MemoryUsage.html">MemoryUsage</a>Memory usage statistics for the running simulation.</li><li class="collection-item"><a href="source/userobjects/MessageFromInput.html">MessageFromInput</a>Print out a message from the input file</li><li class="collection-item"><a href="source/postprocessors/NearestNodeNumber.html">NearestNodeNumber</a>Outputs the nearest node number to a point</li><li class="collection-item"><a href="source/userobjects/NearestNodeNumberUO.html">NearestNodeNumberUO</a>Finds and outputs the nearest node number to a point</li><li class="collection-item"><a href="source/userobjects/NearestPointAverage.html">NearestPointAverage</a>Compute element variable averages for nearest-point based subdomains</li><li class="collection-item"><a href="source/userobjects/NearestPointLayeredAverage.html">NearestPointLayeredAverage</a>Computes averages of a variable storing partial sums for the specified number of intervals in a direction (x,y,z). Given a list of points this object computes the layered average closest to each one of those points.</li><li class="collection-item"><a href="source/userobjects/NearestPointLayeredIntegral.html">NearestPointLayeredIntegral</a>Computes integrals of a variable storing partial sums for the specified number of intervals in a direction (x,y,z). Given a list of points this object computes the layered integral closest to each one of those points.</li><li class="collection-item"><a href="source/userobjects/NearestPointLayeredSideAverage.html">NearestPointLayeredSideAverage</a>Compute layered side averages for nearest-point based subdomains</li><li class="collection-item"><a href="source/userobjects/NearestPointLayeredSideDiffusiveFluxAverage.html">NearestPointLayeredSideDiffusiveFluxAverage</a>Compute layered side diffusive flux averages for nearest-point based subdivisions</li><li class="collection-item"><a href="source/userobjects/NearestPointLayeredSideDiffusiveFluxAverage.html">NearestPointLayeredSideFluxAverage</a>Compute layered side diffusive flux averages for nearest-point based subdivisions</li><li class="collection-item"><a href="source/userobjects/NearestPointLayeredSideIntegral.html">NearestPointLayeredSideIntegral</a>Compute layered side integrals for nearest-point based sidesets</li><li class="collection-item"><a href="source/userobjects/NearestRadiusLayeredAverage.html">NearestRadiusLayeredAverage</a>Computes averages of a variable storing partial sums for the specified number of intervals in a direction (x,y,z). Given a list of points this object computes the layered average closest to each one of those points, where the distance is computed in terms of radius (or distance to the origin in the plane perpendicular to &#x27;direction&#x27;).</li><li class="collection-item"><a href="source/postprocessors/NodalExtremeValue.html">NodalExtremeValue</a>Finds either the min or max elemental value of a variable over the domain.</li><li class="collection-item"><a href="source/postprocessors/NodalL2Error.html">NodalL2Error</a>The L2-norm of the difference between a variable and a function computed at nodes.</li><li class="collection-item"><a href="source/postprocessors/NodalL2Norm.html">NodalL2Norm</a>Computes the nodal L2-norm of the coupled variable, which is defined by summing the square of its value at every node and taking the square root.</li><li class="collection-item"><a href="source/postprocessors/NodalMaxValue.html">NodalMaxValue</a>Computes the maximum (over all the nodal values) of a variable.</li><li class="collection-item"><a href="source/postprocessors/NodalMaxValueId.html">NodalMaxValueId</a>Finds the node id with the maximum nodal value across all postprocessors.</li><li class="collection-item"><a href="source/userobjects/NodalNormalsCorner.html">NodalNormalsCorner</a>Computes nodal normals at boundary corners.</li><li class="collection-item"><a href="source/userobjects/NodalNormalsEvaluator.html">NodalNormalsEvaluator</a>Helper object to compute nodal normal values via the NodalNormals input block.</li><li class="collection-item"><a href="source/userobjects/NodalNormalsPreprocessor.html">NodalNormalsPreprocessor</a>An object that prepares MOOSE for computing nodal normal vectors. This object is automatically created via the [NodalNormals] input block.</li><li class="collection-item"><a href="source/postprocessors/NodalMaxValueId.html">NodalProxyMaxValue</a>Finds the node id with the maximum nodal value across all postprocessors.</li><li class="collection-item"><a href="source/postprocessors/NodalSum.html">NodalSum</a>Computes the sum of all of the nodal values of the specified variable. Note: This object sets the default &quot;unique_node_execute&quot; flag to true to avoid double counting nodes between shared blocks.</li><li class="collection-item"><a href="source/postprocessors/NodalVariableValue.html">NodalVariableValue</a>Outputs values of a nodal variable at a particular location</li><li class="collection-item"><a href="source/postprocessors/NumDOFs.html">NumDOFs</a>Return the number of Degrees of freedom from either the NL, Aux or both systems.</li><li class="collection-item"><a href="source/postprocessors/NumElems.html">NumElems</a>Return the number of active or total elements in the simulation.</li><li class="collection-item"><a href="source/postprocessors/NumFailedTimeSteps.html">NumFailedTimeSteps</a>Collects the number of failed time steps from the time stepper.</li><li class="collection-item"><a href="source/postprocessors/NumFixedPointIterations.html">NumFixedPointIterations</a>Returns the number of fixed point iterations taken by the executioner.</li><li class="collection-item"><a href="source/postprocessors/NumLinearIterations.html">NumLinearIterations</a>Compute the number of linear iterations.</li><li class="collection-item"><a href="source/postprocessors/NumNodes.html">NumNodes</a>Returns the total number of nodes in a simulation (works with DistributedMesh)</li><li class="collection-item"><a href="source/postprocessors/NumNonlinearIterations.html">NumNonlinearIterations</a>Outputs the number of nonlinear iterations</li><li class="collection-item"><a href="source/postprocessors/NumFixedPointIterations.html">NumPicardIterations</a>Returns the number of fixed point iterations taken by the executioner.</li><li class="collection-item"><a href="source/postprocessors/NumPositions.html">NumPositions</a>Return the number of Positions from a Positions object.</li><li class="collection-item"><a href="source/postprocessors/NumRelationshipManagers.html">NumRelationshipManagers</a>Return the number of relationship managers active.</li><li class="collection-item"><a href="source/postprocessors/NumResidualEvaluations.html">NumResidualEvaluations</a>Returns the total number of residual evaluations performed.</li><li class="collection-item"><a href="source/postprocessors/NumVars.html">NumVars</a>Return the number of variables from either the NL, Aux, or both systems.</li><li class="collection-item"><a href="source/postprocessors/ParsedPostprocessor.html">ParsedPostprocessor</a>Computes a parsed expression with post-processors</li><li class="collection-item"><a href="source/postprocessors/PercentChangePostprocessor.html">PercentChangePostprocessor</a>Computes the percent change of a postprocessor value compared to the value at the previous timestep.</li><li class="collection-item"><a href="source/postprocessors/PerfGraphData.html">PerfGraphData</a>Retrieves performance information about a section from the PerfGraph.</li><li class="collection-item"><a href="source/postprocessors/PointValue.html">PointValue</a>Compute the value of a variable at a specified location</li><li class="collection-item"><a href="source/userobjects/PointwiseRenormalizeVector.html">PointwiseRenormalizeVector</a>Pointwise renormalize the solution of a set of variables comprising a vector</li><li class="collection-item"><a href="source/postprocessors/PostprocessorComparison.html">PostprocessorComparison</a>Compares two post-processors and produces a boolean value</li><li class="collection-item"><a href="source/userobjects/PostprocessorSpatialUserObject.html">PostprocessorSpatialUserObject</a>User object (spatial) that holds a postprocessor value.</li><li class="collection-item"><a href="source/userobjects/PropertyReadFile.html">PropertyReadFile</a>User Object to read property data from an external file and assign to elements.</li><li class="collection-item"><a href="source/userobjects/RadialAverage.html">RadialAverage</a>Perform a radial average of a material property</li><li class="collection-item"><a href="source/postprocessors/Receiver.html">Receiver</a>Reports the value stored in this processor, which is usually filled in by another object. The Receiver does not compute its own value.</li><li class="collection-item"><a href="source/postprocessors/RelativeDifferencePostprocessor.html">RelativeDifferencePostprocessor</a>Computes the absolute value of the relative difference between 2 post-processor values.</li><li class="collection-item"><a href="source/postprocessors/RelativeSolutionDifferenceNorm.html">RelativeSolutionDifferenceNorm</a>Computes the relative norm of the solution difference of two consecutive time steps.</li><li class="collection-item"><a href="source/postprocessors/Residual.html">Residual</a>Report the non-linear residual.</li><li class="collection-item"><a href="source/postprocessors/ScalarL2Error.html">ScalarL2Error</a>Compute L2 error of a scalar variable using analytic function.</li><li class="collection-item"><a href="source/postprocessors/ScalarVariable.html">ScalarVariable</a>Returns the value of a scalar variable as a postprocessor value.</li><li class="collection-item"><a href="source/postprocessors/ScalePostprocessor.html">ScalePostprocessor</a>Scales a post-processor by a value</li><li class="collection-item"><a href="source/postprocessors/SideAverageMaterialProperty.html">SideAverageMaterialProperty</a>Computes the average of a material property over a side set.</li><li class="collection-item"><a href="source/postprocessors/SideAverageValue.html">SideAverageValue</a>Computes the average value of a variable on a sideset. Note that this cannot be used on the centerline of an axisymmetric model.</li><li class="collection-item"><a href="source/postprocessors/SideDiffusiveFluxAverage.html">SideDiffusiveFluxAverage</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="source/postprocessors/SideDiffusiveFluxIntegral.html">SideDiffusiveFluxIntegral</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="source/postprocessors/SideExtremeValue.html">SideExtremeValue</a>Finds either the min or max variable value of a variable over a boundary.</li><li class="collection-item"><a href="source/postprocessors/SideDiffusiveFluxAverage.html">SideFluxAverage</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="source/postprocessors/SideDiffusiveFluxIntegral.html">SideFluxIntegral</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="source/postprocessors/SideIntegralFunctorPostprocessor.html">SideIntegralFunctorPostprocessor</a>Computes a surface integral of the specified functor, using the single-sided face argument, which usually means that the functor will be evaluated from a single side of the surface, not interpolated between both sides.</li><li class="collection-item"><a href="source/postprocessors/SideIntegralMaterialProperty.html">SideIntegralMaterialProperty</a>Compute the integral of a scalar material property component over the domain.</li><li class="collection-item"><a href="source/postprocessors/SideIntegralVariablePostprocessor.html">SideIntegralVariablePostprocessor</a>Computes a surface integral of the specified variable</li><li class="collection-item"><a href="source/postprocessors/SideDiffusiveFluxIntegral.html">SideVectorDiffusivityFluxIntegral</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="source/userobjects/SolutionUserObject.html">SolutionUserObject</a>Reads a variable from a mesh in one simulation to another</li><li class="collection-item"><a href="source/userobjects/Terminator.html">Terminator</a>Requests termination of the current solve based on the evaluation of a parsed logical expression of the Postprocessor value(s).</li><li class="collection-item"><a href="source/postprocessors/TimeExtremeValue.html">TimeExtremeValue</a>A postprocessor for reporting the extreme value of another postprocessor over time.</li><li class="collection-item"><a href="source/postprocessors/TimeIntegratedPostprocessor.html">TimeIntegratedPostprocessor</a>Integrate a Postprocessor value over time using trapezoidal rule.</li><li class="collection-item"><a href="source/postprocessors/TimePostprocessor.html">TimePostprocessor</a>Reports the current time</li><li class="collection-item"><a href="source/postprocessors/TimestepSize.html">TimestepSize</a>Reports the timestep size</li><li class="collection-item"><a href="source/postprocessors/TimeIntegratedPostprocessor.html">TotalVariableValue</a>Integrate a Postprocessor value over time using trapezoidal rule.</li><li class="collection-item"><a href="source/postprocessors/VariableInnerProduct.html">VariableInnerProduct</a>Computes a volume integral of the specified variable</li><li class="collection-item"><a href="source/postprocessors/VariableResidual.html">VariableResidual</a>Computes the L2 norm of the residual of a single variable in the solution vector.</li><li class="collection-item"><a href="source/postprocessors/VectorPostprocessorComparison.html">VectorPostprocessorComparison</a>Compares two vector post-processors of equal size and produces a boolean value</li><li class="collection-item"><a href="source/postprocessors/VectorPostprocessorComponent.html">VectorPostprocessorComponent</a>Returns the value of the specified component of a VectorPostprocessor</li><li class="collection-item"><a href="source/postprocessors/VectorPostprocessorReductionValue.html">VectorPostprocessorReductionValue</a>Takes a VectorPostprocessor and performs a reduction operation on it (max, min, sum, average) and stores as postprocessor.</li><li class="collection-item"><a href="source/userobjects/VerifyElementUniqueID.html">VerifyElementUniqueID</a>Verifies that all element ids are unique.</li><li class="collection-item"><a href="source/userobjects/VerifyNodalUniqueID.html">VerifyNodalUniqueID</a>Verifies that all node ids are unique.</li><li class="collection-item"><a href="source/postprocessors/VolumePostprocessor.html">VolumePostprocessor</a>Computes the volume of a specified block</li><li class="collection-header">Navier Stokes App</li><li class="collection-item"><a href="source/postprocessors/CFLTimeStepSize.html">ADCFLTimeStepSize</a>Computes a time step size based on a user-specified CFL number</li><li class="collection-item"><a href="source/postprocessors/CFLTimeStepSize.html">CFLTimeStepSize</a>Computes a time step size based on a user-specified CFL number</li><li class="collection-item"><a href="source/userobjects/HLLCUserObject.html">HLLCUserObject</a>Computes free-flow wave speeds on internal sides, useful in HLLC contexts</li><li class="collection-item"><a href="source/postprocessors/INSElementIntegralEnergyAdvection.html">INSADElementIntegralEnergyAdvection</a>Computes the net volumetric balance of energy transported by advection</li><li class="collection-item"><a href="source/userobjects/INSADObjectTracker.html">INSADObjectTracker</a>User object used to track the kernels added to an INS simulation and determine what properties to calculate in INSADMaterial</li><li class="collection-item"><a href="source/postprocessors/INSElementIntegralEnergyAdvection.html">INSElementIntegralEnergyAdvection</a>Computes the net volumetric balance of energy transported by advection</li><li class="collection-item"><a href="source/postprocessors/INSExplicitTimestepSelector.html">INSExplicitTimestepSelector</a>Postprocessor that computes the minimum value of h_min/|u|, where |u| is coupled in as an aux variable.</li><li class="collection-item"><a href="source/userobjects/INSFVRhieChowInterpolator.html">INSFVRhieChowInterpolator</a>Computes the Rhie-Chow velocity based on gathered &#x27;a&#x27; coefficient data.</li><li class="collection-item"><a href="source/postprocessors/MassFluxWeightedFlowRate.html">MassFluxWeightedFlowRate</a>Computes the mass flux weighted average of the quantity provided by advected_quantity over a boundary.</li><li class="collection-item"><a href="source/postprocessors/MfrPostprocessor.html">MfrPostprocessor</a>Object for outputting boundary mass fluxes in conjunction with FVFluxBC derived objects that support it</li><li class="collection-item"><a href="source/postprocessors/NSEntropyError.html">NSEntropyError</a>Computes entropy error.</li><li class="collection-item"><a href="source/userobjects/PINSFVRhieChowInterpolator.html">PINSFVRhieChowInterpolator</a>Performs interpolations and reconstructions of porosity and computes the Rhie-Chow face velocities.</li><li class="collection-item"><a href="source/postprocessors/PressureDrop.html">PressureDrop</a>Computes the pressure drop between an upstream and a downstream boundary.</li><li class="collection-item"><a href="source/postprocessors/RayleighNumber.html">RayleighNumber</a>Postprocessor that computes the Rayleigh number for free flow with natural circulation</li><li class="collection-item"><a href="source/postprocessors/VolumetricFlowRate.html">VolumetricFlowRate</a>Computes the volumetric flow rate of an advected quantity through a sideset.</li><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/postprocessors/Mass.html">ADMass</a>Computes a volume integral of the specified variable</li><li class="collection-item"><a href="source/postprocessors/MaterialTensorAverage.html">ADMaterialTensorAverage</a>Computes the average of a RankTwoTensor component over a volume.</li><li class="collection-item"><a href="source/postprocessors/MaterialTensorIntegral.html">ADMaterialTensorIntegral</a>This postprocessor computes an element integral of a component of a material tensor as specified by the user-supplied indices</li><li class="collection-item"><a href="source/postprocessors/SidesetReaction.html">ADSidesetReaction</a>Computes the integrated reaction force in a user-specified direction on a sideset from the surface traction</li><li class="collection-item"><a href="source/userobjects/AbaqusUExternalDB.html">AbaqusUExternalDB</a>Coupling user object to use Abaqus UEXTERNALDB subroutines in MOOSE</li><li class="collection-item"><a href="source/postprocessors/AsymptoticExpansionHomogenizationElasticConstants.html">AsymptoticExpansionHomogenizationElasticConstants</a>Postprocessor for asymptotic expansion homogenization for elasticity</li><li class="collection-item"><a href="source/postprocessors/CavityPressurePostprocessor.html">CavityPressurePostprocessor</a>Interfaces with the CavityPressureUserObject to store the initial number of moles of a gas contained within an internal volume.</li><li class="collection-item"><a href="source/userobjects/CavityPressureUserObject.html">CavityPressureUserObject</a>Uses the ideal gas law to compute internal pressure and an initial moles of gas quantity.</li><li class="collection-item"><a href="source/postprocessors/CrackFrontData.html">CrackFrontData</a>Determines which nodes are along the crack front</li><li class="collection-item"><a href="source/userobjects/CrackFrontDefinition.html">CrackFrontDefinition</a>Used to describe geometric characteristics of the crack front for fracture integral calculations</li><li class="collection-item"><a href="source/postprocessors/CriticalTimeStep.html">CriticalTimeStep</a>Computes and reports the critical time step for the explicit solver.</li><li class="collection-item"><a href="source/userobjects/CrystalPlasticitySlipRateGSS.html">CrystalPlasticitySlipRateGSS</a>Phenomenological constitutive model slip rate class.  Override the virtual functions in your class</li><li class="collection-item"><a href="source/userobjects/CrystalPlasticitySlipResistanceGSS.html">CrystalPlasticitySlipResistanceGSS</a>Phenomenological constitutive models&#x27; slip resistance base class.  Override the virtual functions in your class</li><li class="collection-item"><a href="source/userobjects/CrystalPlasticityStateVarRateComponentGSS.html">CrystalPlasticityStateVarRateComponentGSS</a>Phenomenological constitutive model state variable evolution rate component base class.  Override the virtual functions in your class</li><li class="collection-item"><a href="source/userobjects/CrystalPlasticityStateVarRateComponentVoce.html">CrystalPlasticityStateVarRateComponentVoce</a>Phenomenological Voce constitutive model state variable evolution rate component base class.</li><li class="collection-item"><a href="source/userobjects/CrystalPlasticityStateVariable.html">CrystalPlasticityStateVariable</a>Crystal plasticity state variable class.  Override the virtual functions in your class</li><li class="collection-item"><a href="source/userobjects/EulerAngleFileReader.html">EulerAngleFileReader</a>Read Euler angle data from a file and provide it to other objects.</li><li class="collection-item"><a href="source/userobjects/GeneralizedPlaneStrainUserObject.html">GeneralizedPlaneStrainUserObject</a>Generalized plane strain UserObject to provide residual and diagonal Jacobian entries.</li><li class="collection-item"><a href="source/userobjects/GlobalStrainUserObject.html">GlobalStrainUserObject</a>Global Strain UserObject to provide Residual and diagonal Jacobian entry</li><li class="collection-item"><a href="source/userobjects/HEVPEqvPlasticStrain.html">HEVPEqvPlasticStrain</a>User Object to integrate equivalent plastic strain</li><li class="collection-item"><a href="source/userobjects/HEVPEqvPlasticStrainRate.html">HEVPEqvPlasticStrainRate</a>User Object computing equivalent plastic strain rate</li><li class="collection-item"><a href="source/userobjects/HEVPFlowRatePowerLawJ2.html">HEVPFlowRatePowerLawJ2</a>User object to evaluate power law flow rate and flow direction based on J2</li><li class="collection-item"><a href="source/userobjects/HEVPLinearHardening.html">HEVPLinearHardening</a>User Object for linear hardening</li><li class="collection-item"><a href="source/userobjects/HEVPRambergOsgoodHardening.html">HEVPRambergOsgoodHardening</a>User object for Ramberg-Osgood hardening power law hardening</li><li class="collection-item"><a href="source/userobjects/lagrangian/HomogenizationConstraint.html">HomogenizationConstraint</a></li><li class="collection-item"><a href="source/userobjects/LinearViscoelasticityManager.html">LinearViscoelasticityManager</a>Manages the updating of the semi-implicit single-step first-order finite difference time-stepping scheme</li><li class="collection-item"><a href="source/postprocessors/Mass.html">Mass</a>Computes a volume integral of the specified variable</li><li class="collection-item"><a href="source/postprocessors/MaterialTensorAverage.html">MaterialTensorAverage</a>Computes the average of a RankTwoTensor component over a volume.</li><li class="collection-item"><a href="source/postprocessors/MaterialTensorIntegral.html">MaterialTensorIntegral</a>This postprocessor computes an element integral of a component of a material tensor as specified by the user-supplied indices</li><li class="collection-item"><a href="source/postprocessors/MaterialTimeStepPostprocessor.html">MaterialTimeStepPostprocessor</a>This postprocessor estimates a timestep that reduces the increment change in a material property below a given threshold.</li><li class="collection-item"><a href="source/userobjects/NodalPatchRecoveryMaterialProperty.html">NodalPatchRecoveryMaterialProperty</a>Prepare patches for use in nodal patch recovery based on a material property.</li><li class="collection-item"><a href="source/postprocessors/NormalBoundaryDisplacement.html">NormalBoundaryDisplacement</a>This postprocessor computes the normal displacement on a given set of boundaries.</li><li class="collection-item"><a href="source/postprocessors/PolarMomentOfInertia.html">PolarMomentOfInertia</a>Compute the polar moment of inertia of a sideset w.r.t. a point and a direction</li><li class="collection-item"><a href="source/postprocessors/SidesetReaction.html">SidesetReaction</a>Computes the integrated reaction force in a user-specified direction on a sideset from the surface traction</li><li class="collection-item"><a href="source/userobjects/StepUserObject.html">StepUserObject</a></li><li class="collection-item"><a href="source/userobjects/TensorMechanicsHardeningConstant.html">TensorMechanicsHardeningConstant</a>No hardening - the parameter is independent of the internal parameter(s)</li><li class="collection-item"><a href="source/userobjects/TensorMechanicsHardeningCubic.html">TensorMechanicsHardeningCubic</a>Hardening is Cubic</li><li class="collection-item"><a href="source/userobjects/TensorMechanicsHardeningCutExponential.html">TensorMechanicsHardeningCutExponential</a>Hardening is Cut-exponential</li><li class="collection-item"><a href="source/userobjects/TensorMechanicsHardeningExponential.html">TensorMechanicsHardeningExponential</a>Hardening is Exponential</li><li class="collection-item"><a href="source/userobjects/TensorMechanicsHardeningGaussian.html">TensorMechanicsHardeningGaussian</a>Hardening is Gaussian</li><li class="collection-item"><a href="source/userobjects/TensorMechanicsHardeningPowerRule.html">TensorMechanicsHardeningPowerRule</a>Hardening defined by power rule</li><li class="collection-item"><a href="source/userobjects/TensorMechanicsPlasticDruckerPrager.html">TensorMechanicsPlasticDruckerPrager</a>Non-associative Drucker Prager plasticity with no smoothing of the cone tip.</li><li class="collection-item"><a href="source/userobjects/TensorMechanicsPlasticDruckerPragerHyperbolic.html">TensorMechanicsPlasticDruckerPragerHyperbolic</a>Non-associative Drucker Prager plasticity with hyperbolic smoothing of the cone tip.</li><li class="collection-item"><a href="source/userobjects/TensorMechanicsPlasticIsotropicSD.html">TensorMechanicsPlasticIsotropicSD</a>IsotropicSD plasticity for pressure sensitive materials and also models the strength differential effect</li><li class="collection-item"><a href="source/userobjects/TensorMechanicsPlasticJ2.html">TensorMechanicsPlasticJ2</a>J2 plasticity, associative, with hardening</li><li class="collection-item"><a href="source/userobjects/TensorMechanicsPlasticMeanCap.html">TensorMechanicsPlasticMeanCap</a>Class that limits the mean stress.  Yield function = a*mean_stress - strength.  mean_stress = (stress_xx + stress_yy + stress_zz)/3</li><li class="collection-item"><a href="source/userobjects/TensorMechanicsPlasticMeanCapTC.html">TensorMechanicsPlasticMeanCapTC</a>Associative mean-cap tensile and compressive plasticity with hardening/softening</li><li class="collection-item"><a href="source/userobjects/TensorMechanicsPlasticMohrCoulomb.html">TensorMechanicsPlasticMohrCoulomb</a>Non-associative Mohr-Coulomb plasticity with hardening/softening</li><li class="collection-item"><a href="source/userobjects/TensorMechanicsPlasticMohrCoulombMulti.html">TensorMechanicsPlasticMohrCoulombMulti</a>Non-associative Mohr-Coulomb plasticity with hardening/softening</li><li class="collection-item"><a href="source/userobjects/TensorMechanicsPlasticOrthotropic.html">TensorMechanicsPlasticOrthotropic</a>Orthotropic plasticity for pressure sensitive materials and also models the strength differential effect</li><li class="collection-item"><a href="source/userobjects/TensorMechanicsPlasticSimpleTester.html">TensorMechanicsPlasticSimpleTester</a>Class that can be used for testing multi-surface plasticity models.  Yield function = a*stress_yy + b*stress_zz + c*stress_xx + d*(stress_xy + stress_yx)/2 + e*(stress_xz + stress_zx)/2 + f*(stress_yz + stress_zy)/2 - strength</li><li class="collection-item"><a href="source/userobjects/TensorMechanicsPlasticTensile.html">TensorMechanicsPlasticTensile</a>Associative tensile plasticity with hardening/softening, and tensile_strength = 1</li><li class="collection-item"><a href="source/userobjects/TensorMechanicsPlasticTensileMulti.html">TensorMechanicsPlasticTensileMulti</a>Associative tensile plasticity with hardening/softening</li><li class="collection-item"><a href="source/userobjects/TensorMechanicsPlasticWeakPlaneShear.html">TensorMechanicsPlasticWeakPlaneShear</a>Non-associative finite-strain weak-plane shear perfect plasticity.  Here cohesion = 1, tan(phi) = 1 = tan(psi)</li><li class="collection-item"><a href="source/userobjects/TensorMechanicsPlasticWeakPlaneTensile.html">TensorMechanicsPlasticWeakPlaneTensile</a>Associative weak-plane tensile plasticity with hardening/softening</li><li class="collection-item"><a href="source/userobjects/TensorMechanicsPlasticWeakPlaneTensileN.html">TensorMechanicsPlasticWeakPlaneTensileN</a>Associative weak-plane tensile plasticity with hardening/softening, with specified, fixed normal vector.  (WeakPlaneTensile combined with specifying N in the Material might be preferable to you.)</li><li class="collection-item"><a href="source/postprocessors/TorqueReaction.html">TorqueReaction</a>TorqueReaction calculates the torque in 2D and 3Dabout a user-specified axis of rotation centeredat a user-specified origin.</li><li class="collection-header">Rdg App</li><li class="collection-item"><a href="source/userobjects/AEFVFreeOutflowBoundaryFlux.html">AEFVFreeOutflowBoundaryFlux</a>Free outflow BC based boundary flux user object for the advection equation using a cell-centered finite volume method.</li><li class="collection-item"><a href="source/userobjects/AEFVSlopeLimitingOneD.html">AEFVSlopeLimitingOneD</a>One-dimensional slope limiting to get the limited slope of cell average variable for the advection equation using a cell-centered finite volume method.</li><li class="collection-item"><a href="source/userobjects/AEFVUpwindInternalSideFlux.html">AEFVUpwindInternalSideFlux</a>Upwind numerical flux scheme for the advection equation using a cell-centered finite volume method.</li><li class="collection-item"><a href="source/postprocessors/BoundaryFluxPostprocessor.html">BoundaryFluxPostprocessor</a>Computes the side integral of a flux entry from a BoundaryFluxBase user object</li><li class="collection-header">Ray Tracing App</li><li class="collection-item"><a href="source/userobjects/ConeRayStudy.html">ConeRayStudy</a>Ray study that spawns Rays in the direction of a cone from a given set of starting points.</li><li class="collection-item"><a href="source/postprocessors/RayDataValue.html">RayDataValue</a>Obtains a value from the data or aux data of a Ray after tracing has been completed.</li><li class="collection-item"><a href="source/postprocessors/RayIntegralValue.html">RayIntegralValue</a>Obtains the integrated value accumulated into a Ray from an IntegralRayKernel-derived class.</li><li class="collection-item"><a href="source/postprocessors/RayTracingStudyResult.html">RayTracingStudyResult</a>Gets a result from a RayTracingStudy.</li><li class="collection-item"><a href="source/userobjects/RepeatableRayStudy.html">RepeatableRayStudy</a>A ray tracing study that generates rays from vector of user-input start points and end points/directions.</li><li class="collection-header">Heat Conduction App</li><li class="collection-item"><a href="source/postprocessors/ConvectiveHeatTransferSideIntegral.html">ADConvectiveHeatTransferSideIntegral</a>Computes the total convective heat transfer across a boundary.</li><li class="collection-item"><a href="source/userobjects/ConstantViewFactorSurfaceRadiation.html">ConstantViewFactorSurfaceRadiation</a>ConstantViewFactorSurfaceRadiation computes radiative heat transfer between side sets and the view factors are provided in the input file</li><li class="collection-item"><a href="source/postprocessors/ConvectiveHeatTransferSideIntegral.html">ConvectiveHeatTransferSideIntegral</a>Computes the total convective heat transfer across a boundary.</li><li class="collection-item"><a href="source/postprocessors/ExposedSideAverageValue.html">ExposedSideAverageValue</a>Computes the average value of a variable on the exposed portion of a sideset. Note that this cannot be used on the centerline of an axisymmetric model.</li><li class="collection-item"><a href="source/userobjects/FunctorGapFluxModelConduction.html">FunctorGapFluxModelConduction</a>Gap flux model for varying gap conductance using a functor for temperature.</li><li class="collection-item"><a href="source/userobjects/FunctorGapFluxModelRadiation.html">FunctorGapFluxModelRadiation</a>Gap flux model for heat transfer across a gap due to radiation, based on the diffusion approximation. Uses a temperature functor.</li><li class="collection-item"><a href="source/userobjects/GapFluxModelConduction.html">GapFluxModelConduction</a>Gap flux model for varying gap conductance using a coupled variable for temperature</li><li class="collection-item"><a href="source/userobjects/GapFluxModelPressureDependentConduction.html">GapFluxModelPressureDependentConduction</a>Heat flux model across a closed gap to calculate the conductance between two solid materials</li><li class="collection-item"><a href="source/userobjects/GapFluxModelRadiation.html">GapFluxModelRadiation</a>Gap flux model for heat conduction across a gap due to radiation, based on the diffusion approximation. Uses a coupled temperature variable.</li><li class="collection-item"><a href="source/userobjects/GapFluxModelRadiative.html">GapFluxModelRadiative</a>Gap flux demonstration model for radiative heat conductance</li><li class="collection-item"><a href="source/userobjects/GapFluxModelSimple.html">GapFluxModelSimple</a>Gap flux model with a constant conductance</li><li class="collection-item"><a href="source/postprocessors/GrayLambertSurfaceRadiationPP.html">GrayLambertSurfaceRadiationPP</a>This postprocessor allows to extract radiosity, heat flux density, and temperature from the GrayLambertSurfaceRadiationBase object.</li><li class="collection-item"><a href="source/postprocessors/HomogenizedThermalConductivity.html">HomogenizedThermalConductivity</a>Postprocessor for asymptotic expansion homogenization for thermal conductivity</li><li class="collection-item"><a href="source/userobjects/RayTracingViewFactor.html">RayTracingViewFactor</a>Computes view factors for arbitrary geometries using raytracing.</li><li class="collection-item"><a href="source/userobjects/SelfShadowSideUserObject.html">SelfShadowSideUserObject</a>Compute the illumination status for a self shadowing sideset</li><li class="collection-item"><a href="source/postprocessors/ThermalConductivity.html">ThermalConductivity</a>Computes the average value of a variable on a sideset. Note that this cannot be used on the centerline of an axisymmetric model.</li><li class="collection-item"><a href="source/userobjects/UnobstructedPlanarViewFactor.html">UnobstructedPlanarViewFactor</a>Computes the view factors for planar faces in unubstructed radiative heat transfer.</li><li class="collection-item"><a href="source/userobjects/ViewFactorObjectSurfaceRadiation.html">ViewFactorObjectSurfaceRadiation</a>ViewFactorObjectSurfaceRadiation computes radiative heat transfer between side sets and the view factors are computed by a ViewFactor object</li><li class="collection-item"><a href="source/postprocessors/ViewFactorPP.html">ViewFactorPP</a>This postprocessor allows to extract view factors from ViewFactor userobjects.</li><li class="collection-item"><a href="source/userobjects/ViewFactorRayStudy.html">ViewFactorRayStudy</a>This ray study is used to compute view factors in cavities with obstruction. It sends out rays from surfaces bounding the radiation cavity into a set of directions determined by an angular quadrature. The rays are tracked and view factors are computed by determining the surface where the ray dies.</li><li class="collection-header">Fluid Properties App</li><li class="collection-item"><a href="source/userobjects/FluidPropertiesInterrogator.html">FluidPropertiesInterrogator</a>User object for querying a single-phase or two-phase fluid properties object</li></ul></section><section class="scrollspy" id="da907588-444e-4eeb-9772-bbbc4ffa4130" data-section-level="2" data-section-text="Variables"><h2 id="variables"><a href="syntax/Variables/index.html">Variables</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddVariableAction.html">AddVariableAction</a>Add a non-linear variable to the simulation.</li><li class="collection-item"><a href="source/actions/CopyNodalVarsAction.html">CopyNodalVarsAction</a>Copies variable information from a file.</li><li class="collection-item"><a href="source/variables/ArrayMooseVariable.html">ArrayMooseVariable</a>Used for grouping standard field variables with the same finite element family and order</li><li class="collection-item"><a href="source/variables/MooseVariable.html">MooseVariable</a>Represents standard field variables, e.g. Lagrange, Hermite, or non-constant Monomials</li><li class="collection-item"><a href="source/variables/MooseVariableBase.html">MooseVariableBase</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/MooseVariableConstMonomial.html">MooseVariableConstMonomial</a>Specialization for constant monomials that avoids unnecessary loops</li><li class="collection-item"><a href="source/variables/MooseVariableFV.html">MooseVariableFVReal</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/MooseVariableScalar.html">MooseVariableScalar</a>Moose wrapper class around scalar variables</li><li class="collection-item"><a href="source/variables/VectorMooseVariable.html">VectorMooseVariable</a>Represents vector field variables, e.g. Vector Lagrange or Nedelec</li><li class="collection-header">Navier Stokes App</li><li class="collection-item"><a href="source/variables/BernoulliPressureVariable.html">BernoulliPressureVariable</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/INSFVEnergyVariable.html">INSFVEnergyVariable</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/INSFVPressureVariable.html">INSFVPressureVariable</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/INSFVScalarFieldVariable.html">INSFVScalarFieldVariable</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/INSFVVelocityVariable.html">INSFVVelocityVariable</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/PINSFVSuperficialVelocityVariable.html">PINSFVSuperficialVelocityVariable</a>Base class for Moose variables. This should never be the terminal object type</li><li class="collection-item"><a href="source/variables/PiecewiseConstantVariable.html">PiecewiseConstantVariable</a>Base class for Moose variables. This should never be the terminal object type</li></ul></section><section class="scrollspy" id="6709ab78-a15e-44bf-b006-ba7bf44d2bb3" data-section-level="2" data-section-text="VectorPostprocessors"><h2 id="vectorpostprocessors"><a href="syntax/VectorPostprocessors/index.html">VectorPostprocessors</a></h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="source/actions/AddVectorPostprocessorAction.html">AddVectorPostprocessorAction</a>Add a VectorPostprocessor object to the simulation.</li><li class="collection-item"><a href="source/vectorpostprocessors/CSVReader.html">CSVReader</a>Converts columns of a CSV file into vectors of a VectorPostprocessor.</li><li class="collection-item"><a href="source/vectorpostprocessors/ConstantVectorPostprocessor.html">ConstantVectorPostprocessor</a>Populate constant VectorPostprocessorValue directly from input file.</li><li class="collection-item"><a href="source/vectorpostprocessors/CylindricalAverage.html">CylindricalAverage</a>Compute a cylindrical average of a variableas a function of radius throughout the simulation domain.</li><li class="collection-item"><a href="source/vectorpostprocessors/Eigenvalues.html">Eigenvalues</a>Returns the Eigen values from the nonlinear Eigen system.</li><li class="collection-item"><a href="source/vectorpostprocessors/ElementValueSampler.html">ElementValueSampler</a>Samples values of elemental variable(s).</li><li class="collection-item"><a href="source/vectorpostprocessors/ElementVariablesDifferenceMax.html">ElementVariablesDifferenceMax</a>Computes the largest difference between two variable fields.</li><li class="collection-item"><a href="source/vectorpostprocessors/ElementsAlongLine.html">ElementsAlongLine</a>Outputs the IDs of every element intersected by a user-defined line</li><li class="collection-item"><a href="source/vectorpostprocessors/ElementsAlongPlane.html">ElementsAlongPlane</a>Outputs the IDs of every element intersected by a user-defined plane</li><li class="collection-item"><a href="source/vectorpostprocessors/ExtraIDIntegralVectorPostprocessor.html">ExtraIDIntegralVectorPostprocessor</a>Integrates variables based on extra element IDs</li><li class="collection-item"><a href="source/vectorpostprocessors/HistogramVectorPostprocessor.html">HistogramVectorPostprocessor</a>Compute a histogram for each column of a VectorPostprocessor</li><li class="collection-item"><a href="source/vectorpostprocessors/IntersectionPointsAlongLine.html">IntersectionPointsAlongLine</a>Get the intersection points for all of the elements that are intersected by a line.</li><li class="collection-item"><a href="source/vectorpostprocessors/LeastSquaresFit.html">LeastSquaresFit</a>Performs a polynomial least squares fit on the data contained in another VectorPostprocessor</li><li class="collection-item"><a href="source/vectorpostprocessors/LeastSquaresFitHistory.html">LeastSquaresFitHistory</a>Performs a polynomial least squares fit on the data contained in another VectorPostprocessor and stores the full time history of the coefficients</li><li class="collection-item"><a href="source/vectorpostprocessors/LineFunctionSampler.html">LineFunctionSampler</a>Sample one or more functions along a line.</li><li class="collection-item"><a href="source/vectorpostprocessors/LineMaterialRealSampler.html">LineMaterialRealSampler</a>Samples real-valued material properties for all quadrature points in all elements that are intersected by a specified line</li><li class="collection-item"><a href="source/vectorpostprocessors/LineValueSampler.html">LineValueSampler</a>Samples variable(s) along a specified line</li><li class="collection-item"><a href="source/vectorpostprocessors/MaterialVectorPostprocessor.html">MaterialVectorPostprocessor</a>Records all scalar material properties of a material object on elements at the indicated execution points.</li><li class="collection-item"><a href="source/userobjects/NearestPointIntegralVariablePostprocessor.html">NearestPointIntegralVariablePostprocessor</a>Compute element variable integrals for nearest-point based subdomains</li><li class="collection-item"><a href="source/vectorpostprocessors/NodalValueSampler.html">NodalValueSampler</a>Samples values of nodal variable(s).</li><li class="collection-item"><a href="source/vectorpostprocessors/PointValueSampler.html">PointValueSampler</a>Sample a variable at specific points.</li><li class="collection-item"><a href="source/vectorpostprocessors/SideValueSampler.html">SideValueSampler</a>Sample variable(s) along a sideset, internal or external.</li><li class="collection-item"><a href="source/vectorpostprocessors/SidesetInfoVectorPostprocessor.html">SidesetInfoVectorPostprocessor</a>This VectorPostprocessor collects meta data for provided sidesets.</li><li class="collection-item"><a href="source/vectorpostprocessors/SpatialUserObjectVectorPostprocessor.html">SpatialUserObjectVectorPostprocessor</a>Outputs the values of a spatial user object in the order of the specified spatial points</li><li class="collection-item"><a href="source/vectorpostprocessors/SphericalAverage.html">SphericalAverage</a>Compute a spherical average of a variable as a function of radius throughout the simulation domain.</li><li class="collection-item"><a href="source/vectorpostprocessors/VariableValueVolumeHistogram.html">VariableValueVolumeHistogram</a>Compute a histogram of volume fractions binned according to variable values.</li><li class="collection-item"><a href="source/vectorpostprocessors/VectorMemoryUsage.html">VectorMemoryUsage</a>Get memory stats for all ranks in the simulation</li><li class="collection-item"><a href="source/vectorpostprocessors/VectorOfPostprocessors.html">VectorOfPostprocessors</a>Outputs the values of an arbitrary user-specified set of postprocessors as a vector in the order specified by the user</li><li class="collection-item"><a href="source/vectorpostprocessors/VariableValueVolumeHistogram.html">VolumeHistogram</a>Compute a histogram of volume fractions binned according to variable values.</li><li class="collection-item"><a href="source/vectorpostprocessors/WorkBalance.html">WorkBalance</a>Computes several metrics for workload balance per processor</li><li class="collection-header">Navier Stokes App</li><li class="collection-item"><a href="source/vectorpostprocessors/WaveSpeedVPP.html">WaveSpeedVPP</a>Extracts wave speeds from HLLC userobject for a given face</li><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="source/vectorpostprocessors/InteractionIntegral.html">ADInteractionIntegral</a>Computes the interaction integral, which is used to compute various fracture mechanics parameters at a crack tip, including KI, KII, KIII, and the T stress.</li><li class="collection-item"><a href="source/vectorpostprocessors/InteractionIntegral.html">InteractionIntegral</a>Computes the interaction integral, which is used to compute various fracture mechanics parameters at a crack tip, including KI, KII, KIII, and the T stress.</li><li class="collection-item"><a href="source/vectorpostprocessors/JIntegral.html">JIntegral</a>Computes the J-Integral, a measure of the strain energy release rate at a crack tip, which can be used as a criterion for fracture growth. It can, alternatively, compute the C(t) integral</li><li class="collection-item"><a href="source/vectorpostprocessors/LineMaterialRankTwoSampler.html">LineMaterialRankTwoSampler</a>Access a component of a RankTwoTensor</li><li class="collection-item"><a href="source/vectorpostprocessors/LineMaterialRankTwoScalarSampler.html">LineMaterialRankTwoScalarSampler</a>Compute a scalar property of a RankTwoTensor</li><li class="collection-item"><a href="source/vectorpostprocessors/MixedModeEquivalentK.html">MixedModeEquivalentK</a>Computes the mixed-mode stress intensity factor given the <span class="moose-katex-inline-equation" id="moose-equation-98b7c122-2be1-447a-992f-42e67a4ef30c"><script>var element = document.getElementById("moose-equation-98b7c122-2be1-447a-992f-42e67a4ef30c");katex.render("K_I", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, <span class="moose-katex-inline-equation" id="moose-equation-ba7f47d2-c905-4b25-a781-a899a90bec88"><script>var element = document.getElementById("moose-equation-ba7f47d2-c905-4b25-a781-a899a90bec88");katex.render("K_{II}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span>, and <span class="moose-katex-inline-equation" id="moose-equation-13b00151-de22-4a81-9730-cfa37d8c8b2a"><script>var element = document.getElementById("moose-equation-13b00151-de22-4a81-9730-cfa37d8c8b2a");katex.render("K_{III}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> stress intensity factors</li><li class="collection-header">Ray Tracing App</li><li class="collection-item"><a href="source/vectorpostprocessors/PerProcessorRayTracingResultsVectorPostprocessor.html">PerProcessorRayTracingResultsVectorPostprocessor</a>Accumulates ray tracing results (information about the trace) on a per-processor basis.</li><li class="collection-header">Heat Conduction App</li><li class="collection-item"><a href="source/vectorpostprocessors/SurfaceRadiationVectorPostprocessor.html">SurfaceRadiationVectorPostprocessor</a>VectorPostprocessor for accessing information stored in surface radiation user object</li><li class="collection-item"><a href="source/vectorpostprocessors/ViewfactorVectorPostprocessor.html">ViewfactorVectorPostprocessor</a>VectorPostprocessor for accessing view factors from GrayLambertSurfaceRadiationBase UO</li></ul></section></section></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#ed959f78-9210-4aa9-a8c4-1d811acd8351" class="tooltipped" data-position="left" data-tooltip="The Eel syntax">The Eel syntax</a></li><li><a href="#8c5ca366-098f-4b20-b14f-fd22c9a414aa" class="tooltipped" data-position="left" data-tooltip="BCs">BCs</a></li><li><a href="#e354e966-8799-4b8b-9870-807832efcad7" class="tooltipped" data-position="left" data-tooltip="FunctorMaterials">FunctorMaterials</a></li><li><a href="#b001c97e-7e24-40ee-a320-97fef005dff9" class="tooltipped" data-position="left" data-tooltip="InterfaceKernels">InterfaceKernels</a></li><li><a href="#3aa94de6-66cc-49c4-b2a4-f1007d6f391e" class="tooltipped" data-position="left" data-tooltip="Kernels">Kernels</a></li><li><a href="#f735fcb1-8b79-44f6-bc86-7aec21998f57" class="tooltipped" data-position="left" data-tooltip="Materials">Materials</a></li><li><a href="#78cc7aab-e122-46eb-86f7-cd938e9045c5" class="tooltipped" data-position="left" data-tooltip="The complete list of syntax">The complete list of syntax</a></li><li><a href="#de3a9a8f-67a2-4230-b202-9a7ebb6e90dd" class="tooltipped" data-position="left" data-tooltip="Adaptivity">Adaptivity</a></li><li><a href="#bd02fc45-603c-4984-8408-3c2412388a27" class="tooltipped" data-position="left" data-tooltip="AuxKernels">AuxKernels</a></li><li><a href="#e867c560-9c72-41a8-87bf-07855e7b6670" class="tooltipped" data-position="left" data-tooltip="AuxScalarKernels">AuxScalarKernels</a></li><li><a href="#22c465ed-6f63-4bdf-a71b-0f14964e443d" class="tooltipped" data-position="left" data-tooltip="AuxVariables">AuxVariables</a></li><li><a href="#0bea22c2-960e-4320-82a1-8d23fdc89294" class="tooltipped" data-position="left" data-tooltip="BCs">BCs</a></li><li><a href="#6aa6c69e-b58d-4202-9f0d-5520c38713c3" class="tooltipped" data-position="left" data-tooltip="Bounds">Bounds</a></li><li><a href="#0c6c9d05-4742-48f5-bc05-2a6bc72ee49d" class="tooltipped" data-position="left" data-tooltip="Constraints">Constraints</a></li><li><a href="#bdfe1ee8-26dc-4d7f-84bb-e309d57c50b4" class="tooltipped" data-position="left" data-tooltip="Controls">Controls</a></li><li><a href="#3ef72d18-6843-4797-8fdb-98d7d338401a" class="tooltipped" data-position="left" data-tooltip="DGKernels">DGKernels</a></li><li><a href="#ff9cba35-2c76-4dbc-b2bc-869452aa6db2" class="tooltipped" data-position="left" data-tooltip="Dampers">Dampers</a></li><li><a href="#6c3c96fd-f647-4a62-a06c-b12070ec71d1" class="tooltipped" data-position="left" data-tooltip="Debug">Debug</a></li><li><a href="#96e33361-f57d-40d9-8877-814cece5041e" class="tooltipped" data-position="left" data-tooltip="DeprecatedBlock">DeprecatedBlock</a></li><li><a href="#d3266639-eb3d-45b8-830f-aac30585a5b1" class="tooltipped" data-position="left" data-tooltip="DiracKernels">DiracKernels</a></li><li><a href="#39fab3bb-3583-4b98-a05e-30e977e89f28" class="tooltipped" data-position="left" data-tooltip="Distributions">Distributions</a></li><li><a href="#8a89bd14-a122-4d22-8dee-000394adbc6c" class="tooltipped" data-position="left" data-tooltip="DomainIntegral">DomainIntegral</a></li><li><a href="#dd549210-517c-47f3-af6c-f154312a4689" class="tooltipped" data-position="left" data-tooltip="Executioner">Executioner</a></li><li><a href="#09dcb902-5a30-44ff-ae60-368cd5e65cac" class="tooltipped" data-position="left" data-tooltip="Executors">Executors</a></li><li><a href="#0ac97f4f-e430-4f06-93c4-3f7e1a9a157c" class="tooltipped" data-position="left" data-tooltip="FVBCs">FVBCs</a></li><li><a href="#03e9f153-924e-4937-882d-0d78cf7d27c7" class="tooltipped" data-position="left" data-tooltip="FVInterfaceKernels">FVInterfaceKernels</a></li><li><a href="#a4a75dbb-3a1b-4d8d-9e0b-4a0b80452d82" class="tooltipped" data-position="left" data-tooltip="FVKernels">FVKernels</a></li><li><a href="#9bb74a53-6dd7-4286-a420-0ccda4186e66" class="tooltipped" data-position="left" data-tooltip="FluidProperties">FluidProperties</a></li><li><a href="#9d148718-bfc0-4d1e-90ca-dc679f65b386" class="tooltipped" data-position="left" data-tooltip="FluidPropertiesInterrogator">FluidPropertiesInterrogator</a></li><li><a href="#731af09e-bce0-4060-a555-b86d8cf38f1c" class="tooltipped" data-position="left" data-tooltip="Functions">Functions</a></li><li><a href="#c069ba01-18e3-427e-9a08-b41755b0813c" class="tooltipped" data-position="left" data-tooltip="FunctorMaterials">FunctorMaterials</a></li><li><a href="#0b3b7d96-845f-44d1-bd6b-6ee83abde6e2" class="tooltipped" data-position="left" data-tooltip="GlobalParams">GlobalParams</a></li><li><a href="#85e381b8-b57c-41ff-9616-caddef737c26" class="tooltipped" data-position="left" data-tooltip="GrayDiffuseRadiation">GrayDiffuseRadiation</a></li><li><a href="#496be166-bc01-4198-a23d-4d8a7f09b5c4" class="tooltipped" data-position="left" data-tooltip="ICs">ICs</a></li><li><a href="#bec349ba-c25a-434e-a0d8-eb2a0c7168fe" class="tooltipped" data-position="left" data-tooltip="InterfaceKernels">InterfaceKernels</a></li><li><a href="#59bbe651-eb03-4894-aff1-a622dadb9ea0" class="tooltipped" data-position="left" data-tooltip="Kernels">Kernels</a></li><li><a href="#25626631-36bd-4bfc-a355-853281955081" class="tooltipped" data-position="left" data-tooltip="Materials">Materials</a></li><li><a href="#520cd38d-6dbd-43f9-a827-154644d60c06" class="tooltipped" data-position="left" data-tooltip="Mesh">Mesh</a></li><li><a href="#65e03989-dbd0-4934-9a08-0fbf95a48fdc" class="tooltipped" data-position="left" data-tooltip="Modules">Modules</a></li><li><a href="#05317cab-7a5f-46d9-8e7e-e8d235a2cdfb" class="tooltipped" data-position="left" data-tooltip="MortarGapHeatTransfer">MortarGapHeatTransfer</a></li><li><a href="#2f9d2807-df83-47c0-9049-61aa6eb20139" class="tooltipped" data-position="left" data-tooltip="MultiApps">MultiApps</a></li><li><a href="#e9df0f13-3c39-4b67-bf74-e7e4ca27a0c0" class="tooltipped" data-position="left" data-tooltip="NodalKernels">NodalKernels</a></li><li><a href="#e1a5b14e-27ad-42ee-a2e8-abbc02d8b089" class="tooltipped" data-position="left" data-tooltip="NodalNormals">NodalNormals</a></li><li><a href="#fa8a2361-0b91-4f22-8a5a-cd7cd9fa3659" class="tooltipped" data-position="left" data-tooltip="Outputs">Outputs</a></li><li><a href="#2eeaed53-8cf8-4fc7-8015-5dbf94ccc01c" class="tooltipped" data-position="left" data-tooltip="Positions">Positions</a></li><li><a href="#18d0fefe-1b33-43f1-b143-ed62cbce47f9" class="tooltipped" data-position="left" data-tooltip="Postprocessors">Postprocessors</a></li><li><a href="#2ecd1045-1def-4431-9bb3-29246665f267" class="tooltipped" data-position="left" data-tooltip="Preconditioning">Preconditioning</a></li><li><a href="#42b1ae75-0055-4431-ad31-85e493744465" class="tooltipped" data-position="left" data-tooltip="Problem">Problem</a></li><li><a href="#df2aed87-1654-4d19-8a3f-ad574c1f44c7" class="tooltipped" data-position="left" data-tooltip="RayBCs">RayBCs</a></li><li><a href="#c708e091-0a62-45c4-a8f3-6a13ab2eeb00" class="tooltipped" data-position="left" data-tooltip="RayKernels">RayKernels</a></li><li><a href="#86961cb1-22af-4a53-b0bf-7a769d1301ff" class="tooltipped" data-position="left" data-tooltip="Reporters">Reporters</a></li><li><a href="#a6c5e22e-e21d-4d3b-9774-89fdfb8a3c7e" class="tooltipped" data-position="left" data-tooltip="Samplers">Samplers</a></li><li><a href="#ade3bb00-d8a3-40f0-94a8-e8744e9bfdcf" class="tooltipped" data-position="left" data-tooltip="ScalarKernels">ScalarKernels</a></li><li><a href="#8b7d9d01-7361-4503-a478-71a5fbefbdb6" class="tooltipped" data-position="left" data-tooltip="ThermalContact">ThermalContact</a></li><li><a href="#bdd30d04-543b-4de4-8ca9-9ab99b14fd3b" class="tooltipped" data-position="left" data-tooltip="Times">Times</a></li><li><a href="#35983bfe-b5f9-431d-a634-5fc50bc3afcc" class="tooltipped" data-position="left" data-tooltip="Transfers">Transfers</a></li><li><a href="#563f092f-28e9-4763-9ddb-3682f71c5ef9" class="tooltipped" data-position="left" data-tooltip="UserObjects">UserObjects</a></li><li><a href="#da907588-444e-4eeb-9772-bbbc4ffa4130" class="tooltipped" data-position="left" data-tooltip="Variables">Variables</a></li><li><a href="#6709ab78-a15e-44bf-b006-ba7bf44d2bb3" class="tooltipped" data-position="left" data-tooltip="VectorPostprocessors">VectorPostprocessors</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="contrib/prism/prism.min.js"></script><script type="text/javascript" src="js/init.js"></script><script type="text/javascript" src="js/navigation.js"></script><script type="text/javascript" src="contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="js/search_index.js"></script><script type="text/javascript" src="js/sqa_moose.js"></script>