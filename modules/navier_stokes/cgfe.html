<!DOCTYPE html><head><meta charset="UTF-8"><title>Continuous Galerkin Finite Element Navier Stokes | Eel</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Eel</a><a href="https://github.com/hugary1995/eel" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="../../eel.html">Documentation</a></li></ul><a href="#" class="sidenav-trigger" data-target="b799dab3-94ef-4966-817f-2687e781d271"><i class="material-icons">menu</i></a><ul class="sidenav" id="b799dab3-94ef-4966-817f-2687e781d271"><li><a href="../../eel.html">Documentation</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><span class="breadcrumb">modules</span><a href="." class="breadcrumb">navier_stokes</a><a href="#" class="breadcrumb">cgfe</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="8fb929f9-2b49-4ff0-994f-4891c3697f56" data-section-level="1" data-section-text="Continuous Galerkin Finite Element Navier Stokes"><h1 id="continuous-galerkin-finite-element-navier-stokes">Continuous Galerkin Finite Element Navier Stokes</h1><p>The CGFE method has been implemented to solve either the incompressible or compressible Navier-Stokes equations. The original CGFE method is usually not numerically stable for solving problems when the Peclet number is greater than 2. An SUPG (Streamline Upwind Petrov Galerkin) scheme is implemented for stabilized solution in smooth compressible flows. A low-diffusion, discontinuity/shock-capturing scheme is required but currently absent for the CGFE method to obtain non-oscillatory solutions of flow problems that contain contact discontinuity or shock waves. For compressible flow problems, users can choose the CGFE method only when the flow field is sufficiently smooth.</p><p>For incompressible flow, we have implemented both pressure-stabilized Petrov-Galerkin (PSPG) and streamline-upwind Petrov-Galerkin (SUPG) methods. The former stabilization allows use of equal order shape functions by introducing an on-diagonal dependence in the pressure equation, removing the saddle-point nature of the problem. The latter SUPG method allows simulation at much higher Reynolds numbers than if SUPG was not used. For an overview of the incompressible Navier-Stokes capability, please see the journal article <a href="https://www.sciencedirect.com/science/article/pii/S0965997817310591?via%3Dihub">here</a> or the pre-print <a href="https://arxiv.org/pdf/1710.08898.pdf">here</a>. Note that automatic differentiation versions of the incompressible objects have been created; these objects are currently not as performant as their hand-coded peers, but they can be used seamlessly in simulations with mesh deformation and are guaranteed to generate correct Jacobians.</p><p>Known limitations of AD INS implementation (these limitations are not present with the hand-coded INS implementation):</p><ul class="browser-default"><li><p>Stabilization methods will be inconsistent if a second order <code>LAGRANGE_VEC</code> basis is used for the velocity variable. This is because second derivatives are not implemented in libMesh for vector <code>FE</code> types, and consequently we cannot add in the contribution from the viscous term which includes a Laplacian operation</p></li></ul><section class="scrollspy" id="7428bf02-0b8a-4ac3-864d-05d27a99653d" data-section-level="2" data-section-text="Notes on INS RZ"><h2 id="notes-on-ins-rz">Notes on INS RZ</h2><p>Notes regarding INS RZ equations derivation:</p><ul class="browser-default"><li><p>Two additional terms are introduced into the r-component of the strong representation of the momentum equation viscous term </p></li><li><p>One additional term is introduced into the r-component of the weak representation of the momentum equation viscous term </p></li><li><p>One additional term is introduced into the z-component of the strong representation of the momentum equation viscous term </p></li><li><p>Zero additional terms are introduced into the z-component of the weak representation of the momentum equation viscous term </p></li><li><p>An additional pressure term will enter the weak form of the r-component of the momentum equation if the pressure term was integrated by parts. No additional terms appear in the strong form if the term is integrated by parts (integration by parts is a part of forming the weak form) </p></li><li><p>An additional term is introduced into the mass balance equation</p></li></ul><p>The derivation for the RZ weak form can be inspected <a href="../../media/jw-peterson-rz-derivation.pdf">here</a>.</p><section id="3f967584-2cb8-407c-8f9e-e80bb31006aa" data-section-level="3" data-section-text="RZ INS tests"><h3 id="rz-ins-tests">RZ INS tests</h3><p>For a sufficiently long channel, flow should be fully developed at the channel exit and <code>grad_u * normals</code> should be equal to zero. If that premise is true, <em>and</em> if the pressure is integrated by parts <em>and</em> a natural boundary condition is &quot;imposed&quot; on the outflow boundary, <em>then</em> the pressure at the outflow should also be zero.</p><p>In the RZ channel tests, for a steady simulation the volumetric inflow rate should be equal to the volumetric outflow rate. The inflow is equal to .3926991, which corresponds to the exact integral of</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-cf67132f-ea3c-45d1-acb6-d9ec1dd269d8"></span><script>var element = document.getElementById("moose-equation-cf67132f-ea3c-45d1-acb6-d9ec1dd269d8");katex.render("2 * \\pi * \\int_0^{0.5} (-4 * r^2 + 1) r \\mathrm{d}r", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span></p><p>where <span class="moose-katex-inline-equation" id="moose-equation-b03fc784-6941-4c38-a8a7-989df5fd22ab"><script>var element = document.getElementById("moose-equation-b03fc784-6941-4c38-a8a7-989df5fd22ab");katex.render("(-4 * r^2 + 1)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> represents the inlet function for the normal velocity component at the inlet. Below is a summary of the volumetric outflow for different INS formulations:</p><div form="['center', 'center']" recursive class="moose-table-div"><table><thead><tr><th style=";text-align:center">Formulation</th><th style=";text-align:center">Outflow</th></tr></thead><tbody><tr><td style=";text-align:center">Not integrated by parts, natural BC</td><td style=";text-align:center">.3926991</td></tr></tbody><tbody><tr><td style=";text-align:center">Integrated by parts, natural BC</td><td style=";text-align:center">.3926991</td></tr></tbody><tbody><tr><td style=";text-align:center">Not integrated by parts, NoBCBC</td><td style=";text-align:center">.3926993</td></tr></tbody><tbody><tr><td style=";text-align:center">Integrated by parts, NoBCBC</td><td style=";text-align:center">.3926993</td></tr></tbody></table></div><p>For the NoBCBC cases, if <code>Mesh/uniform_refine=2</code> is applied, then the outflow converges to the correct solution of .3926991. Note that the results in the above table are achieved whether using the standard variable, hand-coded Jacobian INS implementation or the vector variable, AD Jacobian INS implementation. In fact the steady tests for all of the four cases use the same gold files between the two implementations.</p></section><section id="e7e6ace7-347a-4849-b258-91034fc3d8e2" data-section-level="3" data-section-text="Stabilized RZ INS tests"><h3 id="stabilized-rz-ins-tests">Stabilized RZ INS tests</h3><p>Below is a summary of different stabilized INS RZ tests. A natural boundary condition is used on the outflow in all cases. Note that while a second order basis is capable of exactly capturing the quadratic character of the inlet flow function, a first order basis is not. Order in the below table refers to the velocity order.</p><div form="['center', 'center', 'center']" recursive class="moose-table-div"><table><thead><tr><th style=";text-align:center">Formulation</th><th style=";text-align:center">Inflow</th><th style=";text-align:center">Outflow</th></tr></thead><tbody><tr><td style=";text-align:center">AD, Not integrated by parts, first order, SUPG and PSPG</td><td style=";text-align:center">.3599742</td><td style=";text-align:center">.3384178</td></tr></tbody><tbody><tr><td style=";text-align:center">Hand-coded, Not integrated by parts, first order, SUPG and PSPG</td><td style=";text-align:center">.3599742</td><td style=";text-align:center">.3384178</td></tr></tbody><tbody><tr><td style=";text-align:center">AD, Integrated by parts, first order, SUPG and PSPG</td><td style=";text-align:center">.3599742</td><td style=";text-align:center">.3599742</td></tr></tbody><tbody><tr><td style=";text-align:center">Hand-coded, Integrated by parts, first order, SUPG and PSPG</td><td style=";text-align:center">.3599742</td><td style=";text-align:center">.3599742</td></tr></tbody><tbody><tr><td style=";text-align:center">AD, Not integrated by parts, second order, SUPG and PSPG</td><td style=";text-align:center">.3926991</td><td style=";text-align:center">.3756223</td></tr></tbody><tbody><tr><td style=";text-align:center">Hand-coded, Not integrated by parts, second order, SUPG and PSPG</td><td style=";text-align:center">.3926991</td><td style=";text-align:center">.3926991</td></tr></tbody><tbody><tr><td style=";text-align:center">AD, Integrated by parts, second order, SUPG and PSPG</td><td style=";text-align:center">.3926991</td><td style=";text-align:center">.3926991</td></tr></tbody><tbody><tr><td style=";text-align:center">Hand-coded, Integrated by parts, second order, SUPG and PSPG</td><td style=";text-align:center">.3926991</td><td style=";text-align:center">.3926991</td></tr></tbody></table></div><p>Notes on the above table:</p><ul class="browser-default"><li><p>All cases which have the incorrect result for the outflow approach the correct solution with mesh refinement </p></li><li><p>While the second order hand-coded cases achieve the correct result at the base level of mesh refinement, the equivalent AD cases do not. (Yes the global outflow variable for the integrated by parts case is accurate to the comparison tolerance, but an exodiff executed between the AD and hand-coded cases shows the files are different.) Given that the first order cases are identical (we just symlink between hand-coded and AD first-order cases in the gold directory), the difference has to be due to the inability to calculate second derivatives for vector variables, which leads to an inability to include the Laplacian of the velocity in the strong form of the momentum residual. For a first order basis, the inability to include the Laplacian terms induces no error. However, for the second order basis it does.</p></li></ul></section><section id="8343a84a-37fe-45d7-8fcd-444c5a8e9dc7" data-section-level="3" data-section-text="INS Recommendations"><h3 id="ins-recommendations">INS Recommendations</h3><ul class="browser-default"><li><p>If not computing on a displaced mesh, use the hand-coded INS implementation because it is slightly faster and it includes the Laplacian terms in SUPG and PSPG stabilization methods, meaning it is completely consistent and will exhibit less error in the finite element solution </p></li><li><p>If computing on a displaced mesh, use the AD implementation because it will include derivatives with respect to displacements in the Jacobian and the nonlinear solve will be more efficient. </p></li><li><p>If using the AD implementation, either run unstabilized with second order basis for the velocity and first order basis for the pressure, or if desiring stabilization use a first order basis for the velocity variable as it will not introduce any inconsistency. (Recall from above that the vector variable, AD implementation cannot currently include Laplacian terms. For a first order basis this incurs no error, but for a second order basis it does)</p></li></ul></section></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#7428bf02-0b8a-4ac3-864d-05d27a99653d" class="tooltipped" data-position="left" data-tooltip="Notes on INS RZ">Notes on INS RZ</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>